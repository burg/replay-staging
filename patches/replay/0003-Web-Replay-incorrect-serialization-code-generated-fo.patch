From 9b206f46c29aa14c73d83cff3b45bdd5b6f0c73a Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Tue, 15 Jul 2014 11:33:21 -0700
Subject: [PATCH] Web Replay: incorrect serialization code generated for enum
 classes inside class scope Need the bug URL (OOPS!).

Reviewed by NOBODY (OOPS!).

If an enum class is defined inside of a class scope, then the enum class
cannot be forward-declared and the relevant header should be included.
Some generated code used incorrectly-scoped enum values in this situation.

* replay/scripts/CodeGeneratorReplayInputs.py:
(Generator.generate_includes.declaration.is):
(Generator.generate_enum_trait_implementation.is):
(Generator.generate_enum_trait_implementation):

Tests:

* replay/scripts/tests/expected/generate-enums-with-same-base-name.json-TestReplayInputs.cpp: Rebaselined.
* replay/scripts/tests/expected/generate-enums-with-same-base-name.json-TestReplayInputs.h: Rebaselined.
* replay/scripts/tests/generate-enums-with-same-base-name.json: Add enum
class types to this test case.
---
 Source/JavaScriptCore/ChangeLog                    |  23 +++++
 .../replay/scripts/CodeGeneratorReplayInputs.py    |   8 +-
 ...s-with-same-base-name.json-TestReplayInputs.cpp | 110 ++++++++++++++++-----
 ...ums-with-same-base-name.json-TestReplayInputs.h |  47 ++++++---
 .../tests/generate-enums-with-same-base-name.json  |  26 ++++-
 5 files changed, 165 insertions(+), 49 deletions(-)

diff --git a/Source/JavaScriptCore/ChangeLog b/Source/JavaScriptCore/ChangeLog
index 3f3939f..8ec9b7d 100644
--- a/Source/JavaScriptCore/ChangeLog
+++ b/Source/JavaScriptCore/ChangeLog
@@ -1,12 +1,35 @@
 2014-07-15  Brian J. Burg  <burg@cs.washington.edu>
 
+        Web Replay: incorrect serialization code generated for enum classes inside class scope
+        Need the bug URL (OOPS!).
+
+        Reviewed by NOBODY (OOPS!).
+
+        If an enum class is defined inside of a class scope, then the enum class
+        cannot be forward-declared and the relevant header should be included.
+        Some generated code used incorrectly-scoped enum values in this situation.
+
+        * replay/scripts/CodeGeneratorReplayInputs.py:
+        (Generator.generate_includes.declaration.is):
+        (Generator.generate_enum_trait_implementation.is):
+        (Generator.generate_enum_trait_implementation):
+
+        Tests:
+
+        * replay/scripts/tests/expected/generate-enums-with-same-base-name.json-TestReplayInputs.cpp: Rebaselined.
+        * replay/scripts/tests/expected/generate-enums-with-same-base-name.json-TestReplayInputs.h: Rebaselined.
+        * replay/scripts/tests/generate-enums-with-same-base-name.json: Add enum
+        class types to this test case.
+
+2014-07-15  Brian J. Burg  <burg@cs.washington.edu>
+
         Web Replay: vectors of characters should be base64-encoded
         Need the bug URL (OOPS!).
 
         Reviewed by NOBODY (OOPS!).
 
         Without this specialization, encode/decode methods try to create an
         array of single characters in JSON, rather than treating the
         vector as a binary blob.
 
         * replay/EncodedValue.cpp:
diff --git a/Source/JavaScriptCore/replay/scripts/CodeGeneratorReplayInputs.py b/Source/JavaScriptCore/replay/scripts/CodeGeneratorReplayInputs.py
index d12e9eb..6229bcb 100644
--- a/Source/JavaScriptCore/replay/scripts/CodeGeneratorReplayInputs.py
+++ b/Source/JavaScriptCore/replay/scripts/CodeGeneratorReplayInputs.py
@@ -628,21 +628,21 @@ class Generator:
 
         for _type in self._model.types:
             # Types in the "global" framework are implicitly declared and available in all namespaces.
             if _type.framework is Frameworks.Global:
                 continue
             # For RefCounted types, we reverse when to include the header so that the destructor can be
             # used in the header file.
             include_for_destructor = _type.mode is TypeModes.SHARED
             # Enums within classes cannot be forward declared, so we include
             # headers with the relevant class declaration.
-            include_for_enclosing_class = _type.is_enum() and _type.enclosing_class is not None
+            include_for_enclosing_class = _type.enclosing_class is not None
             # Include headers for types like URL and String which are copied, not owned or shared.
             include_for_copyable_member = _type.mode is TypeModes.HEAVY_SCALAR
             if (not includes_for_types) ^ (include_for_destructor or include_for_enclosing_class or include_for_copyable_member):
                 continue
 
             if self.target_framework != _type.framework:
                 lines.add("#include <%s>" % _type.header)
             else:
                 lines.add("#include \"%s\"" % os.path.basename(_type.header))
 
@@ -794,24 +794,24 @@ class Generator:
             'constructorFormalsList': self.generate_constructor_formals_list(_input),
         }
 
         return wrap_with_guard(Template(Templates.InputClassImplementation).substitute(template_arguments), _input.guard)
 
     def generate_enum_trait_implementation(self, _type):
         should_qualify_type = _type.framework != self.traits_framework
         prefix_components = []
         if should_qualify_type:
             prefix_components.append(_type.framework.setting('namespace'))
-        if _type.is_enum_class():
-            prefix_components.append(_type.type_name())
-        if _type.enclosing_class is not None:
+        if _type.is_enum() and _type.enclosing_class is not None:
             prefix_components.append(_type.enclosing_class)
+        elif _type.is_enum_class():
+            prefix_components.append(_type.type_name(qualified=False))
         prefix_components.append("")
         enum_prefix = "::".join(prefix_components)
         encodeLines = []
 
         if _type.is_enum():
             encode_template = Templates.EnumEncodeCase
             decode_template = Templates.EnumDecodeCase
             enum_trait_template = Templates.EnumTraitImplementation
         else:
             encode_template = Templates.EnumClassEncodeCase
diff --git a/Source/JavaScriptCore/replay/scripts/tests/expected/generate-enums-with-same-base-name.json-TestReplayInputs.cpp b/Source/JavaScriptCore/replay/scripts/tests/expected/generate-enums-with-same-base-name.json-TestReplayInputs.cpp
index 6b79631..43503b4 100644
--- a/Source/JavaScriptCore/replay/scripts/tests/expected/generate-enums-with-same-base-name.json-TestReplayInputs.cpp
+++ b/Source/JavaScriptCore/replay/scripts/tests/expected/generate-enums-with-same-base-name.json-TestReplayInputs.cpp
@@ -28,114 +28,172 @@
 // by the script: JavaScriptCore/replay/scripts/CodeGeneratorReplayInputs.py
 
 #include "config.h"
 #include "generate-enums-with-same-base-name.json-TestReplayInputs.h"
 
 #if ENABLE(WEB_REPLAY)
 #include "InternalNamespaceImplIncludeDummy.h"
 #include <platform/ExternalNamespaceImplIncludeDummy.h>
 
 namespace Test {
-FormCombo::FormCombo(PlatformEvent::Type eventType, FormData::Type formType)
+FormCombo::FormCombo(PlatformEvent1::Type eventType1, PlatformEvent2::Type eventType2, FormData1::Type formType1, FormData2::Type formType2)
     : NondeterministicInput<FormCombo>()
-    , m_eventType(eventType)
-    , m_formType(formType)
+    , m_eventType1(eventType1)
+    , m_eventType2(eventType2)
+    , m_formType1(formType1)
+    , m_formType2(formType2)
 {
 }
 
 FormCombo::~FormCombo()
 {
 }
 } // namespace Test
 
 namespace JSC {
 const AtomicString& InputTraits<Test::FormCombo>::type()
 {
     static NeverDestroyed<const AtomicString> type("FormCombo", AtomicString::ConstructFromLiteral);
     return type;
 }
 
 void InputTraits<Test::FormCombo>::encode(EncodedValue& encodedValue, const Test::FormCombo& input)
 {
-    encodedValue.put<PlatformEvent::Type>(ASCIILiteral("eventType"), input.eventType());
-    encodedValue.put<WebCore::FormData::Type>(ASCIILiteral("formType"), input.formType());
+    encodedValue.put<PlatformEvent1::Type>(ASCIILiteral("eventType1"), input.eventType1());
+    encodedValue.put<PlatformEvent2::Type>(ASCIILiteral("eventType2"), input.eventType2());
+    encodedValue.put<WebCore::FormData1::Type>(ASCIILiteral("formType1"), input.formType1());
+    encodedValue.put<WebCore::FormData2::Type>(ASCIILiteral("formType2"), input.formType2());
 }
 
 bool InputTraits<Test::FormCombo>::decode(EncodedValue& encodedValue, std::unique_ptr<Test::FormCombo>& input)
 {
-    PlatformEvent::Type eventType;
-    if (!encodedValue.get<PlatformEvent::Type>(ASCIILiteral("eventType"), eventType))
+    PlatformEvent1::Type eventType1;
+    if (!encodedValue.get<PlatformEvent1::Type>(ASCIILiteral("eventType1"), eventType1))
         return false;
 
-    WebCore::FormData::Type formType;
-    if (!encodedValue.get<WebCore::FormData::Type>(ASCIILiteral("formType"), formType))
+    PlatformEvent2::Type eventType2;
+    if (!encodedValue.get<PlatformEvent2::Type>(ASCIILiteral("eventType2"), eventType2))
         return false;
 
-    input = std::make_unique<Test::FormCombo>(eventType, formType);
+    WebCore::FormData1::Type formType1;
+    if (!encodedValue.get<WebCore::FormData1::Type>(ASCIILiteral("formType1"), formType1))
+        return false;
+
+    WebCore::FormData2::Type formType2;
+    if (!encodedValue.get<WebCore::FormData2::Type>(ASCIILiteral("formType2"), formType2))
+        return false;
+
+    input = std::make_unique<Test::FormCombo>(eventType1, eventType2, formType1, formType2);
     return true;
 }
-EncodedValue EncodingTraits<WebCore::FormData::Type>::encodeValue(const WebCore::FormData::Type& enumValue)
+EncodedValue EncodingTraits<WebCore::FormData1::Type>::encodeValue(const WebCore::FormData1::Type& enumValue)
 {
     EncodedValue encodedValue = EncodedValue::createArray();
-    if (enumValue & WebCore::FormData::Text) {
+    if (enumValue & WebCore::FormData1::Text) {
         encodedValue.append<String>(ASCIILiteral("Text"));
-        if (enumValue == WebCore::FormData::Text)
+        if (enumValue == WebCore::FormData1::Text)
             return encodedValue;
     }
-    if (enumValue & WebCore::FormData::Blob) {
+    if (enumValue & WebCore::FormData1::Blob) {
         encodedValue.append<String>(ASCIILiteral("Blob"));
-        if (enumValue == WebCore::FormData::Blob)
+        if (enumValue == WebCore::FormData1::Blob)
             return encodedValue;
     }
     return encodedValue;
 }
 
-bool EncodingTraits<WebCore::FormData::Type>::decodeValue(EncodedValue& encodedValue, WebCore::FormData::Type& enumValue)
+bool EncodingTraits<WebCore::FormData1::Type>::decodeValue(EncodedValue& encodedValue, WebCore::FormData1::Type& enumValue)
 {
     Vector<String> enumStrings;
     if (!EncodingTraits<Vector<String>>::decodeValue(encodedValue, enumStrings))
         return false;
 
     for (String enumString : enumStrings) {
         if (enumString == "Text")
-            enumValue = static_cast<WebCore::FormData::Type>(enumValue | WebCore::FormData::Text);
+            enumValue = static_cast<WebCore::FormData1::Type>(enumValue | WebCore::FormData1::Text);
         if (enumString == "Blob")
-            enumValue = static_cast<WebCore::FormData::Type>(enumValue | WebCore::FormData::Blob);
+            enumValue = static_cast<WebCore::FormData1::Type>(enumValue | WebCore::FormData1::Blob);
     }
 
     return true;
 }
 
-EncodedValue EncodingTraits<PlatformEvent::Type>::encodeValue(const PlatformEvent::Type& enumValue)
+EncodedValue EncodingTraits<WebCore::FormData2::Type>::encodeValue(const WebCore::FormData2::Type& enumValue)
+{
+    switch (enumValue) {
+    case WebCore::FormData2::Type::Text: return EncodedValue::createString("Text");
+    case WebCore::FormData2::Type::Blob: return EncodedValue::createString("Blob");
+    default: ASSERT_NOT_REACHED(); return EncodedValue::createString("Error!");
+    }
+}
+
+bool EncodingTraits<WebCore::FormData2::Type>::decodeValue(EncodedValue& encodedValue, WebCore::FormData2::Type& enumValue)
+{
+    String enumString = encodedValue.convertTo<String>();
+    if (enumString == "Text") {
+        enumValue = WebCore::FormData2::Type::Text;
+        return true;
+    }
+    if (enumString == "Blob") {
+        enumValue = WebCore::FormData2::Type::Blob;
+        return true;
+    }
+    return false;
+}
+
+EncodedValue EncodingTraits<PlatformEvent1::Type>::encodeValue(const PlatformEvent1::Type& enumValue)
 {
     EncodedValue encodedValue = EncodedValue::createArray();
-    if (enumValue & PlatformEvent::Mouse) {
+    if (enumValue & PlatformEvent1::Mouse) {
         encodedValue.append<String>(ASCIILiteral("Mouse"));
-        if (enumValue == PlatformEvent::Mouse)
+        if (enumValue == PlatformEvent1::Mouse)
             return encodedValue;
     }
-    if (enumValue & PlatformEvent::Keyboard) {
+    if (enumValue & PlatformEvent1::Keyboard) {
         encodedValue.append<String>(ASCIILiteral("Keyboard"));
-        if (enumValue == PlatformEvent::Keyboard)
+        if (enumValue == PlatformEvent1::Keyboard)
             return encodedValue;
     }
     return encodedValue;
 }
 
-bool EncodingTraits<PlatformEvent::Type>::decodeValue(EncodedValue& encodedValue, PlatformEvent::Type& enumValue)
+bool EncodingTraits<PlatformEvent1::Type>::decodeValue(EncodedValue& encodedValue, PlatformEvent1::Type& enumValue)
 {
     Vector<String> enumStrings;
     if (!EncodingTraits<Vector<String>>::decodeValue(encodedValue, enumStrings))
         return false;
 
     for (String enumString : enumStrings) {
         if (enumString == "Mouse")
-            enumValue = static_cast<PlatformEvent::Type>(enumValue | PlatformEvent::Mouse);
+            enumValue = static_cast<PlatformEvent1::Type>(enumValue | PlatformEvent1::Mouse);
         if (enumString == "Keyboard")
-            enumValue = static_cast<PlatformEvent::Type>(enumValue | PlatformEvent::Keyboard);
+            enumValue = static_cast<PlatformEvent1::Type>(enumValue | PlatformEvent1::Keyboard);
     }
 
     return true;
 }
+
+EncodedValue EncodingTraits<PlatformEvent2::Type>::encodeValue(const PlatformEvent2::Type& enumValue)
+{
+    switch (enumValue) {
+    case PlatformEvent2::Type::Mouse: return EncodedValue::createString("Mouse");
+    case PlatformEvent2::Type::Keyboard: return EncodedValue::createString("Keyboard");
+    default: ASSERT_NOT_REACHED(); return EncodedValue::createString("Error!");
+    }
+}
+
+bool EncodingTraits<PlatformEvent2::Type>::decodeValue(EncodedValue& encodedValue, PlatformEvent2::Type& enumValue)
+{
+    String enumString = encodedValue.convertTo<String>();
+    if (enumString == "Mouse") {
+        enumValue = PlatformEvent2::Type::Mouse;
+        return true;
+    }
+    if (enumString == "Keyboard") {
+        enumValue = PlatformEvent2::Type::Keyboard;
+        return true;
+    }
+    return false;
+}
 } // namespace JSC
 
 #endif // ENABLE(WEB_REPLAY)
diff --git a/Source/JavaScriptCore/replay/scripts/tests/expected/generate-enums-with-same-base-name.json-TestReplayInputs.h b/Source/JavaScriptCore/replay/scripts/tests/expected/generate-enums-with-same-base-name.json-TestReplayInputs.h
index d734076..37b4847 100644
--- a/Source/JavaScriptCore/replay/scripts/tests/expected/generate-enums-with-same-base-name.json-TestReplayInputs.h
+++ b/Source/JavaScriptCore/replay/scripts/tests/expected/generate-enums-with-same-base-name.json-TestReplayInputs.h
@@ -26,63 +26,82 @@
 
 // DO NOT EDIT THIS FILE. It is automatically generated from generate-enums-with-same-base-name.json
 // by the script: JavaScriptCore/replay/scripts/CodeGeneratorReplayInputs.py
 
 #ifndef generate_enums_with_same_base_name_json_TestReplayInputs_h
 #define generate_enums_with_same_base_name_json_TestReplayInputs_h
 
 #if ENABLE(WEB_REPLAY)
 #include "InternalNamespaceHeaderIncludeDummy.h"
 #include <platform/ExternalNamespaceHeaderIncludeDummy.h>
-#include <replay/FormData.h>
+#include <replay/FormData1.h>
+#include <replay/FormData2.h>
 #include <replay/PlatformEvent.h>
 
 
 
 namespace Test {
 class FormCombo;
 } // namespace Test
 
 namespace JSC {
 template<> struct InputTraits<Test::FormCombo> {
     static InputQueue queue() { return InputQueue::ScriptMemoizedData; }
     static const AtomicString& type();
 
     static void encode(JSC::EncodedValue&, const Test::FormCombo&);
     static bool decode(JSC::EncodedValue&, std::unique_ptr<Test::FormCombo>&);
 };
-template<> struct EncodingTraits<WebCore::FormData::Type> {
-    typedef WebCore::FormData::Type DecodedType;
+template<> struct EncodingTraits<WebCore::FormData1::Type> {
+    typedef WebCore::FormData1::Type DecodedType;
 
-    static EncodedValue encodeValue(const WebCore::FormData::Type& value);
-    static bool decodeValue(EncodedValue&, WebCore::FormData::Type& value);
+    static EncodedValue encodeValue(const WebCore::FormData1::Type& value);
+    static bool decodeValue(EncodedValue&, WebCore::FormData1::Type& value);
 };
 
-template<> struct EncodingTraits<PlatformEvent::Type> {
-    typedef PlatformEvent::Type DecodedType;
+template<> struct EncodingTraits<WebCore::FormData2::Type> {
+    typedef WebCore::FormData2::Type DecodedType;
 
-    static EncodedValue encodeValue(const PlatformEvent::Type& value);
-    static bool decodeValue(EncodedValue&, PlatformEvent::Type& value);
+    static EncodedValue encodeValue(const WebCore::FormData2::Type& value);
+    static bool decodeValue(EncodedValue&, WebCore::FormData2::Type& value);
+};
+
+template<> struct EncodingTraits<PlatformEvent1::Type> {
+    typedef PlatformEvent1::Type DecodedType;
+
+    static EncodedValue encodeValue(const PlatformEvent1::Type& value);
+    static bool decodeValue(EncodedValue&, PlatformEvent1::Type& value);
+};
+
+template<> struct EncodingTraits<PlatformEvent2::Type> {
+    typedef PlatformEvent2::Type DecodedType;
+
+    static EncodedValue encodeValue(const PlatformEvent2::Type& value);
+    static bool decodeValue(EncodedValue&, PlatformEvent2::Type& value);
 };
 } // namespace JSC
 
 namespace Test {
 class FormCombo : public NondeterministicInput<FormCombo> {
 public:
-    FormCombo(PlatformEvent::Type eventType, FormData::Type formType);
+    FormCombo(PlatformEvent1::Type eventType1, PlatformEvent2::Type eventType2, FormData1::Type formType1, FormData2::Type formType2);
     virtual ~FormCombo();
 
-    PlatformEvent::Type eventType() const { return m_eventType; }
-    FormData::Type formType() const { return m_formType; }
+    PlatformEvent1::Type eventType1() const { return m_eventType1; }
+    PlatformEvent2::Type eventType2() const { return m_eventType2; }
+    FormData1::Type formType1() const { return m_formType1; }
+    FormData2::Type formType2() const { return m_formType2; }
 private:
-    PlatformEvent::Type m_eventType;
-    FormData::Type m_formType;
+    PlatformEvent1::Type m_eventType1;
+    PlatformEvent2::Type m_eventType2;
+    FormData1::Type m_formType1;
+    FormData2::Type m_formType2;
 };
 } // namespace Test
 
 #define TEST_REPLAY_INPUT_NAMES_FOR_EACH(macro) \
     macro(FormCombo) \
     \
 // end of TEST_REPLAY_INPUT_NAMES_FOR_EACH
 
 #endif // ENABLE(WEB_REPLAY)
 
diff --git a/Source/JavaScriptCore/replay/scripts/tests/generate-enums-with-same-base-name.json b/Source/JavaScriptCore/replay/scripts/tests/generate-enums-with-same-base-name.json
index 2ed2912..d77bdb6 100644
--- a/Source/JavaScriptCore/replay/scripts/tests/generate-enums-with-same-base-name.json
+++ b/Source/JavaScriptCore/replay/scripts/tests/generate-enums-with-same-base-name.json
@@ -1,34 +1,50 @@
 {
     "types": {
         "JavaScriptCore": [
             {
                 "name": "Type", "mode": "SCALAR", "storage": "uint64_t",
-                "enclosing_class": "PlatformEvent",
+                "enclosing_class": "PlatformEvent1",
                 "flags": ["ENUM"],
                 "values": ["Mouse", "Keyboard"],
                 "header": "replay/PlatformEvent.h"
+            },
+            {
+                "name": "Type", "mode": "SCALAR",
+                "enclosing_class": "PlatformEvent2",
+                "flags": ["ENUM_CLASS"],
+                "values": ["Mouse", "Keyboard"],
+                "header": "replay/PlatformEvent.h"
             }
         ],
         "WebCore": [
             {
                 "name": "Type", "mode": "SCALAR", "storage": "uint64_t",
-                "enclosing_class": "FormData",
+                "enclosing_class": "FormData1",
                 "flags": ["ENUM"],
                 "values": ["Text", "Blob"],
-                "header": "replay/FormData.h"
+                "header": "replay/FormData1.h"
+            },
+            {
+                "name": "Type", "mode": "SCALAR",
+                "enclosing_class": "FormData2",
+                "flags": ["ENUM_CLASS"],
+                "values": ["Text", "Blob"],
+                "header": "replay/FormData2.h"
             }
         ]
     },
 
     "inputs": [
         {
             "name": "FormCombo",
             "description": "Combines an event type and form data type.",
             "queue": "SCRIPT_MEMOIZED",
             "members": [
-                { "name": "eventType", "type": "PlatformEvent::Type" },
-                { "name": "formType", "type": "FormData::Type" }
+                { "name": "eventType1", "type": "PlatformEvent1::Type" },
+                { "name": "eventType2", "type": "PlatformEvent2::Type" },
+                { "name": "formType1", "type": "FormData1::Type" },
+                { "name": "formType2", "type": "FormData2::Type" }
             ]
         }
     ]
 }
-- 
2.0.1

