From a097696a28a7eea01fd55a7ef2260d7d44fb6c70 Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Sun, 14 Sep 2014 01:45:37 -0700
Subject: [PATCH] Web Inspector: subtract elapsed time while debugger is paused
 from profile nodes https://bugs.webkit.org/show_bug.cgi?id=136796

Reviewed by NOBODY (OOPS!).

Source/JavaScriptCore:

Rather than accruing no time to any profile node created while the debugger is paused,
we can instead count a node's elapsed time and exclude time elapsed while paused.

Time for a node may elapse in a non-contiguous fashion depending on the interleaving of
didPause, didContinue, willExecute, and didExecute. A node's start time is set to the
start of the last such interval that accrues elapsed time.

* profiler/ProfileGenerator.cpp:
(JSC::ProfileGenerator::ProfileGenerator):
(JSC::ProfileGenerator::beginCallEntry):
(JSC::ProfileGenerator::endCallEntry):
(JSC::ProfileGenerator::didPause): Added.
(JSC::ProfileGenerator::didContinue): Added.
* profiler/ProfileGenerator.h:
(JSC::ProfileGenerator::didPause): Deleted.
(JSC::ProfileGenerator::didContinue): Deleted.
* profiler/ProfileNode.h: Rename totalTime to elapsedTime.
(JSC::ProfileNode::Call::Call):
(JSC::ProfileNode::Call::elapsedTime): Added.
(JSC::ProfileNode::Call::setElapsedTime): Added.
(JSC::CalculateProfileSubtreeDataFunctor::operator()):
(JSC::ProfileNode::Call::totalTime): Deleted.
(JSC::ProfileNode::Call::setTotalTime): Deleted.

Source/WebCore:

* inspector/TimelineRecordFactory.cpp:
(WebCore::buildInspectorObject):
---
 Source/JavaScriptCore/ChangeLog                    | 31 ++++++++++++
 .../JavaScriptCore/profiler/ProfileGenerator.cpp   | 55 ++++++++++++++++++++--
 Source/JavaScriptCore/profiler/ProfileGenerator.h  |  7 +--
 Source/JavaScriptCore/profiler/ProfileNode.h       | 18 +++----
 Source/WebCore/ChangeLog                           | 10 ++++
 Source/WebCore/inspector/TimelineRecordFactory.cpp |  2 +-
 6 files changed, 106 insertions(+), 17 deletions(-)

diff --git a/Source/JavaScriptCore/ChangeLog b/Source/JavaScriptCore/ChangeLog
index 795faf2..99bc5da 100644
--- a/Source/JavaScriptCore/ChangeLog
+++ b/Source/JavaScriptCore/ChangeLog
@@ -1,10 +1,41 @@
+2014-09-14  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Inspector: subtract elapsed time while debugger is paused from profile nodes
+        https://bugs.webkit.org/show_bug.cgi?id=136796
+
+        Reviewed by NOBODY (OOPS!).
+
+        Rather than accruing no time to any profile node created while the debugger is paused,
+        we can instead count a node's elapsed time and exclude time elapsed while paused.
+
+        Time for a node may elapse in a non-contiguous fashion depending on the interleaving of
+        didPause, didContinue, willExecute, and didExecute. A node's start time is set to the
+        start of the last such interval that accrues elapsed time.
+
+        * profiler/ProfileGenerator.cpp:
+        (JSC::ProfileGenerator::ProfileGenerator):
+        (JSC::ProfileGenerator::beginCallEntry):
+        (JSC::ProfileGenerator::endCallEntry):
+        (JSC::ProfileGenerator::didPause): Added.
+        (JSC::ProfileGenerator::didContinue): Added.
+        * profiler/ProfileGenerator.h:
+        (JSC::ProfileGenerator::didPause): Deleted.
+        (JSC::ProfileGenerator::didContinue): Deleted.
+        * profiler/ProfileNode.h: Rename totalTime to elapsedTime.
+        (JSC::ProfileNode::Call::Call):
+        (JSC::ProfileNode::Call::elapsedTime): Added.
+        (JSC::ProfileNode::Call::setElapsedTime): Added.
+        (JSC::CalculateProfileSubtreeDataFunctor::operator()):
+        (JSC::ProfileNode::Call::totalTime): Deleted.
+        (JSC::ProfileNode::Call::setTotalTime): Deleted.
+
 2014-08-27  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Replay: code generator should be able to encode/decode ViewState::Flags
         https://bugs.webkit.org/show_bug.cgi?id=136297
 
         Reviewed by NOBODY (OOPS!).
 
         ViewState::(enum) is an anonymous enum inside of a struct. ViewState::Flags is a typedef
         for unsigned, and the enum values are used to bitwise-construct and query an unsigned value
         containing several flags.
diff --git a/Source/JavaScriptCore/profiler/ProfileGenerator.cpp b/Source/JavaScriptCore/profiler/ProfileGenerator.cpp
index cff66aa..7e43446 100644
--- a/Source/JavaScriptCore/profiler/ProfileGenerator.cpp
+++ b/Source/JavaScriptCore/profiler/ProfileGenerator.cpp
@@ -41,25 +41,25 @@
 namespace JSC {
 
 PassRefPtr<ProfileGenerator> ProfileGenerator::create(ExecState* exec, const String& title, unsigned uid)
 {
     return adoptRef(new ProfileGenerator(exec, title, uid));
 }
 
 ProfileGenerator::ProfileGenerator(ExecState* exec, const String& title, unsigned uid)
     : m_origin(exec ? exec->lexicalGlobalObject() : nullptr)
     , m_profileGroup(exec ? exec->lexicalGlobalObject()->profileGroup() : 0)
+    , m_debuggerPausedTimestamp(NAN)
     , m_foundConsoleStartParent(false)
-    , m_debuggerPaused(false)
 {
     if (Debugger* debugger = exec->lexicalGlobalObject()->debugger())
-        m_debuggerPaused = debugger->isPaused();
+        m_debuggerPausedTimestamp = debugger->isPaused() ? currentTime() : NAN;
 
     m_profile = Profile::create(title, uid);
     m_currentNode = m_rootNode = m_profile->rootNode();
     if (exec)
         addParentForConsoleStart(exec);
 }
 
 class AddParentForConsoleStartFunctor {
 public:
     AddParentForConsoleStartFunctor(ExecState* exec, RefPtr<ProfileNode>& rootNode, RefPtr<ProfileNode>& currentNode)
@@ -111,31 +111,51 @@ const String& ProfileGenerator::title() const
 {
     return m_profile->title();
 }
 
 void ProfileGenerator::beginCallEntry(ProfileNode* node, double startTime)
 {
     ASSERT_ARG(node, node);
 
     if (isnan(startTime))
         startTime = currentTime();
+
+    // If the debugger is paused when beginning, then don't set the start time. It
+    // will be fixed up when the debugger unpauses or the call entry ends.
+    if (!isnan(m_debuggerPausedTimestamp))
+        startTime = NAN;
+
     node->appendCall(ProfileNode::Call(startTime));
 }
 
 void ProfileGenerator::endCallEntry(ProfileNode* node)
 {
     ASSERT_ARG(node, node);
 
     ProfileNode::Call& last = node->lastCall();
-    ASSERT(isnan(last.totalTime()));
 
-    last.setTotalTime(m_debuggerPaused ? 0.0 : currentTime() - last.startTime());
+    // If the debugger is paused, ignore the interval that ends now.
+    if (!isnan(m_debuggerPausedTimestamp) && !isnan(last.elapsedTime()))
+        return;
+
+    // If paused and no time was accrued then the debugger was never unpaused. The call will
+    // have no time accrued and appear to have started when the debugger was paused.
+    if (!isnan(m_debuggerPausedTimestamp)) {
+        last.setStartTime(m_debuggerPausedTimestamp);
+        last.setElapsedTime(0.0);
+        return;
+    }
+
+    // Otherwise, add the interval ending now to elapsed time.
+    double previousElapsedTime = isnan(last.elapsedTime()) ? 0.0 : last.elapsedTime();
+    double newlyElapsedTime = currentTime() - last.startTime();
+    last.setElapsedTime(previousElapsedTime + newlyElapsedTime);
 }
 
 void ProfileGenerator::willExecute(ExecState* callerCallFrame, const CallIdentifier& callIdentifier)
 {
     if (JAVASCRIPTCORE_PROFILE_WILL_EXECUTE_ENABLED()) {
         CString name = callIdentifier.functionName().utf8();
         CString url = callIdentifier.url().utf8();
         JAVASCRIPTCORE_PROFILE_WILL_EXECUTE(m_profileGroup, const_cast<char*>(name.data()), const_cast<char*>(url.data()), callIdentifier.lineNumber(), callIdentifier.columnNumber());
     }
 
@@ -189,20 +209,47 @@ void ProfileGenerator::exceptionUnwind(ExecState* handlerCallFrame, const CallId
 {
     // If the current node was called by the handler (==) or any
     // more nested function (>) the we have exited early from it.
     ASSERT(m_currentNode);
     while (m_currentNode->callerCallFrame() >= handlerCallFrame) {
         didExecute(m_currentNode->callerCallFrame(), m_currentNode->callIdentifier());
         ASSERT(m_currentNode);
     }
 }
 
+void ProfileGenerator::didPause(PassRefPtr<DebuggerCallFrame>, const CallIdentifier&)
+{
+    ASSERT(isnan(m_debuggerPausedTimestamp));
+
+    m_debuggerPausedTimestamp = currentTime();
+
+    for (ProfileNode* node = m_currentNode.get(); node != m_profile->rootNode(); node = node->parent()) {
+        ProfileNode::Call& last = node->lastCall();
+        ASSERT(!isnan(last.startTime()));
+
+        double previousElapsedTime = isnan(last.elapsedTime()) ? 0.0 : last.elapsedTime();
+        double additionalElapsedTime = m_debuggerPausedTimestamp - last.startTime();
+        last.setStartTime(NAN);
+        last.setElapsedTime(previousElapsedTime + additionalElapsedTime);
+    }
+}
+
+void ProfileGenerator::didContinue(PassRefPtr<DebuggerCallFrame>, const CallIdentifier&)
+{
+    ASSERT(!isnan(m_debuggerPausedTimestamp));
+
+    for (ProfileNode* node = m_currentNode.get(); node != m_profile->rootNode(); node = node->parent())
+        node->lastCall().setStartTime(m_debuggerPausedTimestamp);
+
+    m_debuggerPausedTimestamp = NAN;
+}
+
 void ProfileGenerator::stopProfiling()
 {
     for (ProfileNode* node = m_currentNode.get(); node != m_profile->rootNode(); node = node->parent())
         endCallEntry(node);
 
     if (m_foundConsoleStartParent) {
         removeProfileStart();
         removeProfileEnd();
     }
 
diff --git a/Source/JavaScriptCore/profiler/ProfileGenerator.h b/Source/JavaScriptCore/profiler/ProfileGenerator.h
index 3b6b95a..7c970d6 100644
--- a/Source/JavaScriptCore/profiler/ProfileGenerator.h
+++ b/Source/JavaScriptCore/profiler/ProfileGenerator.h
@@ -47,39 +47,40 @@ namespace JSC {
         // Members
         const WTF::String& title() const;
         PassRefPtr<Profile> profile() const { return m_profile; }
         JSGlobalObject* origin() const { return m_origin; }
         unsigned profileGroup() const { return m_profileGroup; }
 
         void willExecute(ExecState* callerCallFrame, const CallIdentifier&);
         void didExecute(ExecState* callerCallFrame, const CallIdentifier&);
         void exceptionUnwind(ExecState* handlerCallFrame, const CallIdentifier&);
 
-        void didPause(PassRefPtr<DebuggerCallFrame>, const CallIdentifier&) { m_debuggerPaused = true; }
-        void didContinue(PassRefPtr<DebuggerCallFrame>, const CallIdentifier&) { m_debuggerPaused = false; }
+        void didPause(PassRefPtr<DebuggerCallFrame>, const CallIdentifier&);
+        void didContinue(PassRefPtr<DebuggerCallFrame>, const CallIdentifier&);
 
         void stopProfiling();
 
         typedef void (ProfileGenerator::*ProfileFunction)(ExecState* callerOrHandlerCallFrame, const CallIdentifier& callIdentifier);
 
     private:
         ProfileGenerator(ExecState*, const WTF::String& title, unsigned uid);
         void addParentForConsoleStart(ExecState*);
 
         void removeProfileStart();
         void removeProfileEnd();
 
         void beginCallEntry(ProfileNode*, double startTime = NAN);
         void endCallEntry(ProfileNode*);
 
         RefPtr<Profile> m_profile;
         JSGlobalObject* m_origin;
         unsigned m_profileGroup;
+        // Timestamp is set to NAN when the debugger is not currently paused.
+        double m_debuggerPausedTimestamp;
         RefPtr<ProfileNode> m_rootNode;
         RefPtr<ProfileNode> m_currentNode;
         bool m_foundConsoleStartParent;
-        bool m_debuggerPaused;
     };
 
 } // namespace JSC
 
 #endif // ProfileGenerator_h
diff --git a/Source/JavaScriptCore/profiler/ProfileNode.h b/Source/JavaScriptCore/profiler/ProfileNode.h
index 6676e91..dea9137 100644
--- a/Source/JavaScriptCore/profiler/ProfileNode.h
+++ b/Source/JavaScriptCore/profiler/ProfileNode.h
@@ -49,43 +49,43 @@ namespace JSC {
             return adoptRef(new ProfileNode(callerCallFrame, callIdentifier, parentNode));
         }
 
         static PassRefPtr<ProfileNode> create(ExecState* callerCallFrame, ProfileNode* node)
         {
             return adoptRef(new ProfileNode(callerCallFrame, node));
         }
 
         struct Call {
         public:
-            Call(double startTime, double totalTime = NAN)
+            Call(double startTime, double elapsedTime = NAN)
                 : m_startTime(startTime)
-                , m_totalTime(totalTime)
+                , m_elapsedTime(elapsedTime)
             {
             }
 
             double startTime() const { return m_startTime; }
             void setStartTime(double time)
             {
-                ASSERT_ARG(time, time >= 0.0);
+                ASSERT_ARG(time, time >= 0.0 || isnan(time));
                 m_startTime = time;
             }
 
-            double totalTime() const { return m_totalTime; }
-            void setTotalTime(double time)
+            double elapsedTime() const { return m_elapsedTime; }
+            void setElapsedTime(double time)
             {
-                ASSERT_ARG(time, time >= 0.0);
-                m_totalTime = time;
+                ASSERT_ARG(time, time >= 0.0 || isnan(time));
+                m_elapsedTime = time;
             }
 
         private:
             double m_startTime;
-            double m_totalTime;
+            double m_elapsedTime;
         };
 
         bool operator==(ProfileNode* node) { return m_callIdentifier == node->callIdentifier(); }
 
         ExecState* callerCallFrame() const { return m_callerCallFrame; }
         const CallIdentifier& callIdentifier() const { return m_callIdentifier; }
         unsigned id() const { return m_callIdentifier.hash(); }
         const String& functionName() const { return m_callIdentifier.functionName(); }
         const String& url() const { return m_callIdentifier.url(); }
         unsigned lineNumber() const { return m_callIdentifier.lineNumber(); }
@@ -163,21 +163,21 @@ namespace JSC {
         }
 
         functor(endNode);
     }
 
     struct CalculateProfileSubtreeDataFunctor {
         void operator()(ProfileNode* node)
         {
             double selfTime = 0.0;
             for (const ProfileNode::Call& call : node->calls())
-                selfTime += call.totalTime();
+                selfTime += call.elapsedTime();
 
             double totalTime = selfTime;
             for (RefPtr<ProfileNode> child : node->children()) {
                 auto it = m_data.selfAndTotalTimes.find(child.get());
                 if (it != m_data.selfAndTotalTimes.end())
                     totalTime += it->value.second;
             }
 
             ASSERT(node);
             m_data.selfAndTotalTimes.set(node, std::make_pair(selfTime, totalTime));
diff --git a/Source/WebCore/ChangeLog b/Source/WebCore/ChangeLog
index 9717bf9..15b7cfa 100644
--- a/Source/WebCore/ChangeLog
+++ b/Source/WebCore/ChangeLog
@@ -1,10 +1,20 @@
+2014-09-14  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Inspector: subtract elapsed time while debugger is paused from profile nodes
+        https://bugs.webkit.org/show_bug.cgi?id=136796
+
+        Reviewed by NOBODY (OOPS!).
+
+        * inspector/TimelineRecordFactory.cpp:
+        (WebCore::buildInspectorObject):
+
 2014-08-11  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Inspector: add eject current recording button to the replay dashboard
         https://bugs.webkit.org/show_bug.cgi?id=135225
 
         Reviewed by NOBODY (OOPS!).
 
         Add a protocol method that creates an empty replay session. To eject, the
         frontend creates an empty session and then switches to it.
 
diff --git a/Source/WebCore/inspector/TimelineRecordFactory.cpp b/Source/WebCore/inspector/TimelineRecordFactory.cpp
index d459dfc..1d18332 100644
--- a/Source/WebCore/inspector/TimelineRecordFactory.cpp
+++ b/Source/WebCore/inspector/TimelineRecordFactory.cpp
@@ -267,21 +267,21 @@ PassRefPtr<InspectorObject> TimelineRecordFactory::createPaintData(const FloatQu
 
 void TimelineRecordFactory::appendLayoutRoot(InspectorObject* data, const FloatQuad& quad)
 {
     data->setArray("root", createQuad(quad));
 }
 
 static PassRefPtr<Protocol::Timeline::CPUProfileNodeCall> buildInspectorObject(const JSC::ProfileNode::Call& call)
 {
     RefPtr<Protocol::Timeline::CPUProfileNodeCall> result = Protocol::Timeline::CPUProfileNodeCall::create()
         .setStartTime(call.startTime())
-        .setTotalTime(call.totalTime());
+        .setTotalTime(call.elapsedTime());
     return result.release();
 }
 
 static PassRefPtr<Protocol::Timeline::CPUProfileNode> buildInspectorObject(const JSC::ProfileNode* node)
 {
     RefPtr<Protocol::Array<Protocol::Timeline::CPUProfileNodeCall>> calls = Protocol::Array<Protocol::Timeline::CPUProfileNodeCall>::create();
     for (const JSC::ProfileNode::Call& call : node->calls())
         calls->addItem(buildInspectorObject(call));
 
     RefPtr<Protocol::Timeline::CPUProfileNode> result = Protocol::Timeline::CPUProfileNode::create()
-- 
2.0.1

