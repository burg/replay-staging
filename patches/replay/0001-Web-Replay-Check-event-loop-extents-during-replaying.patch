From a95b7d793d9db0bb8c3ae6a71c60f22ceda283e7 Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Tue, 19 Aug 2014 12:12:33 -0700
Subject: [PATCH] Web Replay: Check event loop extents during replaying Need a
 Bug URL (OOPS!)

Reviewed by NOBODY (OOPS!).

Sometimes we see different nondeterminism during capture and replay
executions, so we should support determinism checks during replay too.

Move the withinEventLoopInputExtent flag to the base class.

Source/JavaScriptCore:

* replay/InputCursor.h:
(JSC::InputCursor::InputCursor):
(JSC::InputCursor::setWithinEventLoopInputExtent): Added.
(JSC::InputCursor::withinEventLoopInputExtent): Added.

Source/WebCore:

* replay/CapturingInputCursor.cpp:
(WebCore::CapturingInputCursor::CapturingInputCursor):
(WebCore::CapturingInputCursor::setWithinEventLoopInputExtent): Deleted.
* replay/CapturingInputCursor.h:
* replay/EventLoopInput.cpp:
(WebCore::EventLoopInputExtent::EventLoopInputExtent):
(WebCore::EventLoopInputExtent::~EventLoopInputExtent):
* replay/EventLoopInput.h:
* replay/ReplayController.cpp:
(WebCore::ReplayController::willDispatchEvent): Expand the assetion to include replaying.
---
 Source/JavaScriptCore/ChangeLog                | 17 +++++++++++++++++
 Source/JavaScriptCore/replay/InputCursor.h     | 18 +++++++++++++++++-
 Source/WebCore/ChangeLog                       | 23 +++++++++++++++++++++++
 Source/WebCore/replay/CapturingInputCursor.cpp |  8 --------
 Source/WebCore/replay/CapturingInputCursor.h   |  4 ----
 Source/WebCore/replay/EventLoopInput.cpp       | 19 +++++++++----------
 Source/WebCore/replay/EventLoopInput.h         |  3 ++-
 Source/WebCore/replay/ReplayController.cpp     |  4 ++--
 8 files changed, 70 insertions(+), 26 deletions(-)

diff --git a/Source/JavaScriptCore/ChangeLog b/Source/JavaScriptCore/ChangeLog
index 38084a3..57a3489 100644
--- a/Source/JavaScriptCore/ChangeLog
+++ b/Source/JavaScriptCore/ChangeLog
@@ -1,10 +1,27 @@
+2014-08-19  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Replay: Check event loop extents during replaying
+        Need a Bug URL (OOPS!)
+
+        Reviewed by NOBODY (OOPS!).
+
+        Sometimes we see different nondeterminism during capture and replay
+        executions, so we should support determinism checks during replay too.
+
+        Move the withinEventLoopInputExtent flag to the base class.
+
+        * replay/InputCursor.h:
+        (JSC::InputCursor::InputCursor):
+        (JSC::InputCursor::setWithinEventLoopInputExtent): Added.
+        (JSC::InputCursor::withinEventLoopInputExtent): Added.
+
 2014-09-11  Joseph Pecoraro  <pecoraro@apple.com>
 
         Web Inspector: Occasional ASSERT closing web inspector
         https://bugs.webkit.org/show_bug.cgi?id=136762
 
         Reviewed by Timothy Hatcher.
 
         It is harmless, and indeed possible to have an empty set of listeners
         now that each Page gets its own PageDebugServer instead of a shared
         global. So we should replace the null checks with isEmpty checks.
diff --git a/Source/JavaScriptCore/replay/InputCursor.h b/Source/JavaScriptCore/replay/InputCursor.h
index 6102a7f..2f40040 100644
--- a/Source/JavaScriptCore/replay/InputCursor.h
+++ b/Source/JavaScriptCore/replay/InputCursor.h
@@ -33,43 +33,59 @@
 #include "NondeterministicInput.h"
 #include <wtf/Noncopyable.h>
 #include <wtf/RefCounted.h>
 #include <wtf/text/AtomicString.h>
 
 namespace JSC {
 
 class InputCursor : public RefCounted<InputCursor> {
     WTF_MAKE_NONCOPYABLE(InputCursor);
 public:
-    InputCursor() { }
+    InputCursor()
+        : m_withinEventLoopInputExtent(false)
+    {
+    }
 
     virtual ~InputCursor() { }
 
     virtual bool isCapturing() const = 0;
     virtual bool isReplaying() const = 0;
 
+    void setWithinEventLoopInputExtent(bool withinEventLoopInputExtent)
+    {
+        // We cannot enter more than one extent at a time, since they represent
+        // a single run loop's work on behalf of the Page.
+        ASSERT(withinEventLoopInputExtent != m_withinEventLoopInputExtent);
+        m_withinEventLoopInputExtent = withinEventLoopInputExtent;
+    }
+
+    bool withinEventLoopInputExtent() const { return m_withinEventLoopInputExtent; }
+
     template <class InputType, class... Args> inline
     void appendInput(Args&&... args)
     {
         InputType* rawInput = WTF::safeCast<InputType*>(new InputType(std::forward<Args>(args)...));
         return storeInput(std::unique_ptr<NondeterministicInputBase>(rawInput));
     }
 
     template <class InputType> inline
     InputType* fetchInput()
     {
         return static_cast<InputType*>(loadInput(InputTraits<InputType>::queue(), InputTraits<InputType>::type()));
     }
 
     virtual void storeInput(std::unique_ptr<NondeterministicInputBase>) = 0;
     virtual NondeterministicInputBase* uncheckedLoadInput(InputQueue) = 0;
 protected:
     virtual NondeterministicInputBase* loadInput(InputQueue, const AtomicString&) = 0;
+
+private:
+    bool m_withinEventLoopInputExtent;
 };
 
 } // namespace JSC
 
 using JSC::InputCursor;
 
 #endif // ENABLE(WEB_REPLAY)
 
 #endif // InputCursor_h
diff --git a/Source/WebCore/ChangeLog b/Source/WebCore/ChangeLog
index cc257d1..422f220 100644
--- a/Source/WebCore/ChangeLog
+++ b/Source/WebCore/ChangeLog
@@ -1,10 +1,33 @@
+2014-08-19  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Replay: Check event loop extents during replaying
+        Need a Bug URL (OOPS!)
+
+        Reviewed by NOBODY (OOPS!).
+
+        Sometimes we see different nondeterminism during capture and replay
+        executions, so we should support determinism checks during replay too.
+
+        Move the withinEventLoopInputExtent flag to the base class.
+
+        * replay/CapturingInputCursor.cpp:
+        (WebCore::CapturingInputCursor::CapturingInputCursor):
+        (WebCore::CapturingInputCursor::setWithinEventLoopInputExtent): Deleted.
+        * replay/CapturingInputCursor.h:
+        * replay/EventLoopInput.cpp:
+        (WebCore::EventLoopInputExtent::EventLoopInputExtent):
+        (WebCore::EventLoopInputExtent::~EventLoopInputExtent):
+        * replay/EventLoopInput.h:
+        * replay/ReplayController.cpp:
+        (WebCore::ReplayController::willDispatchEvent): Expand the assetion to include replaying.
+
 2014-09-11  Joseph Pecoraro  <pecoraro@apple.com>
 
         Web Inspector: Occasional ASSERT closing web inspector
         https://bugs.webkit.org/show_bug.cgi?id=136762
 
         Reviewed by Timothy Hatcher.
 
         * bindings/js/WorkerScriptDebugServer.h:
         * inspector/PageScriptDebugServer.h:
 
diff --git a/Source/WebCore/replay/CapturingInputCursor.cpp b/Source/WebCore/replay/CapturingInputCursor.cpp
index 40db3b6..73b402f 100644
--- a/Source/WebCore/replay/CapturingInputCursor.cpp
+++ b/Source/WebCore/replay/CapturingInputCursor.cpp
@@ -33,21 +33,20 @@
 #include "EventLoopInput.h"
 #include "Logging.h"
 #include "ReplaySessionSegment.h"
 #include "SegmentedInputStorage.h"
 #include <wtf/CurrentTime.h>
 
 namespace WebCore {
 
 CapturingInputCursor::CapturingInputCursor(PassRefPtr<ReplaySessionSegment> segment)
     : m_segment(segment)
-    , m_withinEventLoopInputExtent(false)
 {
     LOG(WebReplay, "%-30sCreated capture cursor=%p.\n", "[ReplayController]", this);
 }
 
 CapturingInputCursor::~CapturingInputCursor()
 {
     LOG(WebReplay, "%-30sDestroyed capture cursor=%p.\n", "[ReplayController]", this);
 }
 
 PassRefPtr<CapturingInputCursor> CapturingInputCursor::create(PassRefPtr<ReplaySessionSegment> segment)
@@ -75,20 +74,13 @@ NondeterministicInputBase* CapturingInputCursor::loadInput(InputQueue, const Ato
     return nullptr;
 }
 
 NondeterministicInputBase* CapturingInputCursor::uncheckedLoadInput(InputQueue)
 {
     // Can't load inputs from capturing cursor.
     ASSERT_NOT_REACHED();
     return nullptr;
 }
 
-void CapturingInputCursor::setWithinEventLoopInputExtent(bool withinEventLoopInputExtent)
-{
-    // We cannot enter more than one extent at a time, since they represent a single run loop.
-    ASSERT(withinEventLoopInputExtent != m_withinEventLoopInputExtent);
-    m_withinEventLoopInputExtent = withinEventLoopInputExtent;
-}
-
 }; // namespace WebCore
 
 #endif // ENABLE(WEB_REPLAY)
diff --git a/Source/WebCore/replay/CapturingInputCursor.h b/Source/WebCore/replay/CapturingInputCursor.h
index 59e6d4c..ec25c84 100644
--- a/Source/WebCore/replay/CapturingInputCursor.h
+++ b/Source/WebCore/replay/CapturingInputCursor.h
@@ -41,31 +41,27 @@ class ReplaySessionSegment;
 
 class CapturingInputCursor final : public InputCursor {
     WTF_MAKE_NONCOPYABLE(CapturingInputCursor);
 public:
     static PassRefPtr<CapturingInputCursor> create(PassRefPtr<ReplaySessionSegment>);
     virtual ~CapturingInputCursor();
 
     virtual bool isCapturing() const override { return true; }
     virtual bool isReplaying() const override { return false; }
 
-    void setWithinEventLoopInputExtent(bool);
-    bool withinEventLoopInputExtent() const { return m_withinEventLoopInputExtent; }
-
 protected:
     virtual NondeterministicInputBase* loadInput(InputQueue, const AtomicString& type) override;
 
 private:
     CapturingInputCursor(PassRefPtr<ReplaySessionSegment>);
 
     virtual NondeterministicInputBase* uncheckedLoadInput(InputQueue) override;
     virtual void storeInput(std::unique_ptr<NondeterministicInputBase>) override;
 
     RefPtr<ReplaySessionSegment> m_segment;
-    bool m_withinEventLoopInputExtent;
 };
 
 } // namespace WebCore
 
 #endif // ENABLE(WEB_REPLAY)
 
 #endif // CapturingInputCursor_h
diff --git a/Source/WebCore/replay/EventLoopInput.cpp b/Source/WebCore/replay/EventLoopInput.cpp
index bb27026..2599a0a 100644
--- a/Source/WebCore/replay/EventLoopInput.cpp
+++ b/Source/WebCore/replay/EventLoopInput.cpp
@@ -21,34 +21,33 @@
  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "EventLoopInput.h"
 
 #if ENABLE(WEB_REPLAY)
 
-#include "CapturingInputCursor.h"
+#include <replay/InputCursor.h>
 
 namespace WebCore {
 
-EventLoopInputExtent::EventLoopInputExtent(InputCursor& cursor)
+EventLoopInputExtent::EventLoopInputExtent(JSC::InputCursor& cursor)
+    : EventLoopInputExtent(&cursor) { }
+
+EventLoopInputExtent::EventLoopInputExtent(JSC::InputCursor* cursor)
     : m_cursor(cursor)
 {
-    if (!m_cursor.isCapturing())
-        return;
-
-    static_cast<CapturingInputCursor&>(cursor).setWithinEventLoopInputExtent(true);
+    if (m_cursor)
+        m_cursor->setWithinEventLoopInputExtent(true);
 }
 
 EventLoopInputExtent::~EventLoopInputExtent()
 {
-    if (!m_cursor.isCapturing())
-        return;
-
-    static_cast<CapturingInputCursor&>(m_cursor).setWithinEventLoopInputExtent(false);
+    if (m_cursor)
+        m_cursor->setWithinEventLoopInputExtent(false);
 }
 
 }; // namespace WebCore
 
 #endif // ENABLE(WEB_REPLAY)
diff --git a/Source/WebCore/replay/EventLoopInput.h b/Source/WebCore/replay/EventLoopInput.h
index 250a3db..1081ac0 100644
--- a/Source/WebCore/replay/EventLoopInput.h
+++ b/Source/WebCore/replay/EventLoopInput.h
@@ -41,23 +41,24 @@ namespace WebCore {
 
 class ReplayController;
 
 // This is an RAII helper used during capturing which sets a flag on the input cursor
 // to track the dynamic extent of a captured event loop input. This extent approximates
 // the interval in which EventLoopInputDispatcher::dispatching() is true.
 class EventLoopInputExtent {
     WTF_MAKE_NONCOPYABLE(EventLoopInputExtent);
 public:
     EventLoopInputExtent(JSC::InputCursor&);
+    EventLoopInputExtent(JSC::InputCursor*);
     ~EventLoopInputExtent();
 private:
-    JSC::InputCursor& m_cursor;
+    JSC::InputCursor* m_cursor;
 };
 
 class EventLoopInputBase : public NondeterministicInputBase {
 public:
     virtual ~EventLoopInputBase() { }
     virtual InputQueue queue() const override final { return InputQueue::EventLoopInput; }
 
     virtual void dispatch(ReplayController&) = 0;
 };
 
diff --git a/Source/WebCore/replay/ReplayController.cpp b/Source/WebCore/replay/ReplayController.cpp
index 119f490..8edceb2 100644
--- a/Source/WebCore/replay/ReplayController.cpp
+++ b/Source/WebCore/replay/ReplayController.cpp
@@ -465,22 +465,22 @@ void ReplayController::willDispatchEvent(const Event& event, Frame* frame)
     bool eventIsUnrelated = !cursor.isCapturing() && !cursor.isReplaying();
     logDispatchedDOMEvent(event, eventIsUnrelated);
 #else
     UNUSED_PARAM(cursor);
 #endif
 
 #if ENABLE_AGGRESSIVE_DETERMINISM_CHECKS
     // To ensure deterministic JS execution, all DOM events must be dispatched deterministically.
     // If these assertions fail, then this DOM event is being dispatched by a nondeterministic EventLoop
     // cycle, and may cause program execution to diverge if any JS code runs because of the DOM event.
-    if (cursor.isCapturing())
-        ASSERT(static_cast<CapturingInputCursor&>(cursor).withinEventLoopInputExtent());
+    if (cursor.isCapturing() || cursor.isReplaying())
+        ASSERT(cursor.withinEventLoopInputExtent());
     else if (cursor.isReplaying())
         ASSERT(dispatcher().isDispatching());
 #endif
 }
 
 PassRefPtr<ReplaySession> ReplayController::loadedSession() const
 {
     return m_loadedSession;
 }
 
-- 
2.0.1

