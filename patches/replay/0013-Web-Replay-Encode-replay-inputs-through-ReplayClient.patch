From c1ea7f9d76e164241e4b2ee3a11762f4493e1cb0 Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Fri, 9 Jan 2015 21:35:21 -0800
Subject: [PATCH] Web Replay: Encode replay inputs through ReplayClient
 https://bugs.webkit.org/show_bug.cgi?id=140448

Reviewed by NOBODY (OOPS!).

Source/JavaScriptCore:

* replay/InputCursor.h:
(JSC::InputCursor::InputCursor): Fix signature of type().

Source/WebCore:

Only WebKit2 can access all possible replay inputs, so it should contain
the big function with cases to encode each input based on its type tag.

Move some logging code out of SegmentedInputStorage so that inputs can be encoded
through ReplayClient and then displayed in the serialized JSON representation.

No new tests, no behavior was changed.

* WebCore.exp.in: Add symbols for EncodingTraits specializations of WebCore inputs.
* WebCore.xcodeproj/project.pbxproj:
* inspector/InspectorReplayAgent.cpp:
(WebCore::SerializeInputToJSONFunctor::SerializeInputToJSONFunctor):
(WebCore::SerializeInputToJSONFunctor::operator()):
(WebCore::buildInspectorObjectForSegment):
(WebCore::buildInspectorObjectForInput): Deleted, it isn't used.
(WebCore::InspectorReplayAgent::getSegmentData):
(WebCore::buildInspectorObjectForInput): Deleted.
* loader/EmptyClients.h:
* replay/AllReplayInputs.h: Removed. It doesn't really do anything.
* replay/CapturingInputCursor.cpp:
(queueTypeToLogPrefix):
(WebCore::CapturingInputCursor::CapturingInputCursor):
(WebCore::CapturingInputCursor::create):
(WebCore::CapturingInputCursor::storeInput):
(WebCore::CapturingInputCursor::loadInput):
* replay/CapturingInputCursor.h:
* replay/EventLoopInputDispatcher.cpp:
(WebCore::EventLoopInputDispatcher::dispatchInput):
* replay/ReplayClient.h: Add encodeInput virtual method.
* replay/ReplayController.cpp:
(WebCore::ReplayController::createSegment):
* replay/ReplayingInputCursor.cpp:
(WebCore::queueTypeToLogPrefix):
(WebCore::ReplayingInputCursor::ReplayingInputCursor):
(WebCore::ReplayingInputCursor::create):
(WebCore::ReplayingInputCursor::loadInput):
(WebCore::ReplayingInputCursor::uncheckedLoadInput):
* replay/ReplayingInputCursor.h:
* replay/SegmentedInputStorage.cpp:
(WebCore::SegmentedInputStorage::load):
(WebCore::SegmentedInputStorage::store):
(WebCore::queueTypeToLogPrefix): Deleted.
(WebCore::jsonStringForInput): Deleted.
* replay/SegmentedInputStorage.h:
* replay/WebReplayInputCoders.cpp:
* replay/WebReplayInputDispatchMethods.cpp:

Source/WebKit2:

Only WebKit2 can access all frameworks' replay inputs, so it should contain
the big function with cases to encode each input based on its type tag.

Move some logging code out of SegmentedInputStorage so that inputs can be encoded
through ReplayClient and then displayed in the serialized JSON representation.

No new tests, no behavior was changed.

* CMakeLists.txt:
* WebKit2.xcodeproj/project.pbxproj:
* WebProcess/Replay/WKReplayInputCoders.cpp: Added.
(JSC::EncodingTraits<NondeterministicInputBase>::encodeValue): Added.
* WebProcess/Replay/WKReplayInputCoders.h: Added.
* WebProcess/WebCoreSupport/WebReplayClient.cpp:
(WebKit::WebReplayClient::encodeInput):
(WebKit::WebReplayClient::decodeInput):
* WebProcess/WebCoreSupport/WebReplayClient.h:
---
 Source/JavaScriptCore/ChangeLog                    |  10 ++
 Source/WebCore/ChangeLog                           |  54 +++++++++
 Source/WebCore/WebCore.exp.in                      |  82 ++++++++++++-
 Source/WebCore/WebCore.xcodeproj/project.pbxproj   |  10 +-
 Source/WebCore/inspector/InspectorReplayAgent.cpp  |  50 ++++----
 Source/WebCore/loader/EmptyClients.h               |   2 +
 Source/WebCore/replay/AllReplayInputs.h            |  48 --------
 Source/WebCore/replay/CapturingInputCursor.cpp     |  41 ++++++-
 Source/WebCore/replay/CapturingInputCursor.h       |   6 +-
 Source/WebCore/replay/EventLoopInputDispatcher.cpp |  10 +-
 Source/WebCore/replay/ReplayClient.h               |   8 ++
 Source/WebCore/replay/ReplayController.cpp         |   3 +-
 Source/WebCore/replay/ReplayingInputCursor.cpp     |  28 ++++-
 Source/WebCore/replay/ReplayingInputCursor.h       |   1 +
 Source/WebCore/replay/SegmentedInputStorage.cpp    |  43 +------
 Source/WebCore/replay/SegmentedInputStorage.h      |   2 +-
 Source/WebCore/replay/WebReplayInputCoders.cpp     |  59 +---------
 Source/WebCore/replay/WebReplayInputCoders.h       |   7 --
 .../replay/WebReplayInputDispatchMethods.cpp       |   2 +-
 Source/WebKit2/CMakeLists.txt                      |   1 +
 Source/WebKit2/ChangeLog                           |  25 ++++
 Source/WebKit2/WebKit2.xcodeproj/project.pbxproj   |   8 ++
 Source/WebKit2/WebProcess/Replay/WKInputs.json     |   4 +-
 .../WebProcess/Replay/WKReplayInputCoders.cpp      | 131 +++++++++++++++++++++
 .../WebProcess/Replay/WKReplayInputCoders.h        |  49 ++++++++
 .../WebProcess/WebCoreSupport/WebReplayClient.cpp  |  12 ++
 .../WebProcess/WebCoreSupport/WebReplayClient.h    |   3 +
 27 files changed, 498 insertions(+), 201 deletions(-)
 delete mode 100644 Source/WebCore/replay/AllReplayInputs.h
 create mode 100644 Source/WebKit2/WebProcess/Replay/WKReplayInputCoders.cpp
 create mode 100644 Source/WebKit2/WebProcess/Replay/WKReplayInputCoders.h

diff --git a/Source/JavaScriptCore/ChangeLog b/Source/JavaScriptCore/ChangeLog
index 94f54b3..9557b65 100644
--- a/Source/JavaScriptCore/ChangeLog
+++ b/Source/JavaScriptCore/ChangeLog
@@ -1,10 +1,20 @@
+2015-01-09  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Replay: Encode replay inputs through ReplayClient
+        https://bugs.webkit.org/show_bug.cgi?id=140448
+
+        Reviewed by NOBODY (OOPS!).
+
+        * replay/InputCursor.h:
+        (JSC::InputCursor::InputCursor): Fix signature of type().
+
 2014-08-20  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Replay: Use framework prefixes for framework-specific replay input code
         https://bugs.webkit.org/show_bug.cgi?id=140447
 
         Reviewed by NOBODY (OOPS!).
 
         Rename SerializationMethods to ReplayInputCoders to match WebKit2 naming schemes.
 
         * replay/scripts/CodeGeneratorReplayInputs.py:
diff --git a/Source/WebCore/ChangeLog b/Source/WebCore/ChangeLog
index 58783a0..ea33152 100644
--- a/Source/WebCore/ChangeLog
+++ b/Source/WebCore/ChangeLog
@@ -1,12 +1,66 @@
 2014-08-20  Brian J. Burg  <burg@cs.washington.edu>
 
+        Web Replay: Encode replay inputs through ReplayClient
+        https://bugs.webkit.org/show_bug.cgi?id=140448
+
+        Reviewed by NOBODY (OOPS!).
+
+        Only WebKit2 can access all possible replay inputs, so it should contain
+        the big function with cases to encode each input based on its type tag.
+
+        Move some logging code out of SegmentedInputStorage so that inputs can be encoded
+        through ReplayClient and then displayed in the serialized JSON representation.
+
+        No new tests, no behavior was changed.
+
+        * WebCore.exp.in: Add symbols for EncodingTraits specializations of WebCore inputs.
+        * WebCore.xcodeproj/project.pbxproj:
+        * inspector/InspectorReplayAgent.cpp:
+        (WebCore::SerializeInputToJSONFunctor::SerializeInputToJSONFunctor):
+        (WebCore::SerializeInputToJSONFunctor::operator()):
+        (WebCore::buildInspectorObjectForSegment):
+        (WebCore::buildInspectorObjectForInput): Deleted, it isn't used.
+        (WebCore::InspectorReplayAgent::getSegmentData):
+        (WebCore::buildInspectorObjectForInput): Deleted.
+        * loader/EmptyClients.h:
+        * replay/AllReplayInputs.h: Removed. It doesn't really do anything.
+        * replay/CapturingInputCursor.cpp:
+        (queueTypeToLogPrefix):
+        (WebCore::CapturingInputCursor::CapturingInputCursor):
+        (WebCore::CapturingInputCursor::create):
+        (WebCore::CapturingInputCursor::storeInput):
+        (WebCore::CapturingInputCursor::loadInput):
+        * replay/CapturingInputCursor.h:
+        * replay/EventLoopInputDispatcher.cpp:
+        (WebCore::EventLoopInputDispatcher::dispatchInput):
+        * replay/ReplayClient.h: Add encodeInput virtual method.
+        * replay/ReplayController.cpp:
+        (WebCore::ReplayController::createSegment):
+        * replay/ReplayingInputCursor.cpp:
+        (WebCore::queueTypeToLogPrefix):
+        (WebCore::ReplayingInputCursor::ReplayingInputCursor):
+        (WebCore::ReplayingInputCursor::create):
+        (WebCore::ReplayingInputCursor::loadInput):
+        (WebCore::ReplayingInputCursor::uncheckedLoadInput):
+        * replay/ReplayingInputCursor.h:
+        * replay/SegmentedInputStorage.cpp:
+        (WebCore::SegmentedInputStorage::load):
+        (WebCore::SegmentedInputStorage::store):
+        (WebCore::queueTypeToLogPrefix): Deleted.
+        (WebCore::jsonStringForInput): Deleted.
+        * replay/SegmentedInputStorage.h:
+        * replay/WebReplayInputCoders.cpp:
+        * replay/WebReplayInputDispatchMethods.cpp:
+
+2014-08-20  Brian J. Burg  <burg@cs.washington.edu>
+
         Web Replay: Use framework prefixes for framework-specific replay input code
         https://bugs.webkit.org/show_bug.cgi?id=140447
 
         Reviewed by NOBODY (OOPS!).
 
         In preparation for moving some inputs to WebKit2, add the 'Web' prefix to some
         files that are specific to WebCore inputs. This includes encode/decode methods,
         factory methods, and input dispatch implementations.
 
         Also rename SerializationMethods to ReplayInputCoders to match WebKit2 naming schemes.
diff --git a/Source/WebCore/WebCore.exp.in b/Source/WebCore/WebCore.exp.in
index 186427a..d5af5b9 100644
--- a/Source/WebCore/WebCore.exp.in
+++ b/Source/WebCore/WebCore.exp.in
@@ -1797,20 +1797,21 @@ __ZNK7WebCore14DocumentMarker11descriptionEv
 __ZNK7WebCore14FrameSelection11currentFormEv
 __ZNK7WebCore14FrameSelection15copyTypingStyleEv
 __ZNK7WebCore14FrameSelection15selectionBoundsEb
 __ZNK7WebCore14FrameSelection18isFocusedAndActiveEv
 __ZNK7WebCore14FrameSelection31getClippedVisibleTextRectanglesERN3WTF6VectorINS_9FloatRectELm0ENS1_15CrashOnOverflowEEE
 __ZNK7WebCore14FrameSelection36rootEditableElementOrDocumentElementEv
 __ZNK7WebCore14InsertionPoint8isActiveEv
 __ZNK7WebCore14RenderListItem10markerTextEv
 __ZNK7WebCore14ResourceHandle10connectionEv
 __ZNK7WebCore14ResourceLoader11frameLoaderEv
+__ZNK7WebCore14ResourceLoader17activeInputCursorEv
 __ZNK7WebCore14ResourceLoader32isAllowedToAskUserForCredentialsEv
 __ZNK7WebCore14ScrollableArea13scrolledToTopEv
 __ZNK7WebCore14ScrollableArea14scrollAnimatorEv
 __ZNK7WebCore14ScrollableArea14scrolledToLeftEv
 __ZNK7WebCore14ScrollableArea15scrolledToRightEv
 __ZNK7WebCore14ScrollableArea16scrolledToBottomEv
 __ZNK7WebCore14ScrollableArea17totalContentsSizeEv
 __ZNK7WebCore14ScrollableArea18visibleContentRectENS0_26VisibleContentRectBehaviorE
 __ZNK7WebCore14ScrollableArea20contentAreaWillPaintEv
 __ZNK7WebCore14ScrollableArea21mouseEnteredScrollbarEPNS_9ScrollbarE
@@ -3507,12 +3508,91 @@ __ZTVN7WebCore32WebVideoFullscreenInterfaceAVKitE
 
 #if ENABLE(VIDEO_TRACK)
 __ZN7WebCore9PageGroup18captionPreferencesEv
 #endif
 
 #if ENABLE(VIEW_MODE_CSS_MEDIA)
 __ZN7WebCore4Page11setViewModeENS0_8ViewModeE
 #endif
 
 #if ENABLE(WEB_REPLAY)
-__ZNK7WebCore14ResourceLoader17activeInputCursorEv
+__ZN3JSC11InputTraitsIN7WebCore10ScrollPageEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore10ScrollPageEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore10ScrollPageEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore11ReloadFrameEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore11ReloadFrameEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore11ReloadFrameEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore12TryClosePageEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore12TryClosePageEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore12TryClosePageEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore13DOMTimerFiredEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore13DOMTimerFiredEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore13DOMTimerFiredEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore14HandleKeyPressEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore14HandleKeyPressEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore14HandleKeyPressEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore14LoadURLRequestEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore14LoadURLRequestEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore14LoadURLRequestEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore15AsyncTimerFiredEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore15AsyncTimerFiredEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore15AsyncTimerFiredEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore15DOMTimerCreatedEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore15DOMTimerCreatedEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore15DOMTimerCreatedEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore15FetchPluginDataEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore15FetchPluginDataEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore15FetchPluginDataEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore15HandleMouseMoveEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore15HandleMouseMoveEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore15HandleMouseMoveEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore16HandleMousePressEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore16HandleMousePressEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore16HandleMousePressEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore16HandleWheelEventEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore16HandleWheelEventEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore16HandleWheelEventEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore16StopLoadingFrameEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore16StopLoadingFrameEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore16StopLoadingFrameEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore17InitialNavigationEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore17InitialNavigationEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore17InitialNavigationEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore17InitializeHistoryEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore17InitializeHistoryEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore17InitializeHistoryEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore17LogicalScrollPageEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore17LogicalScrollPageEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore17LogicalScrollPageEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore18EndSegmentSentinelEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore18EndSegmentSentinelEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore18EndSegmentSentinelEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore18HandleMouseReleaseEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore18HandleMouseReleaseEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore18HandleMouseReleaseEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore20BeginSegmentSentinelEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore20BeginSegmentSentinelEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore20BeginSegmentSentinelEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore21MemoizedDOMResultBaseEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore21MemoizedDOMResultBaseEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore21MemoizedDOMResultBaseEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore21ResourceLoaderDidFailEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore21ResourceLoaderDidFailEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore21ResourceLoaderDidFailEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore24DocumentLastModifiedDateEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore24DocumentLastModifiedDateEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore24DocumentLastModifiedDateEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore25ResourceLoaderDidSendDataEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore25ResourceLoaderDidSendDataEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore25ResourceLoaderDidSendDataEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore28ResourceLoaderDidReceiveDataEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore28ResourceLoaderDidReceiveDataEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore28ResourceLoaderDidReceiveDataEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore30ResourceLoaderDidFinishLoadingEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore30ResourceLoaderDidFinishLoadingEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore30ResourceLoaderDidFinishLoadingEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore32ResourceLoaderDidReceiveResponseEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore32ResourceLoaderDidReceiveResponseEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore32ResourceLoaderDidReceiveResponseEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC14EncodingTraitsIN7WebCore18PlatformMouseEventEE11encodeValueERKS2_
+__ZN3JSC14EncodingTraitsIN7WebCore18PlatformMouseEventEE11decodeValueERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
 #endif
diff --git a/Source/WebCore/WebCore.xcodeproj/project.pbxproj b/Source/WebCore/WebCore.xcodeproj/project.pbxproj
index 7056feb..4d2f705 100644
--- a/Source/WebCore/WebCore.xcodeproj/project.pbxproj
+++ b/Source/WebCore/WebCore.xcodeproj/project.pbxproj
@@ -3666,44 +3666,45 @@
 		97F8E666151D4A4E00D2D181 /* WorkerGlobalScopeNotifications.h in Headers */ = {isa = PBXBuildFile; fileRef = 97F8E662151D4A3F00D2D181 /* WorkerGlobalScopeNotifications.h */; };
 		9831AE4A154225C900FE2644 /* ReferrerPolicy.h in Headers */ = {isa = PBXBuildFile; fileRef = 9831AE49154225A200FE2644 /* ReferrerPolicy.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		984264F112D5280A000D88A4 /* LinkLoaderClient.h in Headers */ = {isa = PBXBuildFile; fileRef = 984264EF12D5280A000D88A4 /* LinkLoaderClient.h */; };
 		985BB96D13A94058007A0B69 /* LinkRelAttribute.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 985BB96B13A94058007A0B69 /* LinkRelAttribute.cpp */; };
 		985BB96E13A94058007A0B69 /* LinkRelAttribute.h in Headers */ = {isa = PBXBuildFile; fileRef = 985BB96C13A94058007A0B69 /* LinkRelAttribute.h */; };
 		98CE4326129E00BD005821DC /* LinkLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 98CE4325129E00BD005821DC /* LinkLoader.cpp */; };
 		98CE432A129E00E5005821DC /* LinkLoader.h in Headers */ = {isa = PBXBuildFile; fileRef = 98CE4329129E00E5005821DC /* LinkLoader.h */; };
 		98EB1F951313FE0500D0E1EA /* NotImplemented.h in Headers */ = {isa = PBXBuildFile; fileRef = 98EB1F941313FE0500D0E1EA /* NotImplemented.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		9920398218B95BC600B39AF9 /* UserInputBridge.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 9920398018B95BC600B39AF9 /* UserInputBridge.cpp */; };
 		9920398318B95BC600B39AF9 /* UserInputBridge.h in Headers */ = {isa = PBXBuildFile; fileRef = 9920398118B95BC600B39AF9 /* UserInputBridge.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		99C7CCB318C663E40032E413 /* MemoizedDOMResult.h in Headers */ = {isa = PBXBuildFile; fileRef = 99C7CCB218C663E40032E413 /* MemoizedDOMResult.h */; };
+		996231F318D18AC300C03FDA /* InspectorWebBackendCommands.js in Headers */ = {isa = PBXBuildFile; fileRef = 996231F118D189BD00C03FDA /* InspectorWebBackendCommands.js */; };
+		996231F418D22FA200C03FDA /* InspectorWebBackendCommands.js in Copy Generated Headers */ = {isa = PBXBuildFile; fileRef = 996231F118D189BD00C03FDA /* InspectorWebBackendCommands.js */; };
+		99C7CCB318C663E40032E413 /* MemoizedDOMResult.h in Headers */ = {isa = PBXBuildFile; fileRef = 99C7CCB218C663E40032E413 /* MemoizedDOMResult.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		99C7CCB518C6B8990032E413 /* MemoizedDOMResult.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99C7CCB418C6B8990032E413 /* MemoizedDOMResult.cpp */; };
-		99CC0B4D18BE9849006CEBCC /* AllReplayInputs.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B3818BE9849006CEBCC /* AllReplayInputs.h */; };
 		99CC0B4E18BE9849006CEBCC /* CapturingInputCursor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B3918BE9849006CEBCC /* CapturingInputCursor.cpp */; };
 		99CC0B4F18BE9849006CEBCC /* CapturingInputCursor.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B3A18BE9849006CEBCC /* CapturingInputCursor.h */; };
 		99CC0B5018BE9849006CEBCC /* EventLoopInputDispatcher.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B3B18BE9849006CEBCC /* EventLoopInputDispatcher.cpp */; };
 		99CC0B5118BE9849006CEBCC /* EventLoopInputDispatcher.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B3C18BE9849006CEBCC /* EventLoopInputDispatcher.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		99CC0B5218BE9849006CEBCC /* FunctorInputCursor.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B3D18BE9849006CEBCC /* FunctorInputCursor.h */; };
 		99CC0B5318BE9849006CEBCC /* ReplayController.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B3E18BE9849006CEBCC /* ReplayController.cpp */; };
 		99CC0B5418BE9849006CEBCC /* ReplayController.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B3F18BE9849006CEBCC /* ReplayController.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		99CC0B5518BE9849006CEBCC /* ReplayingInputCursor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B4018BE9849006CEBCC /* ReplayingInputCursor.cpp */; };
 		99CC0B5618BE984A006CEBCC /* ReplayingInputCursor.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B4118BE9849006CEBCC /* ReplayingInputCursor.h */; };
 		99CC0B5918BE984A006CEBCC /* ReplaySession.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B4418BE9849006CEBCC /* ReplaySession.cpp */; };
 		99CC0B5A18BE984A006CEBCC /* ReplaySession.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B4518BE9849006CEBCC /* ReplaySession.h */; };
 		99CC0B5B18BE984A006CEBCC /* ReplaySessionSegment.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B4618BE9849006CEBCC /* ReplaySessionSegment.cpp */; };
 		99CC0B5C18BE984A006CEBCC /* ReplaySessionSegment.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B4718BE9849006CEBCC /* ReplaySessionSegment.h */; };
 		99CC0B5D18BE984A006CEBCC /* SegmentedInputStorage.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B4818BE9849006CEBCC /* SegmentedInputStorage.cpp */; };
 		99CC0B5E18BE984A006CEBCC /* SegmentedInputStorage.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B4918BE9849006CEBCC /* SegmentedInputStorage.h */; };
 		99CC0B5F18BE984A006CEBCC /* WebReplayInputCoders.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B4A18BE9849006CEBCC /* WebReplayInputCoders.cpp */; };
 		99CC0B6018BE984A006CEBCC /* WebReplayInputCoders.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B4B18BE9849006CEBCC /* WebReplayInputCoders.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		99CC0B6618BE9F15006CEBCC /* InspectorReplayAgent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B6418BE9F15006CEBCC /* InspectorReplayAgent.cpp */; };
 		99CC0B6718BE9F15006CEBCC /* InspectorReplayAgent.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B6518BE9F15006CEBCC /* InspectorReplayAgent.h */; };
 		99CC0B6A18BEA1FF006CEBCC /* WebReplayInputs.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B6818BEA1FF006CEBCC /* WebReplayInputs.cpp */; };
-		99CC0B6B18BEA1FF006CEBCC /* WebReplayInputs.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B6918BEA1FF006CEBCC /* WebReplayInputs.h */; };
+		99CC0B6B18BEA1FF006CEBCC /* WebReplayInputs.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B6918BEA1FF006CEBCC /* WebReplayInputs.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		99E45A1718A063BE0026D88F /* EventLoopInput.h in Headers */ = {isa = PBXBuildFile; fileRef = 99E45A1618A063BE0026D88F /* EventLoopInput.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		9A1142041832D135000BB8AD /* ValueToString.h in Headers */ = {isa = PBXBuildFile; fileRef = 9A1142031832D134000BB8AD /* ValueToString.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		9A1B6F97158869C80011A8C4 /* JSDOMStringListCustom.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 9A1B6F96158869C80011A8C4 /* JSDOMStringListCustom.cpp */; };
 		9A528E8317D7F52F00AA9518 /* FloatingObjects.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 9A528E8117D7F52F00AA9518 /* FloatingObjects.cpp */; };
 		9A528E8417D7F52F00AA9518 /* FloatingObjects.h in Headers */ = {isa = PBXBuildFile; fileRef = 9A528E8217D7F52F00AA9518 /* FloatingObjects.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		9AB1F38018E2489A00534743 /* CSSToLengthConversionData.h in Headers */ = {isa = PBXBuildFile; fileRef = 9AB1F37E18E2489A00534743 /* CSSToLengthConversionData.h */; };
 		9AB1F38118E2489A00534743 /* CSSToLengthConversionData.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 9AB1F37F18E2489A00534743 /* CSSToLengthConversionData.cpp */; };
 		9B1AB07C1648C7C40051F3F2 /* JSHTMLFormControlsCollectionCustom.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 9B1AB07B1648C7C40051F3F2 /* JSHTMLFormControlsCollectionCustom.cpp */; };
 		9B24DE8E15194B9500C59C27 /* HTMLBDIElement.h in Headers */ = {isa = PBXBuildFile; fileRef = 9B24DE8C15194B9500C59C27 /* HTMLBDIElement.h */; };
 		9B2D8A7914997CCF00ECEF3E /* UndoStep.h in Headers */ = {isa = PBXBuildFile; fileRef = 9B2D8A7814997CCF00ECEF3E /* UndoStep.h */; settings = {ATTRIBUTES = (Private, ); }; };
@@ -10881,21 +10882,20 @@
 		984264EF12D5280A000D88A4 /* LinkLoaderClient.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LinkLoaderClient.h; sourceTree = "<group>"; };
 		985BB96B13A94058007A0B69 /* LinkRelAttribute.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LinkRelAttribute.cpp; sourceTree = "<group>"; };
 		985BB96C13A94058007A0B69 /* LinkRelAttribute.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LinkRelAttribute.h; sourceTree = "<group>"; };
 		98CE4325129E00BD005821DC /* LinkLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LinkLoader.cpp; sourceTree = "<group>"; };
 		98CE4329129E00E5005821DC /* LinkLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LinkLoader.h; sourceTree = "<group>"; };
 		98EB1F941313FE0500D0E1EA /* NotImplemented.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NotImplemented.h; sourceTree = "<group>"; };
 		9920398018B95BC600B39AF9 /* UserInputBridge.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = UserInputBridge.cpp; sourceTree = "<group>"; };
 		9920398118B95BC600B39AF9 /* UserInputBridge.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = UserInputBridge.h; sourceTree = "<group>"; };
 		99C7CCB218C663E40032E413 /* MemoizedDOMResult.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MemoizedDOMResult.h; sourceTree = "<group>"; };
 		99C7CCB418C6B8990032E413 /* MemoizedDOMResult.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MemoizedDOMResult.cpp; sourceTree = "<group>"; };
-		99CC0B3818BE9849006CEBCC /* AllReplayInputs.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AllReplayInputs.h; sourceTree = "<group>"; };
 		99CC0B3918BE9849006CEBCC /* CapturingInputCursor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CapturingInputCursor.cpp; sourceTree = "<group>"; };
 		99CC0B3A18BE9849006CEBCC /* CapturingInputCursor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CapturingInputCursor.h; sourceTree = "<group>"; };
 		99CC0B3B18BE9849006CEBCC /* EventLoopInputDispatcher.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = EventLoopInputDispatcher.cpp; sourceTree = "<group>"; };
 		99CC0B3C18BE9849006CEBCC /* EventLoopInputDispatcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EventLoopInputDispatcher.h; sourceTree = "<group>"; };
 		99CC0B3D18BE9849006CEBCC /* FunctorInputCursor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FunctorInputCursor.h; sourceTree = "<group>"; };
 		99CC0B3E18BE9849006CEBCC /* ReplayController.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ReplayController.cpp; sourceTree = "<group>"; };
 		99CC0B3F18BE9849006CEBCC /* ReplayController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ReplayController.h; sourceTree = "<group>"; };
 		99CC0B4018BE9849006CEBCC /* ReplayingInputCursor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ReplayingInputCursor.cpp; sourceTree = "<group>"; };
 		99CC0B4118BE9849006CEBCC /* ReplayingInputCursor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ReplayingInputCursor.h; sourceTree = "<group>"; };
 		99CC0B4218BE9849006CEBCC /* WebReplayInputCreationMethods.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WebReplayInputCreationMethods.cpp; sourceTree = "<group>"; };
@@ -18511,21 +18511,20 @@
 				977E2E0C12F0FC9C00C13379 /* XSSAuditor.h */,
 				977E2E0B12F0FC9C00C13380 /* XSSAuditorDelegate.cpp */,
 				977E2E0C12F0FC9C00C13380 /* XSSAuditorDelegate.h */,
 			);
 			name = parser;
 			sourceTree = "<group>";
 		};
 		99E45A1318A021760026D88F /* replay */ = {
 			isa = PBXGroup;
 			children = (
-				99CC0B3818BE9849006CEBCC /* AllReplayInputs.h */,
 				99CC0B3918BE9849006CEBCC /* CapturingInputCursor.cpp */,
 				99CC0B3A18BE9849006CEBCC /* CapturingInputCursor.h */,
 				C400D10818F1C8F60090D863 /* EventLoopInput.cpp */,
 				99E45A1618A063BE0026D88F /* EventLoopInput.h */,
 				99CC0B3B18BE9849006CEBCC /* EventLoopInputDispatcher.cpp */,
 				99CC0B3C18BE9849006CEBCC /* EventLoopInputDispatcher.h */,
 				99CC0B3D18BE9849006CEBCC /* FunctorInputCursor.h */,
 				99C7CCB418C6B8990032E413 /* MemoizedDOMResult.cpp */,
 				99C7CCB218C663E40032E413 /* MemoizedDOMResult.h */,
 				C4D4F5271975C88B003EF5BC /* ReplayableTimer.cpp */,
@@ -23482,21 +23481,20 @@
 				29A8122B0FBB9C1D00510293 /* AccessibilityTable.h in Headers */,
 				29A812320FBB9C1D00510293 /* AccessibilityTableCell.h in Headers */,
 				29A812410FBB9C1D00510293 /* AccessibilityTableColumn.h in Headers */,
 				29A8123F0FBB9C1D00510293 /* AccessibilityTableHeaderContainer.h in Headers */,
 				29A812310FBB9C1D00510293 /* AccessibilityTableRow.h in Headers */,
 				B5D31DFB11CF610B009F22B4 /* ActiveDOMCallback.h in Headers */,
 				E1C4DE690EA75C1E0023CCD6 /* ActiveDOMObject.h in Headers */,
 				BCF7E491137CD7C7001DDAE7 /* AdjustViewSizeOrNot.h in Headers */,
 				84D0C4061115F1EA0018AA34 /* AffineTransform.h in Headers */,
 				0705850817FA4689005F2BCB /* AllAudioCapabilities.h in Headers */,
-				99CC0B4D18BE9849006CEBCC /* AllReplayInputs.h in Headers */,
 				073AB4B317F8BACA006E0D6F /* AllVideoCapabilities.h in Headers */,
 				CEDA12D7152CA1CB00D9E08D /* AlternativeTextClient.h in Headers */,
 				CE08C3D2152B599A0021B8C2 /* AlternativeTextController.h in Headers */,
 				CE7B2DB31586ABAD0098B3FA /* AlternativeTextUIController.h in Headers */,
 				FD31603E12B0267600C1A359 /* AnalyserNode.h in Headers */,
 				31A795C71888BCB200382F90 /* ANGLEInstancedArrays.h in Headers */,
 				490707E71219C04300D90E51 /* ANGLEWebKitBridge.h in Headers */,
 				49E912AB0EFAC906009D0CAF /* Animation.h in Headers */,
 				316FE1120E6E1DA700BF6088 /* AnimationBase.h in Headers */,
 				316FE1140E6E1DA700BF6088 /* AnimationController.h in Headers */,
diff --git a/Source/WebCore/inspector/InspectorReplayAgent.cpp b/Source/WebCore/inspector/InspectorReplayAgent.cpp
index 2f2112b..5a9ec4e 100644
--- a/Source/WebCore/inspector/InspectorReplayAgent.cpp
+++ b/Source/WebCore/inspector/InspectorReplayAgent.cpp
@@ -35,50 +35,41 @@
 #include "EventLoopInput.h"
 #include "Frame.h"
 #include "FunctorInputCursor.h"
 #include "InspectorController.h"
 #include "InspectorPageAgent.h"
 #include <inspector/InspectorProtocolObjects.h>
 #include "InstrumentingAgents.h"
 #include "Logging.h"
 #include "Page.h"
 #include "ReplayController.h"
+#include "ReplayClient.h"
 #include "ReplaySession.h"
 #include "ReplaySessionSegment.h"
 #include "WebReplayInputCoders.h"
 #include "WebReplayInputs.h" // For EncodingTraits<InputQueue>.
 #include <inspector/InspectorValues.h>
 #include <wtf/text/CString.h>
 #include <wtf/text/WTFString.h>
 
 using namespace Inspector;
 
 namespace WebCore {
 
 static Ref<Inspector::Protocol::Replay::ReplayPosition> buildInspectorObjectForPosition(const ReplayPosition& position)
 {
     return Inspector::Protocol::Replay::ReplayPosition::create()
         .setSegmentOffset(position.segmentOffset)
         .setInputOffset(position.inputOffset)
         .release();
 }
 
-static Ref<Inspector::Protocol::Replay::ReplayInput> buildInspectorObjectForInput(const NondeterministicInputBase& input, size_t offset)
-{
-    EncodedValue encodedInput = EncodingTraits<NondeterministicInputBase>::encodeValue(input);
-    return Inspector::Protocol::Replay::ReplayInput::create()
-        .setType(input.type())
-        .setOffset(offset)
-        .setData(encodedInput.asObject())
-        .release();
-}
-
 static Ref<Inspector::Protocol::Replay::ReplaySession> buildInspectorObjectForSession(RefPtr<ReplaySession>&& session)
 {
     auto segments = Inspector::Protocol::Array<SegmentIdentifier>::create();
 
     for (auto it = session->begin(); it != session->end(); ++it)
         segments->addItem((*it)->identifier());
 
     return Inspector::Protocol::Replay::ReplaySession::create()
         .setId(session->identifier())
         .setTimestamp(session->timestamp())
@@ -100,52 +91,63 @@ static Inspector::Protocol::Replay::SegmentState buildInspectorObjectForSegmentS
     switch (segmentState) {
     case WebCore::SegmentState::Appending: return Inspector::Protocol::Replay::SegmentState::Appending;
     case WebCore::SegmentState::Unloaded: return Inspector::Protocol::Replay::SegmentState::Unloaded;
     case WebCore::SegmentState::Loaded: return Inspector::Protocol::Replay::SegmentState::Loaded;
     case WebCore::SegmentState::Dispatching: return Inspector::Protocol::Replay::SegmentState::Dispatching;
     }
 }
 
 class SerializeInputToJSONFunctor {
 public:
-    typedef RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Replay::ReplayInput>> ReturnType;
+    typedef Ref<Inspector::Protocol::Array<Inspector::Protocol::Replay::ReplayInput>> ReturnType;
 
-    SerializeInputToJSONFunctor()
-        : m_inputs(Inspector::Protocol::Array<Inspector::Protocol::Replay::ReplayInput>::create()) { }
+    SerializeInputToJSONFunctor(ReplayClient& client)
+        : m_client(client)
+        , m_inputs(Inspector::Protocol::Array<Inspector::Protocol::Replay::ReplayInput>::create()) { }
     ~SerializeInputToJSONFunctor() { }
 
     void operator()(size_t index, const NondeterministicInputBase* input)
     {
         LOG(WebReplay, "%-25s Writing %5zu: %s\n", "[SerializeInput]", index, input->type().ascii().data());
 
-        if (RefPtr<Inspector::Protocol::Replay::ReplayInput> serializedInput = buildInspectorObjectForInput(*input, index))
-            m_inputs->addItem(WTF::move(serializedInput));
+        EncodedValue encodedInput;
+        if (!m_client.encodeInput(*input, encodedInput))
+            return;
+
+        auto inputObject = Inspector::Protocol::Replay::ReplayInput::create()
+            .setType(input->type())
+            .setOffset(index)
+            .setData(encodedInput.asObject())
+            .release();
+
+        m_inputs->addItem(WTF::move(inputObject));
     }
 
     ReturnType returnValue() { return WTF::move(m_inputs); }
 private:
-    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Replay::ReplayInput>> m_inputs;
+    ReplayClient& m_client;
+    Ref<Inspector::Protocol::Array<Inspector::Protocol::Replay::ReplayInput>> m_inputs;
 };
 
-static Ref<Inspector::Protocol::Replay::SessionSegment> buildInspectorObjectForSegment(RefPtr<ReplaySessionSegment>&& segment)
+static Ref<Inspector::Protocol::Replay::SessionSegment> buildInspectorObjectForSegment(RefPtr<ReplaySessionSegment>&& segment, ReplayClient& client)
 {
     auto queuesObject = Inspector::Protocol::Array<Inspector::Protocol::Replay::ReplayInputQueue>::create();
 
     for (size_t i = 0; i < static_cast<size_t>(InputQueue::Count); i++) {
-        SerializeInputToJSONFunctor collector;
+        SerializeInputToJSONFunctor collector(client);
         InputQueue queue = static_cast<InputQueue>(i);
-        RefPtr<FunctorInputCursor> functorCursor = FunctorInputCursor::create(segment.copyRef());
-        RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Replay::ReplayInput>> queueInputs = functorCursor->forEachInputInQueue(queue, collector);
+        auto functorCursor = FunctorInputCursor::create(segment.copyRef());
+        Ref<Inspector::Protocol::Array<Inspector::Protocol::Replay::ReplayInput>> queueInputs = functorCursor->forEachInputInQueue(queue, collector);
 
         auto queueObject = Inspector::Protocol::Replay::ReplayInputQueue::create()
             .setType(EncodingTraits<InputQueue>::encodeValue(queue).convertTo<String>())
-            .setInputs(queueInputs)
+            .setInputs(WTF::move(queueInputs))
             .release();
         queuesObject->addItem(WTF::move(queueObject));
     }
 
     return Inspector::Protocol::Replay::SessionSegment::create()
         .setId(segment->identifier())
         .setTimestamp(segment->timestamp())
         .setQueues(WTF::move(queuesObject))
         .release();
 }
@@ -443,34 +445,34 @@ void InspectorReplayAgent::removeSessionSegment(ErrorString& errorString, Inspec
 RefPtr<ReplaySession> InspectorReplayAgent::findSession(ErrorString& errorString, SessionIdentifier identifier)
 {
     ASSERT_ARG(identifier, identifier > 0);
 
     auto it = m_sessionsMap.find(identifier);
     if (it == m_sessionsMap.end()) {
         errorString = ASCIILiteral("Couldn't find session with specified identifier");
         return nullptr;
     }
 
-    return it->value;
+    return it->value.copyRef();
 }
 
 RefPtr<ReplaySessionSegment> InspectorReplayAgent::findSegment(ErrorString& errorString, SegmentIdentifier identifier)
 {
     ASSERT_ARG(identifier, identifier > 0);
 
     auto it = m_segmentsMap.find(identifier);
     if (it == m_segmentsMap.end()) {
         errorString = ASCIILiteral("Couldn't find segment with specified identifier");
         return nullptr;
     }
 
-    return it->value;
+    return it->value.copyRef();
 }
 
 void InspectorReplayAgent::currentReplayState(ErrorString&, Inspector::Protocol::Replay::SessionIdentifier* sessionIdentifier, Inspector::Protocol::OptOutput<Inspector::Protocol::Replay::SegmentIdentifier>* segmentIdentifier, Inspector::Protocol::Replay::SessionState* sessionState, Inspector::Protocol::Replay::SegmentState* segmentState, RefPtr<Inspector::Protocol::Replay::ReplayPosition>& replayPosition)
 {
     *sessionState = buildInspectorObjectForSessionState(m_page.replayController().sessionState());
     *segmentState = buildInspectorObjectForSegmentState(m_page.replayController().segmentState());
 
     *sessionIdentifier = m_page.replayController().loadedSession()->identifier();
     if (m_page.replayController().loadedSegment())
         *segmentIdentifier = m_page.replayController().loadedSegment()->identifier();
@@ -497,16 +499,16 @@ void InspectorReplayAgent::getSessionData(ErrorString& errorString, Inspector::P
 }
 
 void InspectorReplayAgent::getSegmentData(ErrorString& errorString, Inspector::Protocol::Replay::SegmentIdentifier identifier, RefPtr<Inspector::Protocol::Replay::SessionSegment>& serializedObject)
 {
     RefPtr<ReplaySessionSegment> segment = findSegment(errorString, identifier);
     if (!segment) {
         errorString = ASCIILiteral("Couldn't find the specified segment.");
         return;
     }
 
-    serializedObject = buildInspectorObjectForSegment(WTF::move(segment));
+    serializedObject = buildInspectorObjectForSegment(WTF::move(segment), m_page.replayController().client());
 }
 
 } // namespace WebCore
 
 #endif // ENABLE(WEB_REPLAY)
diff --git a/Source/WebCore/loader/EmptyClients.h b/Source/WebCore/loader/EmptyClients.h
index 58f52a5..dcb26a1 100644
--- a/Source/WebCore/loader/EmptyClients.h
+++ b/Source/WebCore/loader/EmptyClients.h
@@ -603,20 +603,22 @@ public:
     virtual void hideHighlight() override { }
 };
 
 #if ENABLE(WEB_REPLAY)
 class EmptyReplayClient : public ReplayClient {
 public:
     EmptyReplayClient() { }
     virtual ~EmptyReplayClient() { }
 
     virtual void dispatchInput(EventLoopInputBase&) override { }
+    virtual bool encodeInput(const JSC::NondeterministicInputBase&, JSC::EncodedValue&) override { return false; }
+    virtual bool decodeInput(JSC::EncodedValue&, std::unique_ptr<JSC::NondeterministicInputBase>&) override { return false; }
 };
 #endif // ENABLE(WEB_REPLAY)
 
 class EmptyDeviceClient : public DeviceClient {
 public:
     virtual void startUpdating() override { }
     virtual void stopUpdating() override { }
 };
 
 class EmptyDeviceMotionClient : public DeviceMotionClient {
diff --git a/Source/WebCore/replay/AllReplayInputs.h b/Source/WebCore/replay/AllReplayInputs.h
deleted file mode 100644
index 669bc25..0000000
--- a/Source/WebCore/replay/AllReplayInputs.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2013 University of Washington. All rights reserved.
- * Copyright (C) 2014 Apple Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- * 2.  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-// This file is the include equivalent for WEB_REPLAY_INPUT_NAMES_FOR_EACH.
-// Note that there is not an exact correspondence between the two, since
-// Some input types reside in the same file.
-
-#ifndef AllReplayInputs_h
-#define AllReplayInputs_h
-
-#if ENABLE(WEB_REPLAY)
-
-#include "MemoizedDOMResult.h"
-#include "WebReplayInputs.h"
-#include <JavaScriptCore/JSReplayInputs.h>
-
-#define IMPORT_FROM_JSC_NAMESPACE(name) \
-using JSC::name; \
-
-JS_REPLAY_INPUT_NAMES_FOR_EACH(IMPORT_FROM_JSC_NAMESPACE)
-
-#endif // ENABLE(WEB_REPLAY)
-
-#endif // AllReplayInputs_h
diff --git a/Source/WebCore/replay/CapturingInputCursor.cpp b/Source/WebCore/replay/CapturingInputCursor.cpp
index 03cee92..5f2c02c 100644
--- a/Source/WebCore/replay/CapturingInputCursor.cpp
+++ b/Source/WebCore/replay/CapturingInputCursor.cpp
@@ -25,53 +25,86 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "CapturingInputCursor.h"
 
 #if ENABLE(WEB_REPLAY)
 
 #include "EventLoopInput.h"
 #include "Logging.h"
+#include "Page.h"
+#include "ReplayController.h"
+#include "ReplayClient.h"
 #include "ReplaySessionSegment.h"
 #include "SegmentedInputStorage.h"
+#include <replay/EncodedValue.h>
 #include <wtf/CurrentTime.h>
+#include <wtf/text/CString.h>
+
+#if !LOG_DISABLED
+// This is used to make the log spew from LOG(WebReplay, ...) more readable.
+static const char* queueTypeToLogPrefix(InputQueue queue)
+{
+    switch (queue) {
+    case InputQueue::EventLoopInput: return ">DSPTCH-STORE";
+    case InputQueue::LoaderMemoizedData: return "<LDMEMO-STORE";
+    case InputQueue::ScriptMemoizedData: return "<---<---<---JSMEMO-STORE";
+    case InputQueue::Count: return "ERROR!";
+    }
+}
+#endif // !LOG_DISABLED
 
 namespace WebCore {
 
-CapturingInputCursor::CapturingInputCursor(RefPtr<ReplaySessionSegment>&& segment)
+CapturingInputCursor::CapturingInputCursor(RefPtr<ReplaySessionSegment>&& segment, Page& page)
     : m_segment(WTF::move(segment))
+    , m_page(page)
 {
     LOG(WebReplay, "%-30sCreated capture cursor=%p.\n", "[ReplayController]", this);
 }
 
 CapturingInputCursor::~CapturingInputCursor()
 {
     LOG(WebReplay, "%-30sDestroyed capture cursor=%p.\n", "[ReplayController]", this);
 }
 
-Ref<CapturingInputCursor> CapturingInputCursor::create(RefPtr<ReplaySessionSegment>&& segment)
+Ref<CapturingInputCursor> CapturingInputCursor::create(RefPtr<ReplaySessionSegment>&& segment, Page& page)
 {
-    return adoptRef(*new CapturingInputCursor(WTF::move(segment)));
+    return adoptRef(*new CapturingInputCursor(WTF::move(segment), page));
 }
 
 void CapturingInputCursor::storeInput(std::unique_ptr<NondeterministicInputBase> input)
 {
     ASSERT_ARG(input, input);
 
     if (input->queue() == InputQueue::EventLoopInput) {
         // FIXME: rewrite this (and related dispatch code) to use std::chrono.
         double now = monotonicallyIncreasingTime();
         m_segment->eventLoopTimings().append(now);
     }
 
-    m_segment->storage().store(WTF::move(input));
+    InputQueue queue = input->queue();
+    const String& type = input->type();
+    EncodedValue encodedInput;
+    m_page.replayController().client().encodeInput(*input, encodedInput);
+
+    size_t inputCount = m_segment->storage().store(WTF::move(input));
+
+#if !LOG_DISABLED
+    LOG(WebReplay, "%-14s#%-5zu %s: %s %s\n", "ReplayEvents", inputCount, queueTypeToLogPrefix(queue), type.utf8().data(), encodedInput.asObject()->toJSONString().utf8().data());
+#else
+    UNUSED_PARAM(queue);
+    UNUSED_PARAM(type);
+    UNUSED_PARAM(encodedInput);
+    UNUSED_PARAM(inputCount);
+#endif
 }
 
 NondeterministicInputBase* CapturingInputCursor::loadInput(InputQueue, const String&)
 {
     // Can't load inputs from capturing cursor.
     ASSERT_NOT_REACHED();
     return nullptr;
 }
 
 NondeterministicInputBase* CapturingInputCursor::uncheckedLoadInput(InputQueue)
diff --git a/Source/WebCore/replay/CapturingInputCursor.h b/Source/WebCore/replay/CapturingInputCursor.h
index a414c2e..e63b907 100644
--- a/Source/WebCore/replay/CapturingInputCursor.h
+++ b/Source/WebCore/replay/CapturingInputCursor.h
@@ -24,45 +24,47 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef CapturingInputCursor_h
 #define CapturingInputCursor_h
 
 #if ENABLE(WEB_REPLAY)
 
 #include <replay/InputCursor.h>
+#include <wtf/RefPtr.h>
 #include <wtf/Noncopyable.h>
 #include <wtf/RefPtr.h>
 
 namespace WebCore {
 
 class EventLoopInputExtent;
 class Page;
 class ReplaySessionSegment;
 
 class CapturingInputCursor final : public InputCursor {
     WTF_MAKE_NONCOPYABLE(CapturingInputCursor);
 public:
-    static Ref<CapturingInputCursor> create(RefPtr<ReplaySessionSegment>&&);
+    static Ref<CapturingInputCursor> create(RefPtr<ReplaySessionSegment>&&, Page&);
     virtual ~CapturingInputCursor();
 
     virtual bool isCapturing() const override { return true; }
     virtual bool isReplaying() const override { return false; }
 
 protected:
     virtual NondeterministicInputBase* loadInput(InputQueue, const String& type) override;
 
 private:
-    CapturingInputCursor(RefPtr<ReplaySessionSegment>&&);
+    CapturingInputCursor(RefPtr<ReplaySessionSegment>&&, Page&);
 
     virtual NondeterministicInputBase* uncheckedLoadInput(InputQueue) override;
     virtual void storeInput(std::unique_ptr<NondeterministicInputBase>) override;
 
     RefPtr<ReplaySessionSegment> m_segment;
+    Page& m_page;
 };
 
 } // namespace WebCore
 
 #endif // ENABLE(WEB_REPLAY)
 
 #endif // CapturingInputCursor_h
diff --git a/Source/WebCore/replay/EventLoopInputDispatcher.cpp b/Source/WebCore/replay/EventLoopInputDispatcher.cpp
index a501569..3b5702c 100644
--- a/Source/WebCore/replay/EventLoopInputDispatcher.cpp
+++ b/Source/WebCore/replay/EventLoopInputDispatcher.cpp
@@ -127,25 +127,25 @@ void EventLoopInputDispatcher::dispatchInput()
 {
     ASSERT(m_currentWork.input);
     ASSERT(!m_dispatching);
 
     if (m_speed == DispatchSpeed::RealTime) {
         m_previousDispatchStartTime = monotonicallyIncreasingTime();
         m_previousInputTimestamp = m_currentWork.timestamp;
     }
 
 #if !LOG_DISABLED
-    EncodedValue encodedInput = EncodingTraits<NondeterministicInputBase>::encodeValue(*m_currentWork.input);
-    String jsonString = encodedInput.asObject()->toJSONString();
-
-    LOG(WebReplay, "%-20s ----------------------------------------------", "ReplayEvents");
-    LOG(WebReplay, "%-20s >DISPATCH: %s %s\n", "ReplayEvents", m_currentWork.input->type().utf8().data(), jsonString.utf8().data());
+    EncodedValue encodedInput;
+    if (m_page.replayController().client().encodeInput(*m_currentWork.input, encodedInput)) {
+        LOG(WebReplay, "%-20s ----------------------------------------------", "ReplayEvents");
+        LOG(WebReplay, "%-20s >DISPATCH: %s %s\n", "ReplayEvents", m_currentWork.input->type().utf8().data(), encodedInput.asObject()->toJSONString().utf8().data());
+    }
 #endif
 
     m_client->willDispatchInput(*m_currentWork.input);
     // Client could stop replay in the previous callback, so check again.
     if (!m_running)
         return;
 
     {
         TemporaryChange<bool> change(m_dispatching, true);
         m_page.replayController().client().dispatchInput(*m_currentWork.input);
diff --git a/Source/WebCore/replay/ReplayClient.h b/Source/WebCore/replay/ReplayClient.h
index 56bb2c0..c6819e8 100644
--- a/Source/WebCore/replay/ReplayClient.h
+++ b/Source/WebCore/replay/ReplayClient.h
@@ -21,26 +21,34 @@
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef ReplayClient_h
 #define ReplayClient_h
 
 #if ENABLE(WEB_REPLAY)
 
+namespace JSC {
+class EncodedValue;
+class NondeterministicInputBase;
+}
+
 namespace WebCore {
 
 class EventLoopInputBase;
 
 class ReplayClient {
 public:
     virtual ~ReplayClient() { }
 
     virtual void dispatchInput(EventLoopInputBase&) = 0;
+
+    virtual bool encodeInput(const JSC::NondeterministicInputBase&, JSC::EncodedValue&) = 0;
+    virtual bool decodeInput(JSC::EncodedValue&, std::unique_ptr<JSC::NondeterministicInputBase>&) = 0;
 };
 
 } // namespace WebCore
 
 #endif // ENABLE(WEB_REPLAY)
 
 #endif // !defined(ReplayClient_h)
diff --git a/Source/WebCore/replay/ReplayController.cpp b/Source/WebCore/replay/ReplayController.cpp
index 3ed2e5d..a53c1c7 100644
--- a/Source/WebCore/replay/ReplayController.cpp
+++ b/Source/WebCore/replay/ReplayController.cpp
@@ -23,21 +23,20 @@
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "ReplayController.h"
 
 #if ENABLE(WEB_REPLAY)
 
-#include "AllReplayInputs.h"
 #include "CapturingInputCursor.h"
 #include "DOMWindow.h"
 #include "DocumentLoader.h"
 #include "Frame.h"
 #include "FrameTree.h"
 #include "InspectorInstrumentation.h"
 #include "Location.h"
 #include "Logging.h"
 #include "MainFrame.h"
 #include "Page.h"
@@ -222,21 +221,21 @@ void ReplayController::createSegment()
     setSegmentState(SegmentState::Appending);
 
     // Create a new segment but don't associate it with the current session
     // until we stop appending to it. This preserves the invariant that
     // segments associated with a replay session have immutable data.
     m_loadedSegment = ReplaySessionSegment::create();
 
     LOG(WebReplay, "%-20s Created segment: %p.\n", "ReplayController", m_loadedSegment.get());
     InspectorInstrumentation::segmentCreated(m_page, m_loadedSegment.copyRef());
 
-    m_activeCursor = CapturingInputCursor::create(m_loadedSegment.copyRef());
+    m_activeCursor = CapturingInputCursor::create(m_loadedSegment.copyRef(), m_page);
     m_activeCursor->appendInput<BeginSegmentSentinel>();
 
     // Dispatching this input saves history, clears all but the current item, appends saved
     // history item to the back/forward list, then moves the current item cursor to the last entry.
     std::unique_ptr<InitializeHistory> historyInput = InitializeHistory::createFromPage(m_page);
     m_client.dispatchInput(*historyInput);
     m_activeCursor->storeInput(WTF::move(historyInput));
 
     // Dispatching this input schedules navigation of the main frame, causing a refresh.
     std::unique_ptr<InitialNavigation> navigationInput = InitialNavigation::createFromPage(m_page);
diff --git a/Source/WebCore/replay/ReplayingInputCursor.cpp b/Source/WebCore/replay/ReplayingInputCursor.cpp
index dd0cead..0504d29 100644
--- a/Source/WebCore/replay/ReplayingInputCursor.cpp
+++ b/Source/WebCore/replay/ReplayingInputCursor.cpp
@@ -24,30 +24,48 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "ReplayingInputCursor.h"
 
 #if ENABLE(WEB_REPLAY)
 
 #include "EventLoopInputDispatcher.h"
+#include "Logging.h"
+#include "Page.h"
+#include "ReplayClient.h"
+#include "ReplayController.h"
 #include "ReplaySessionSegment.h"
 #include "SegmentedInputStorage.h"
 #include "WebReplayInputCoders.h"
 #include "WebReplayInputs.h"
 #include <wtf/text/CString.h>
 
 namespace WebCore {
 
+#if !LOG_DISABLED
+// This is used to make the log spew from LOG(WebReplay, ...) more readable.
+static const char* queueTypeToLogPrefix(InputQueue queue)
+{
+    switch (queue) {
+    case InputQueue::EventLoopInput: return "(DSPTCH-LOAD)";
+    case InputQueue::LoaderMemoizedData: return "<LDMEMO-LOAD";
+    case InputQueue::ScriptMemoizedData: return "<---<---<---JSMEMO-LOAD";
+    case InputQueue::Count: return "ERROR!";
+    }
+}
+#endif // !LOG_DISABLED
+
 ReplayingInputCursor::ReplayingInputCursor(RefPtr<ReplaySessionSegment>&& segment, Page& page, EventLoopInputDispatcherClient* client)
     : m_segment(WTF::move(segment))
+    , m_page(page)
     , m_dispatcher(std::make_unique<EventLoopInputDispatcher>(page, *this, client))
 {
     for (size_t i = 0; i < static_cast<size_t>(InputQueue::Count); i++)
         m_positions.append(0);
 }
 
 ReplayingInputCursor::~ReplayingInputCursor()
 {
 }
 
@@ -75,21 +93,29 @@ NondeterministicInputBase* ReplayingInputCursor::loadInput(InputQueue queue, con
 }
 
 NondeterministicInputBase* ReplayingInputCursor::uncheckedLoadInput(InputQueue queue)
 {
     if (m_positions[static_cast<size_t>(queue)] >= m_segment->storage().queueSize(queue)) {
         String queueString = EncodingTraits<InputQueue>::encodeValue(queue).convertTo<String>();
         LOG_ERROR("%-30s ERROR No more inputs remain for determinism queue %s, but one was requested.", "[ReplayingInputCursor]", queueString.ascii().data());
         return nullptr;
     }
 
-    return m_segment->storage().load(queue, m_positions[static_cast<size_t>(queue)]++);
+    NondeterministicInputBase* input = m_segment->storage().load(queue, m_positions[static_cast<size_t>(queue)]++);
+    if (!input)
+        return nullptr;
+    
+    EncodedValue encodedInput;
+    m_page.replayController().client().encodeInput(*input, encodedInput);
+    LOG(WebReplay, "%-20s %s: %s %s\n", "ReplayEvents", queueTypeToLogPrefix(queue), input->type().utf8().data(), encodedInput.asObject()->toJSONString().utf8().data());
+
+    return input;
 }
 
 EventLoopInputData ReplayingInputCursor::loadEventLoopInput()
 {
     ASSERT(m_segment);
 
     size_t offset = m_positions.at(static_cast<size_t>(InputQueue::EventLoopInput));
     ASSERT(offset < m_segment->eventLoopTimings().size());
 
     EventLoopInputData data;
diff --git a/Source/WebCore/replay/ReplayingInputCursor.h b/Source/WebCore/replay/ReplayingInputCursor.h
index 7a47503..0da1e96 100644
--- a/Source/WebCore/replay/ReplayingInputCursor.h
+++ b/Source/WebCore/replay/ReplayingInputCursor.h
@@ -56,19 +56,20 @@ public:
     EventLoopInputData loadEventLoopInput();
 protected:
     virtual NondeterministicInputBase* loadInput(InputQueue, const String& type) override;
 private:
     ReplayingInputCursor(RefPtr<ReplaySessionSegment>&&, Page&, EventLoopInputDispatcherClient*);
 
     virtual void storeInput(std::unique_ptr<NondeterministicInputBase>) override;
     virtual NondeterministicInputBase* uncheckedLoadInput(InputQueue) override;
 
     RefPtr<ReplaySessionSegment> m_segment;
+    Page& m_page;
     std::unique_ptr<EventLoopInputDispatcher> m_dispatcher;
     Vector<size_t> m_positions;
 };
 
 } // namespace WebCore
 
 #endif // ENABLE(WEB_REPLAY)
 
 #endif // ReplayingInputCursor_h
diff --git a/Source/WebCore/replay/SegmentedInputStorage.cpp b/Source/WebCore/replay/SegmentedInputStorage.cpp
index 287f3b7..57a5fa6 100644
--- a/Source/WebCore/replay/SegmentedInputStorage.cpp
+++ b/Source/WebCore/replay/SegmentedInputStorage.cpp
@@ -23,58 +23,22 @@
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "SegmentedInputStorage.h"
 
 #if ENABLE(WEB_REPLAY)
 
-#if !LOG_DISABLED
-#include "Logging.h"
-#include "WebReplayInputCoders.h"
-#include <replay/EncodedValue.h>
-#include <wtf/text/CString.h>
-#include <wtf/text/WTFString.h>
-#endif
-
 namespace WebCore {
 
-#if !LOG_DISABLED
-// These are used to make the log spew from LOG(WebReplay, ...) more readable.
-static const char* queueTypeToLogPrefix(InputQueue inputQueue, bool isLoad)
-{
-    if (isLoad) {
-        switch (inputQueue) {
-        case InputQueue::EventLoopInput: return "(DSPTCH-LOAD)";
-        case InputQueue::LoaderMemoizedData: return "<LDMEMO-LOAD";
-        case InputQueue::ScriptMemoizedData: return "<---<---<---JSMEMO-LOAD";
-        case InputQueue::Count: return "ERROR!";
-        }
-    } else {
-        switch (inputQueue) {
-        case InputQueue::EventLoopInput: return ">DSPTCH-STORE";
-        case InputQueue::LoaderMemoizedData: return "<LDMEMO-STORE";
-        case InputQueue::ScriptMemoizedData: return "<---<---<---JSMEMO-STORE";
-        case InputQueue::Count: return "ERROR!";
-        }
-    }
-}
-
-static String jsonStringForInput(const NondeterministicInputBase& input)
-{
-    EncodedValue encodedValue = EncodingTraits<NondeterministicInputBase>::encodeValue(input);
-    return encodedValue.asObject()->toJSONString();
-}
-#endif // !LOG_DISABLED
-
 static size_t offsetForInputQueue(InputQueue inputQueue)
 {
     return static_cast<size_t>(inputQueue);
 }
 
 SegmentedInputStorage::SegmentedInputStorage()
 {
     for (size_t i = 0; i < offsetForInputQueue(InputQueue::Count); i++)
         m_queues.append(new QueuedInputs);
 }
@@ -85,33 +49,30 @@ SegmentedInputStorage::~SegmentedInputStorage()
         delete m_queues.at(i);
 }
 
 NondeterministicInputBase* SegmentedInputStorage::load(InputQueue inputQueue, size_t offset)
 {
     ASSERT(offset < queueSize(inputQueue));
 
     NondeterministicInputBase* input = queue(inputQueue).at(offset).get();
     ASSERT(input);
 
-    LOG(WebReplay, "%-20s %s: %s %s\n", "ReplayEvents", queueTypeToLogPrefix(inputQueue, true), input->type().utf8().data(), jsonStringForInput(*input).utf8().data());
-
     return input;
 }
 
-void SegmentedInputStorage::store(std::unique_ptr<NondeterministicInputBase> input)
+size_t SegmentedInputStorage::store(std::unique_ptr<NondeterministicInputBase> input)
 {
     ASSERT_ARG(input, input);
     ASSERT_ARG(input, input->queue() < InputQueue::Count);
 
-    LOG(WebReplay, "%-14s#%-5u %s: %s %s\n", "ReplayEvents", m_inputCount++, queueTypeToLogPrefix(input->queue(), false), input->type().utf8().data(), jsonStringForInput(*input).utf8().data());
-
     m_queues.at(offsetForInputQueue(input->queue()))->append(WTF::move(input));
+    return m_inputCount++;
 }
 
 size_t SegmentedInputStorage::queueSize(InputQueue inputQueue) const
 {
     return queue(inputQueue).size();
 }
 
 const SegmentedInputStorage::QueuedInputs& SegmentedInputStorage::queue(InputQueue queue) const
 {
     ASSERT_ARG(queue, queue < InputQueue::Count);
diff --git a/Source/WebCore/replay/SegmentedInputStorage.h b/Source/WebCore/replay/SegmentedInputStorage.h
index 074f964..5d4b520 100644
--- a/Source/WebCore/replay/SegmentedInputStorage.h
+++ b/Source/WebCore/replay/SegmentedInputStorage.h
@@ -37,21 +37,21 @@
 namespace WebCore {
 
 class SegmentedInputStorage {
     WTF_MAKE_NONCOPYABLE(SegmentedInputStorage);
     friend class FunctorInputCursor;
 public:
     SegmentedInputStorage();
     ~SegmentedInputStorage();
 
     NondeterministicInputBase* load(InputQueue, size_t);
-    void store(std::unique_ptr<NondeterministicInputBase>);
+    size_t store(std::unique_ptr<NondeterministicInputBase>);
     size_t queueSize(InputQueue) const;
 
 private:
     typedef Vector<std::unique_ptr<NondeterministicInputBase>> QueuedInputs;
     const QueuedInputs& queue(InputQueue) const;
 
     Vector<QueuedInputs*, 3> m_queues;
     unsigned m_inputCount {0};
 };
 
diff --git a/Source/WebCore/replay/WebReplayInputCoders.cpp b/Source/WebCore/replay/WebReplayInputCoders.cpp
index 643a8b0..17346a1 100644
--- a/Source/WebCore/replay/WebReplayInputCoders.cpp
+++ b/Source/WebCore/replay/WebReplayInputCoders.cpp
@@ -23,43 +23,45 @@
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "WebReplayInputCoders.h"
 
 #if ENABLE(WEB_REPLAY)
 
-#include "AllReplayInputs.h"
 #include "Document.h"
 #include "FormData.h"
 #include "Frame.h"
 #include "FrameLoadRequest.h"
 #include "FrameTree.h"
 #include "HTTPHeaderMap.h"
 #include "HistoryItem.h"
 #include "MainFrame.h"
+#include "MemoizedDOMResult.h"
 #include "Page.h"
 #include "PlatformKeyboardEvent.h"
 #include "PlatformMouseEvent.h"
 #include "PlatformWheelEvent.h"
 #include "PluginData.h"
 #include "ResourceError.h"
 #include "ResourceLoadTiming.h"
 #include "ResourceRequest.h"
 #include "ResourceResponse.h"
 #include "SecurityOrigin.h"
 #include "SerializedScriptValue.h"
 #include "SharedBuffer.h"
 #include "SubstituteData.h"
 #include "URL.h"
+#include "WebReplayInputs.h"
+#include <JavaScriptCore/JSReplayInputs.h>
 #include <wtf/text/Base64.h>
 
 using WebCore::FormData;
 using WebCore::FormDataElement;
 using WebCore::FrameLoadRequest;
 using WebCore::HTTPHeaderMap;
 using WebCore::HistoryItem;
 using WebCore::IntPoint;
 using WebCore::MimeClassInfo;
 using WebCore::MouseButton;
@@ -326,45 +328,20 @@ bool EncodingTraits<MimeClassInfo>::decodeValue(EncodedValue& encodedData, MimeC
     MimeClassInfo info;
 
     DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, String, type, info.type);
     DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, String, desc, info.desc);
     DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, Vector<String>, extensions, info.extensions);
 
     input = info;
     return true;
 }
 
-EncodedValue EncodingTraits<NondeterministicInputBase>::encodeValue(const NondeterministicInputBase& input)
-{
-    EncodedValue encodedValue = EncodedValue::createObject();
-    ENCODE_TYPE_WITH_KEY(encodedValue, String, type, input.type());
-
-#define ENCODE_IF_TYPE_TAG_MATCHES(name) \
-    if (is<name>(input)) { \
-        InputTraits<name>::encode(encodedValue, downcast<name>(input)); \
-        return encodedValue; \
-    } \
-
-    JS_REPLAY_INPUT_NAMES_FOR_EACH(ENCODE_IF_TYPE_TAG_MATCHES)
-    WEB_REPLAY_INPUT_NAMES_FOR_EACH(ENCODE_IF_TYPE_TAG_MATCHES)
-#undef ENCODE_IF_TYPE_TAG_MATCHES
-
-    // The macro won't work here because of the class template argument.
-    if (is<MemoizedDOMResultBase>(input)) {
-        InputTraits<MemoizedDOMResultBase>::encode(encodedValue, downcast<MemoizedDOMResultBase>(input));
-        return encodedValue;
-    }
-
-    ASSERT_NOT_REACHED();
-    return EncodedValue();
-}
-
 EncodedValue EncodingTraits<HistoryItem>::encodeValue(RefPtr<HistoryItem> item)
 {
     EncodedValue encodedValue = EncodedValue::createObject();
 
     ENCODE_TYPE_WITH_KEY(encodedValue, String, originalURLString, item->originalURLString());
     ENCODE_TYPE_WITH_KEY(encodedValue, String, urlString, item->urlString());
     ENCODE_TYPE_WITH_KEY(encodedValue, String, title, item->title());
     ENCODE_TYPE_WITH_KEY(encodedValue, String, parent, item->parent());
     ENCODE_TYPE_WITH_KEY(encodedValue, int64_t, documentSequenceNumber, item->documentSequenceNumber());
     ENCODE_TYPE_WITH_KEY(encodedValue, Vector<String>, documentState, item->documentState());
@@ -439,50 +416,20 @@ bool EncodingTraits<IntPoint>::decodeValue(EncodedValue& encodedData, IntPoint&
 {
     IntPoint decodedPoint;
 
     DECODE_TYPE_WITH_KEY(encodedData, int, x);
     DECODE_TYPE_WITH_KEY(encodedData, int, y);
 
     point = IntPoint(x, y);
     return true;
 }
 
-bool EncodingTraits<NondeterministicInputBase>::decodeValue(EncodedValue& encodedValue, std::unique_ptr<NondeterministicInputBase>& input)
-{
-    DECODE_TYPE_WITH_KEY(encodedValue, String, type);
-
-#define DECODE_IF_TYPE_TAG_MATCHES(name) \
-    if (type == InputTraits<name>::type()) { \
-        std::unique_ptr<name> decodedInput; \
-        if (!InputTraits<name>::decode(encodedValue, decodedInput)) \
-            return false; \
-        \
-        input = WTF::move(decodedInput); \
-        return true; \
-    } \
-
-    JS_REPLAY_INPUT_NAMES_FOR_EACH(DECODE_IF_TYPE_TAG_MATCHES)
-    WEB_REPLAY_INPUT_NAMES_FOR_EACH(DECODE_IF_TYPE_TAG_MATCHES)
-#undef DECODE_IF_TYPE_TAG_MATCHES
-
-    if (type == InputTraits<MemoizedDOMResultBase>::type()) {
-        std::unique_ptr<MemoizedDOMResultBase> decodedInput;
-        if (!InputTraits<MemoizedDOMResultBase>::decode(encodedValue, decodedInput))
-            return false;
-
-        input = WTF::move(decodedInput);
-        return true;
-    }
-
-    return false;
-}
-
 #if USE(APPKIT)
 EncodedValue EncodingTraits<KeypressCommand>::encodeValue(const KeypressCommand& command)
 {
     EncodedValue encodedValue = EncodedValue::createObject();
 
     ENCODE_TYPE_WITH_KEY(encodedValue, String, commandName, command.commandName);
     ENCODE_OPTIONAL_TYPE_WITH_KEY(encodedValue, String, text, command.text, !command.text.isEmpty());
 
     return encodedValue;
 }
diff --git a/Source/WebCore/replay/WebReplayInputCoders.h b/Source/WebCore/replay/WebReplayInputCoders.h
index 59f5cb6..a5d767f 100644
--- a/Source/WebCore/replay/WebReplayInputCoders.h
+++ b/Source/WebCore/replay/WebReplayInputCoders.h
@@ -100,27 +100,20 @@ template<> struct EncodingTraits<WebCore::KeypressCommand> {
 };
 #endif // USE(APPKIT)
 
 template<> struct EncodingTraits<WebCore::HistoryItem> {
     typedef RefPtr<WebCore::HistoryItem> DecodedType;
 
     static EncodedValue encodeValue(RefPtr<WebCore::HistoryItem>);
     static bool decodeValue(EncodedValue&, RefPtr<WebCore::HistoryItem>&);
 };
 
-template<> struct EncodingTraits<NondeterministicInputBase> {
-    typedef NondeterministicInputBase DecodedType;
-
-    static EncodedValue encodeValue(const NondeterministicInputBase& value);
-    static bool decodeValue(EncodedValue&, std::unique_ptr<NondeterministicInputBase>& value);
-};
-
 template<> struct EncodingTraits<WebCore::PlatformKeyboardEvent> {
     typedef WebCore::PlatformKeyboardEvent DecodedType;
 
     static EncodedValue encodeValue(const WebCore::PlatformKeyboardEvent& value);
     static bool decodeValue(EncodedValue&, std::unique_ptr<WebCore::PlatformKeyboardEvent>& value);
 };
 
 template<> struct EncodingTraits<WebCore::PlatformMouseEvent> {
     typedef WebCore::PlatformMouseEvent DecodedType;
 
diff --git a/Source/WebCore/replay/WebReplayInputDispatchMethods.cpp b/Source/WebCore/replay/WebReplayInputDispatchMethods.cpp
index ea452e6..7b5662c 100644
--- a/Source/WebCore/replay/WebReplayInputDispatchMethods.cpp
+++ b/Source/WebCore/replay/WebReplayInputDispatchMethods.cpp
@@ -21,37 +21,37 @@
  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 
 #if ENABLE(WEB_REPLAY)
 
-#include "AllReplayInputs.h"
 #include "BackForwardController.h"
 #include "DOMTimer.h"
 #include "Document.h"
 #include "DocumentLoader.h"
 #include "FrameLoadRequest.h"
 #include "FrameLoader.h"
 #include "HistoryController.h"
 #include "MainFrame.h"
 #include "NavigationScheduler.h"
 #include "Page.h"
 #include "ReplayController.h"
 #include "ReplayableTimers.h"
 #include "ResourceError.h"
 #include "ResourceLoader.h"
 #include "ResourceRequest.h"
 #include "WebReplayInputCoders.h"
+#include "WebReplayInputs.h"
 #include "URL.h"
 #include "UserInputBridge.h"
 #include <cinttypes>
 
 namespace WebCore {
 
 static ResourceLoader* resourceLoaderForOrdinal(Page& page, unsigned long ordinal, int frameIndex)
 {
     Frame* frame = frameFromFrameIndex(&page, frameIndex);
     ASSERT(frame);
diff --git a/Source/WebKit2/CMakeLists.txt b/Source/WebKit2/CMakeLists.txt
index 3201760..40c7fc9 100644
--- a/Source/WebKit2/CMakeLists.txt
+++ b/Source/WebKit2/CMakeLists.txt
@@ -835,19 +835,20 @@ if (ENABLE_WEB_REPLAY)
 =======
     set(WebKit2_WEB_REPLAY_INPUTS ${WEBKIT2_DIR}/WebProcess/Replay/WebInputs.json)
     add_custom_command(
         OUTPUT ${DERIVED_SOURCES_WEBKIT2_DIR}/WKReplayInputs.h ${DERIVED_SOURCES_WEBKIT2_DIR}/WKReplayInputs.cpp
         MAIN_DEPENDENCY ${JAVASCRIPTCORE_DIR}/replay/scripts/CodeGeneratorReplayInputs.py
         DEPENDS ${WebKit2_WEB_REPLAY_INPUTS}
         COMMAND ${PYTHON_EXECUTABLE} ${JAVASCRIPTCORE_DIR}/replay/scripts/CodeGeneratorReplayInputs.py --outputDir ${DERIVED_SOURCES_WEBKIT2_DIR}/ --framework WebKit ${WebKit2_WEB_REPLAY_INPUTS}
         VERBATIM)
 
     list(APPEND WebKit2_SOURCES
+        WebProcess/Replay/WKReplayInputCoders.cpp
         ${DERIVED_SOURCES_WEBKIT2_DIR}/WKReplayInputs.cpp
     )
 endif ()
 
 POPULATE_LIBRARY_VERSION(WEBKIT2)
 set_target_properties(WebKit2 PROPERTIES VERSION ${WEBKIT2_VERSION} SOVERSION ${WEBKIT2_VERSION_MAJOR})
 
 install(TARGETS WebKit2 DESTINATION "${LIB_INSTALL_DIR}")
 install(TARGETS WebProcess DESTINATION "${LIBEXEC_INSTALL_DIR}")
diff --git a/Source/WebKit2/ChangeLog b/Source/WebKit2/ChangeLog
index 23cb0b4..990b4d8 100644
--- a/Source/WebKit2/ChangeLog
+++ b/Source/WebKit2/ChangeLog
@@ -1,10 +1,35 @@
+2014-08-20  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Replay: Encode replay inputs through ReplayClient
+        https://bugs.webkit.org/show_bug.cgi?id=140448
+
+        Reviewed by NOBODY (OOPS!).
+
+        Only WebKit2 can access all frameworks' replay inputs, so it should contain
+        the big function with cases to encode each input based on its type tag.
+
+        Move some logging code out of SegmentedInputStorage so that inputs can be encoded
+        through ReplayClient and then displayed in the serialized JSON representation.
+
+        No new tests, no behavior was changed.
+
+        * CMakeLists.txt:
+        * WebKit2.xcodeproj/project.pbxproj:
+        * WebProcess/Replay/WKReplayInputCoders.cpp: Added.
+        (JSC::EncodingTraits<NondeterministicInputBase>::encodeValue): Added.
+        * WebProcess/Replay/WKReplayInputCoders.h: Added.
+        * WebProcess/WebCoreSupport/WebReplayClient.cpp:
+        (WebKit::WebReplayClient::encodeInput):
+        (WebKit::WebReplayClient::decodeInput):
+        * WebProcess/WebCoreSupport/WebReplayClient.h:
+
 2015-01-09  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Replay: support generating replay inputs for WebKit framework
         https://bugs.webkit.org/show_bug.cgi?id=140446
 
         Reviewed by NOBODY (OOPS!).
 
         Generate WebKit2-specific replay inputs from WKInputs.json with the code generator.
 
         * CMakeLists.txt:
diff --git a/Source/WebKit2/WebKit2.xcodeproj/project.pbxproj b/Source/WebKit2/WebKit2.xcodeproj/project.pbxproj
index 641850e..990a933 100644
--- a/Source/WebKit2/WebKit2.xcodeproj/project.pbxproj
+++ b/Source/WebKit2/WebKit2.xcodeproj/project.pbxproj
@@ -1621,20 +1621,22 @@
 		C0CE72A01247E71D00BC0EC4 /* WebPageMessageReceiver.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C0CE729E1247E71D00BC0EC4 /* WebPageMessageReceiver.cpp */; };
 		C0CE72A11247E71D00BC0EC4 /* WebPageMessages.h in Headers */ = {isa = PBXBuildFile; fileRef = C0CE729F1247E71D00BC0EC4 /* WebPageMessages.h */; };
 		C0CE72AD1247E78D00BC0EC4 /* HandleMessage.h in Headers */ = {isa = PBXBuildFile; fileRef = C0CE72AC1247E78D00BC0EC4 /* HandleMessage.h */; };
 		C0E3AA7A1209E83000A49D01 /* ModuleCF.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C0E3AA481209E45000A49D01 /* ModuleCF.cpp */; };
 		C0E3AA7B1209E83500A49D01 /* Module.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C0E3AA451209E2BA00A49D01 /* Module.cpp */; };
 		C0E3AA7C1209E83C00A49D01 /* Module.h in Headers */ = {isa = PBXBuildFile; fileRef = C0E3AA441209E2BA00A49D01 /* Module.h */; };
 		C49474B019A3F93F009B3DE8 /* WebReplayClient.h in Headers */ = {isa = PBXBuildFile; fileRef = C49474AE19A3F924009B3DE8 /* WebReplayClient.h */; };
 		C49474B119A3F947009B3DE8 /* WebReplayClient.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C49474AD19A3F924009B3DE8 /* WebReplayClient.cpp */; };
 		C49474B719A41B73009B3DE8 /* WKReplayInputs.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C49474B519A41B73009B3DE8 /* WKReplayInputs.cpp */; };
 		C49474B819A41B73009B3DE8 /* WKReplayInputs.h in Headers */ = {isa = PBXBuildFile; fileRef = C49474B619A41B73009B3DE8 /* WKReplayInputs.h */; };
+		C49474BB19A5413F009B3DE8 /* WKReplayInputCoders.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C49474B919A5413F009B3DE8 /* WKReplayInputCoders.cpp */; };
+		C49474BC19A5413F009B3DE8 /* WKReplayInputCoders.h in Headers */ = {isa = PBXBuildFile; fileRef = C49474BA19A5413F009B3DE8 /* WKReplayInputCoders.h */; };
 		C517388112DF8F4F00EE3F47 /* DragControllerAction.h in Headers */ = {isa = PBXBuildFile; fileRef = C517388012DF8F4F00EE3F47 /* DragControllerAction.h */; };
 		C5237F6012441CA300780472 /* WebEditorClientMac.mm in Sources */ = {isa = PBXBuildFile; fileRef = C5237F5F12441CA300780472 /* WebEditorClientMac.mm */; };
 		C54256B518BEC18C00DE4179 /* WKFormInputControl.h in Headers */ = {isa = PBXBuildFile; fileRef = C54256AF18BEC18B00DE4179 /* WKFormInputControl.h */; };
 		C54256B618BEC18C00DE4179 /* WKFormInputControl.mm in Sources */ = {isa = PBXBuildFile; fileRef = C54256B018BEC18B00DE4179 /* WKFormInputControl.mm */; };
 		C54256B718BEC18C00DE4179 /* WKFormPeripheral.h in Headers */ = {isa = PBXBuildFile; fileRef = C54256B118BEC18B00DE4179 /* WKFormPeripheral.h */; };
 		C54256B818BEC18C00DE4179 /* WKFormPopover.h in Headers */ = {isa = PBXBuildFile; fileRef = C54256B218BEC18B00DE4179 /* WKFormPopover.h */; };
 		C54256B918BEC18C00DE4179 /* WKFormPopover.mm in Sources */ = {isa = PBXBuildFile; fileRef = C54256B318BEC18B00DE4179 /* WKFormPopover.mm */; };
 		C54256BA18BEC18C00DE4179 /* WKFormSelectControl.h in Headers */ = {isa = PBXBuildFile; fileRef = C54256B418BEC18C00DE4179 /* WKFormSelectControl.h */; };
 		C55CB5B718C269CF00CA81E1 /* WKFormSelectPopover.mm in Sources */ = {isa = PBXBuildFile; fileRef = C57193BA18C149D0002D0F12 /* WKFormSelectPopover.mm */; };
 		C55CB5B818C2A5D600CA81E1 /* WKFormSelectPicker.mm in Sources */ = {isa = PBXBuildFile; fileRef = C57193B918C149D0002D0F12 /* WKFormSelectPicker.mm */; };
@@ -3843,20 +3845,22 @@
 		C0CE73361247F70E00BC0EC4 /* generate-message-receiver.py */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.python; path = "generate-message-receiver.py"; sourceTree = "<group>"; };
 		C0CE73371247F70E00BC0EC4 /* generate-messages-header.py */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.python; path = "generate-messages-header.py"; sourceTree = "<group>"; };
 		C0E3AA441209E2BA00A49D01 /* Module.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Module.h; sourceTree = "<group>"; };
 		C0E3AA451209E2BA00A49D01 /* Module.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Module.cpp; sourceTree = "<group>"; };
 		C0E3AA481209E45000A49D01 /* ModuleCF.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ModuleCF.cpp; sourceTree = "<group>"; };
 		C49474AD19A3F924009B3DE8 /* WebReplayClient.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WebReplayClient.cpp; sourceTree = "<group>"; };
 		C49474AE19A3F924009B3DE8 /* WebReplayClient.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WebReplayClient.h; sourceTree = "<group>"; };
 		C49474B319A41246009B3DE8 /* WKInputs.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = WKInputs.json; sourceTree = "<group>"; };
 		C49474B519A41B73009B3DE8 /* WKReplayInputs.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WKReplayInputs.cpp; sourceTree = "<group>"; };
 		C49474B619A41B73009B3DE8 /* WKReplayInputs.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WKReplayInputs.h; sourceTree = "<group>"; };
+		C49474B919A5413F009B3DE8 /* WKReplayInputCoders.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WKReplayInputCoders.cpp; sourceTree = "<group>"; };
+		C49474BA19A5413F009B3DE8 /* WKReplayInputCoders.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WKReplayInputCoders.h; sourceTree = "<group>"; };
 		C517388012DF8F4F00EE3F47 /* DragControllerAction.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DragControllerAction.h; sourceTree = "<group>"; };
 		C5237F5F12441CA300780472 /* WebEditorClientMac.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; path = WebEditorClientMac.mm; sourceTree = "<group>"; };
 		C54256AF18BEC18B00DE4179 /* WKFormInputControl.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WKFormInputControl.h; path = ios/forms/WKFormInputControl.h; sourceTree = "<group>"; };
 		C54256B018BEC18B00DE4179 /* WKFormInputControl.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; name = WKFormInputControl.mm; path = ios/forms/WKFormInputControl.mm; sourceTree = "<group>"; };
 		C54256B118BEC18B00DE4179 /* WKFormPeripheral.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WKFormPeripheral.h; path = ios/forms/WKFormPeripheral.h; sourceTree = "<group>"; };
 		C54256B218BEC18B00DE4179 /* WKFormPopover.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WKFormPopover.h; path = ios/forms/WKFormPopover.h; sourceTree = "<group>"; };
 		C54256B318BEC18B00DE4179 /* WKFormPopover.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; name = WKFormPopover.mm; path = ios/forms/WKFormPopover.mm; sourceTree = "<group>"; };
 		C54256B418BEC18C00DE4179 /* WKFormSelectControl.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WKFormSelectControl.h; path = ios/forms/WKFormSelectControl.h; sourceTree = "<group>"; };
 		C554FFA212E4E8EA002F22C0 /* WebDragClientMac.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; path = WebDragClientMac.mm; sourceTree = "<group>"; };
 		C57193B918C149D0002D0F12 /* WKFormSelectPicker.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; name = WKFormSelectPicker.mm; path = ios/forms/WKFormSelectPicker.mm; sourceTree = "<group>"; };
@@ -7273,20 +7277,22 @@
 			);
 			path = Scripts;
 			sourceTree = "<group>";
 			tabWidth = 8;
 			usesTabs = 0;
 		};
 		C49474B219A4121A009B3DE8 /* Replay */ = {
 			isa = PBXGroup;
 			children = (
 				C49474B319A41246009B3DE8 /* WKInputs.json */,
+				C49474B919A5413F009B3DE8 /* WKReplayInputCoders.cpp */,
+				C49474BA19A5413F009B3DE8 /* WKReplayInputCoders.h */,
 			);
 			path = Replay;
 			sourceTree = "<group>";
 		};
 		C54256AE18BEC16100DE4179 /* forms */ = {
 			isa = PBXGroup;
 			children = (
 				C5FA1ED118E1062200B3F402 /* WKAirPlayRoutePicker.h */,
 				C5FA1ED218E1062200B3F402 /* WKAirPlayRoutePicker.mm */,
 				A58B6F0618FCA733008CBA53 /* WKFileUploadPanel.h */,
@@ -8244,20 +8250,21 @@
 				512F58FC12A88A5400629530 /* WKProtectionSpace.h in Headers */,
 				2DF9EEEE1A786EAD00B6CFBE /* APINavigationResponse.h in Headers */,
 				518ACAEA12AEE6BB00B04B83 /* WKProtectionSpaceTypes.h in Headers */,
 				1AD01BCD1905D54900C9C45F /* WKReloadFrameErrorRecoveryAttempter.h in Headers */,
 				1A9E329B1822E1CC00F5D04C /* WKRemoteObject.h in Headers */,
 				1A9E329F1822FEDD00F5D04C /* WKRemoteObjectCoder.h in Headers */,
 				37948409150C4B9700E52CE9 /* WKRenderLayer.h in Headers */,
 				37608823150414F700FC82C7 /* WKRenderObject.h in Headers */,
 				7C89D2A01A678554003A5FDE /* WKUserContentControllerRef.h in Headers */,
 				C49474B819A41B73009B3DE8 /* WKReplayInputs.h in Headers */,
+				C49474BC19A5413F009B3DE8 /* WKReplayInputCoders.h in Headers */,
 				3336763B130C99DC006C9DE2 /* WKResourceCacheManager.h in Headers */,
 				BC8A501511765F5600757573 /* WKRetainPtr.h in Headers */,
 				1A7E377918E4A4FE003D0FFF /* WKScriptMessage.h in Headers */,
 				1A7E377518E4A33A003D0FFF /* WKScriptMessageHandler.h in Headers */,
 				7CC99A3618EF7CBC0048C8B4 /* WKScriptMessageInternal.h in Headers */,
 				0FCB4E5418BBE044000FCFC9 /* WKScrollView.h in Headers */,
 				F634445D12A885E9000612D8 /* WKSecurityOrigin.h in Headers */,
 				BC407604124FF0270068F20A /* WKSerializedScriptValue.h in Headers */,
 				F67DD7BA125E40D9007BDCB8 /* WKSerializedScriptValuePrivate.h in Headers */,
 				75A8D2D7187D303A00C39C9E /* WKSessionRef.h in Headers */,
@@ -9964,20 +9971,21 @@
 				BCBAACEC145225E30053F82F /* WKProcessGroup.mm in Sources */,
 				1A158419189044F50017616C /* WKProcessPool.mm in Sources */,
 				512F58FB12A88A5400629530 /* WKProtectionSpace.cpp in Sources */,
 				1AD01BCC1905D54900C9C45F /* WKReloadFrameErrorRecoveryAttempter.mm in Sources */,
 				7C89D2A61A6789EA003A5FDE /* APIUserScript.cpp in Sources */,
 				1A9E329A1822E1CC00F5D04C /* WKRemoteObject.mm in Sources */,
 				1AFA4B8B1A65A1D0006C4AB4 /* WebProcessLifetimeTracker.cpp in Sources */,
 				1A9E329E1822FEDD00F5D04C /* WKRemoteObjectCoder.mm in Sources */,
 				37948408150C4B9700E52CE9 /* WKRenderLayer.cpp in Sources */,
 				37608822150414F700FC82C7 /* WKRenderObject.cpp in Sources */,
+				C49474BB19A5413F009B3DE8 /* WKReplayInputCoders.cpp in Sources */,
 				C49474B719A41B73009B3DE8 /* WKReplayInputs.cpp in Sources */,
 				3336763A130C99DC006C9DE2 /* WKResourceCacheManager.cpp in Sources */,
 				1A7E377818E4A4FE003D0FFF /* WKScriptMessage.mm in Sources */,
 				0FCB4E5518BBE044000FCFC9 /* WKScrollView.mm in Sources */,
 				F634445C12A885E9000612D8 /* WKSecurityOrigin.cpp in Sources */,
 				BC407603124FF0270068F20A /* WKSerializedScriptValue.cpp in Sources */,
 				75A8D2D8187D304000C39C9E /* WKSessionRef.cpp in Sources */,
 				1ADE46B21954EC61000F7985 /* WKSessionStateRef.cpp in Sources */,
 				BC407605124FF0270068F20A /* WKString.cpp in Sources */,
 				BC407619124FF0370068F20A /* WKStringCF.mm in Sources */,
diff --git a/Source/WebKit2/WebProcess/Replay/WKInputs.json b/Source/WebKit2/WebProcess/Replay/WKInputs.json
index 8951d77..e8b9e75 100644
--- a/Source/WebKit2/WebProcess/Replay/WKInputs.json
+++ b/Source/WebKit2/WebProcess/Replay/WKInputs.json
@@ -1,15 +1,15 @@
 {
     "inputs": {
         "WebKit": [
             {
-                "name": "HandleMouseMove",
+                "name": "HandleMouseMoveDummy",
                 "description": "The embedder signalled a mouse move event.",
-                "queue": "EVENT_LOOP",
+                "queue": "SCRIPT_MEMOIZED",
                 "members": [
                     { "name": "platformEvent", "type": "PlatformMouseEvent" },
                     { "name": "scrollbarTargeted", "type": "bool" }
                 ]
             }
         ]
     }
 }
diff --git a/Source/WebKit2/WebProcess/Replay/WKReplayInputCoders.cpp b/Source/WebKit2/WebProcess/Replay/WKReplayInputCoders.cpp
new file mode 100644
index 0000000..61eb907
--- /dev/null
+++ b/Source/WebKit2/WebProcess/Replay/WKReplayInputCoders.cpp
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2012, 2014 University of Washington. All rights reserved.
+ * Copyright (C) 2014 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "WKReplayInputCoders.h"
+
+#if ENABLE(WEB_REPLAY)
+
+#include "WKReplayInputs.h"
+#include <JavaScriptCore/JSReplayInputs.h>
+#include <WebCore/MemoizedDOMResult.h>
+#include <WebCore/WebReplayInputs.h>
+
+#define IMPORT_FROM_JSC_NAMESPACE(name) \
+using JSC::name; \
+
+JS_REPLAY_INPUT_NAMES_FOR_EACH(IMPORT_FROM_JSC_NAMESPACE)
+#undef IMPORT_FROM_JSC_NAMESPACE
+
+#define IMPORT_FROM_WEBCORE_NAMESPACE(name) \
+using WebCore::name; \
+
+WEB_REPLAY_INPUT_NAMES_FOR_EACH(IMPORT_FROM_WEBCORE_NAMESPACE)
+#undef IMPORT_FROM_WEBCORE_NAMESPACE
+
+#define IMPORT_FROM_WEBKIT_NAMESPACE(name) \
+using WebKit::name; \
+
+WK_REPLAY_INPUT_NAMES_FOR_EACH(IMPORT_FROM_WEBKIT_NAMESPACE)
+#undef IMPORT_FROM_WEBKIT_NAMESPACE
+
+// FIXME: This is copied verbatim from WebReplayInputCoders.cpp
+#define ENCODE_TYPE_WITH_KEY(_encodedValue, _type, _key, _value) \
+_encodedValue.put<_type>(ASCIILiteral(#_key), _value)
+
+#define DECODE_TYPE_WITH_KEY_TO_LVALUE(_encodedValue, _type, _key, _lvalue) \
+    if (!_encodedValue.get<_type>(ASCIILiteral(#_key), _lvalue)) \
+        return false
+
+#define DECODE_TYPE_WITH_KEY(_encodedValue, _type, _key) \
+    EncodingTraits<_type>::DecodedType _key; \
+    DECODE_TYPE_WITH_KEY_TO_LVALUE(_encodedValue, _type, _key, _key)
+
+using WebCore::MemoizedDOMResultBase;
+
+namespace JSC {
+
+EncodedValue EncodingTraits<NondeterministicInputBase>::encodeValue(const NondeterministicInputBase& input)
+{
+    EncodedValue encodedValue = EncodedValue::createObject();
+    ENCODE_TYPE_WITH_KEY(encodedValue, String, type, input.type());
+
+#define ENCODE_IF_TYPE_TAG_MATCHES(name) \
+    if (is<name>(input)) { \
+        InputTraits<name>::encode(encodedValue, downcast<name>(input)); \
+        return encodedValue; \
+    } \
+
+    JS_REPLAY_INPUT_NAMES_FOR_EACH(ENCODE_IF_TYPE_TAG_MATCHES)
+    WEB_REPLAY_INPUT_NAMES_FOR_EACH(ENCODE_IF_TYPE_TAG_MATCHES)
+#undef ENCODE_IF_TYPE_TAG_MATCHES
+
+    // The macro won't work here because of the class template argument.
+    if (is<MemoizedDOMResultBase>(input)) {
+        InputTraits<MemoizedDOMResultBase>::encode(encodedValue, downcast<MemoizedDOMResultBase>(input));
+        return encodedValue;
+    }
+
+    ASSERT_NOT_REACHED();
+    return EncodedValue();
+}
+
+bool EncodingTraits<NondeterministicInputBase>::decodeValue(EncodedValue& encodedValue, std::unique_ptr<NondeterministicInputBase>& input)
+{
+    DECODE_TYPE_WITH_KEY(encodedValue, String, type);
+
+#define DECODE_IF_TYPE_TAG_MATCHES(name) \
+    if (type == InputTraits<name>::type()) { \
+        std::unique_ptr<name> decodedInput; \
+        if (!InputTraits<name>::decode(encodedValue, decodedInput)) \
+            return false; \
+        \
+        input = WTF::move(decodedInput); \
+        return true; \
+    } \
+
+    JS_REPLAY_INPUT_NAMES_FOR_EACH(DECODE_IF_TYPE_TAG_MATCHES)
+    WEB_REPLAY_INPUT_NAMES_FOR_EACH(DECODE_IF_TYPE_TAG_MATCHES)
+    WK_REPLAY_INPUT_NAMES_FOR_EACH(DECODE_IF_TYPE_TAG_MATCHES)
+#undef DECODE_IF_TYPE_TAG_MATCHES
+
+    // The macro won't work here because of the class template argument.
+    if (type == InputTraits<MemoizedDOMResultBase>::type()) {
+        std::unique_ptr<MemoizedDOMResultBase> decodedInput;
+        if (!InputTraits<MemoizedDOMResultBase>::decode(encodedValue, decodedInput))
+            return false;
+
+        input = WTF::move(decodedInput);
+        return true;
+    }
+
+    return false;
+}
+
+} // namespace JSC
+
+#endif // ENABLE(WEB_REPLAY)
diff --git a/Source/WebKit2/WebProcess/Replay/WKReplayInputCoders.h b/Source/WebKit2/WebProcess/Replay/WKReplayInputCoders.h
new file mode 100644
index 0000000..e12f187
--- /dev/null
+++ b/Source/WebKit2/WebProcess/Replay/WKReplayInputCoders.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013, 2014 University of Washington. All rights reserved.
+ * Copyright (C) 2014 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef WKReplayInputCoders_h
+#define WKReplayInputCoders_h
+
+#if ENABLE(WEB_REPLAY)
+
+#include <JavaScriptCore/EncodedValue.h>
+#include <JavaScriptCore/NondeterministicInput.h>
+
+// Template specializations must be defined in the same namespace as the template declaration.
+namespace JSC {
+
+template<> struct EncodingTraits<JSC::NondeterministicInputBase> {
+    typedef JSC::NondeterministicInputBase DecodedType;
+
+    static EncodedValue encodeValue(const JSC::NondeterministicInputBase& input);
+    static bool decodeValue(EncodedValue&, std::unique_ptr<JSC::NondeterministicInputBase>& input);
+};
+
+} // namespace JSC
+
+#endif // ENABLE(WEB_REPLAY)
+
+#endif // WKReplayInputCoders_h
diff --git a/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.cpp b/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.cpp
index 87c6a2b..f5b7652 100644
--- a/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.cpp
+++ b/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.cpp
@@ -21,24 +21,36 @@
  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "WebReplayClient.h"
 
 #if ENABLE(WEB_REPLAY)
 
+#include "WKReplayInputCoders.h"
 #include "WebPage.h"
 #include <WebCore/EventLoopInput.h>
 #include <WebCore/ReplayController.h>
 
 namespace WebKit {
 
 void WebReplayClient::dispatchInput(WebCore::EventLoopInputBase& input)
 {
     input.dispatch(*m_page->corePage());
 }
 
+bool WebReplayClient::encodeInput(const NondeterministicInputBase& input, EncodedValue& encodedInput)
+{
+    encodedInput = EncodingTraits<NondeterministicInputBase>::encodeValue(input);
+    return true;
+}
+
+bool WebReplayClient::decodeInput(EncodedValue& encodedInput, std::unique_ptr<NondeterministicInputBase>& decodedInput)
+{
+    return EncodingTraits<NondeterministicInputBase>::decodeValue(encodedInput, decodedInput);
+}
+
 } // namespace WebKit
 
 #endif // ENABLE(WEB_REPLAY)
diff --git a/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.h b/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.h
index cee44c3..f6928e1 100644
--- a/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.h
+++ b/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.h
@@ -37,18 +37,21 @@ class WebPage;
 class WebReplayClient : public WebCore::ReplayClient {
 public:
     WebReplayClient(WebPage* page)
         : m_page(page)
     {
     }
 
 private:
     virtual void dispatchInput(WebCore::EventLoopInputBase&) override;
 
+    virtual bool encodeInput(const JSC::NondeterministicInputBase&, JSC::EncodedValue&) override;
+    virtual bool decodeInput(JSC::EncodedValue&, std::unique_ptr<JSC::NondeterministicInputBase>&) override;
+
     WebPage* m_page;
 };
 
 } // namespace WebKit
 
 #endif // ENABLE(WEB_REPLAY)
 
 #endif // WebReplayClient_h
-- 
2.3.5

