From fcce0d38e4c4792aedfd1c069cb496babc2936d7 Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Mon, 18 Aug 2014 18:50:22 -0700
Subject: [PATCH] Web Replay: EventSender dispatches should be deterministic
 and per-Document https://bugs.webkit.org/show_bug.cgi?id=136051

EventSender uses a Timer to asynchronously dispatch the same event to multiple
elements of the same type on a future run loop. This is nondeterministic because
static instances are shared between all Documents in the same process.

This patch shares EventSender instances among elements in the same Document.
The event dispatching is made deterministic by using a ReplayableTimer.

Normal (non-replay) functionality is covered by existing tests.

* WebCore.xcodeproj/project.pbxproj:
* dom/Document.cpp:
(WebCore::Document::Document):
(WebCore::Document::implicitClose): Dispatch pending events for this document only.
* dom/Document.h:
(WebCore::Document::sharedEventSenders):
* dom/EventSender.h: Keep a Document reference around for firing the timer.
(WebCore::EventSender::EventSender):
(WebCore::EventSender::hasPendingEvents):
(WebCore::EventSender::timerFired):
(WebCore::EventSender<T>::dispatchEventSoon):
(WebCore::EventSender<T>::cancelEvent):
(WebCore::EventSender<T>::dispatchPendingEvents):
(WebCore::EventSender<T>::EventSender): Deleted. The type argument was not necessary.

* dom/SharedEventSenders.cpp: Added. Lazily creates event senders as they are requested.
(WebCore::SharedEventSenders::linkLoadEventSender):
(WebCore::SharedEventSenders::styleLoadEventSender):
(WebCore::SharedEventSenders::imageBeforeloadEventSender):
(WebCore::SharedEventSenders::imageLoadEventSender):
(WebCore::SharedEventSenders::imageErrorEventSender):
* dom/SharedEventSenders.h: Added.
(WebCore::SharedEventSenders::SharedEventSenders):
* html/HTMLLinkElement.cpp:
(WebCore::HTMLLinkElement::linkLoadEventSender):
(WebCore::HTMLLinkElement::dispatchPendingEvent):
(WebCore::linkLoadEventSender): Deleted.
(WebCore::HTMLLinkElement::dispatchPendingLoadEvents): Deleted.
* html/HTMLLinkElement.h:
* html/HTMLStyleElement.cpp:
(WebCore::HTMLStyleElement::styleLoadEventSender):
(WebCore::HTMLStyleElement::dispatchPendingEvent):
(WebCore::styleLoadEventSender): Deleted.
(WebCore::HTMLStyleElement::dispatchPendingLoadEvents): Deleted.
* html/HTMLStyleElement.h:
* loader/ImageLoader.cpp:
(WebCore::ImageLoader::beforeLoadEventSender):
(WebCore::ImageLoader::loadEventSender):
(WebCore::ImageLoader::errorEventSender):
(WebCore::ImageLoader::dispatchPendingEvent):
(WebCore::beforeLoadEventSender): Deleted.
(WebCore::loadEventSender): Deleted.
(WebCore::errorEventSender): Deleted.
(WebCore::ImageLoader::dispatchPendingBeforeLoadEvents): Deleted.
(WebCore::ImageLoader::dispatchPendingLoadEvents): Deleted.
(WebCore::ImageLoader::dispatchPendingErrorEvents): Deleted.
* loader/ImageLoader.h:

* xml/parser/XMLDocumentParser.cpp:
(WebCore::XMLDocumentParser::append): Remove an early call to the EventSender for image beforeload
events. This was a performance optimization, but is no longer safe since the document (and thus
the event sender) may not be available in a synchronous document write.
---
 Source/WebCore/ChangeLog                         | 67 +++++++++++++++++++++
 Source/WebCore/WebCore.xcodeproj/project.pbxproj | 10 ++++
 Source/WebCore/dom/Document.cpp                  | 12 ++--
 Source/WebCore/dom/Document.h                    |  5 ++
 Source/WebCore/dom/EventSender.h                 | 63 +++++++++++---------
 Source/WebCore/dom/SharedEventSenders.cpp        | 75 ++++++++++++++++++++++++
 Source/WebCore/dom/SharedEventSenders.h          | 62 ++++++++++++++++++++
 Source/WebCore/html/HTMLLinkElement.cpp          | 15 ++---
 Source/WebCore/html/HTMLLinkElement.h            |  4 +-
 Source/WebCore/html/HTMLStyleElement.cpp         | 15 ++---
 Source/WebCore/html/HTMLStyleElement.h           |  5 +-
 Source/WebCore/loader/ImageLoader.cpp            | 37 ++++--------
 Source/WebCore/loader/ImageLoader.h              |  8 +--
 Source/WebCore/xml/parser/XMLDocumentParser.cpp  |  4 +-
 14 files changed, 292 insertions(+), 90 deletions(-)
 create mode 100644 Source/WebCore/dom/SharedEventSenders.cpp
 create mode 100644 Source/WebCore/dom/SharedEventSenders.h

diff --git a/Source/WebCore/ChangeLog b/Source/WebCore/ChangeLog
index 6b24220..fa3d637 100644
--- a/Source/WebCore/ChangeLog
+++ b/Source/WebCore/ChangeLog
@@ -1,10 +1,77 @@
+2014-08-18  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Replay: EventSender dispatches should be deterministic and per-Document
+        https://bugs.webkit.org/show_bug.cgi?id=136051
+
+        EventSender uses a Timer to asynchronously dispatch the same event to multiple
+        elements of the same type on a future run loop. This is nondeterministic because
+        static instances are shared between all Documents in the same process.
+
+        This patch shares EventSender instances among elements in the same Document.
+        The event dispatching is made deterministic by using a ReplayableTimer.
+
+        Normal (non-replay) functionality is covered by existing tests.
+
+        * WebCore.xcodeproj/project.pbxproj:
+        * dom/Document.cpp:
+        (WebCore::Document::Document):
+        (WebCore::Document::implicitClose): Dispatch pending events for this document only.
+        * dom/Document.h:
+        (WebCore::Document::sharedEventSenders):
+        * dom/EventSender.h: Keep a Document reference around for firing the timer.
+        (WebCore::EventSender::EventSender):
+        (WebCore::EventSender::hasPendingEvents):
+        (WebCore::EventSender::timerFired):
+        (WebCore::EventSender<T>::dispatchEventSoon):
+        (WebCore::EventSender<T>::cancelEvent):
+        (WebCore::EventSender<T>::dispatchPendingEvents):
+        (WebCore::EventSender<T>::EventSender): Deleted. The type argument was not necessary.
+
+        * dom/SharedEventSenders.cpp: Added. Lazily creates event senders as they are requested.
+        (WebCore::SharedEventSenders::linkLoadEventSender):
+        (WebCore::SharedEventSenders::styleLoadEventSender):
+        (WebCore::SharedEventSenders::imageBeforeloadEventSender):
+        (WebCore::SharedEventSenders::imageLoadEventSender):
+        (WebCore::SharedEventSenders::imageErrorEventSender):
+        * dom/SharedEventSenders.h: Added.
+        (WebCore::SharedEventSenders::SharedEventSenders):
+        * html/HTMLLinkElement.cpp:
+        (WebCore::HTMLLinkElement::linkLoadEventSender):
+        (WebCore::HTMLLinkElement::dispatchPendingEvent):
+        (WebCore::linkLoadEventSender): Deleted.
+        (WebCore::HTMLLinkElement::dispatchPendingLoadEvents): Deleted.
+        * html/HTMLLinkElement.h:
+        * html/HTMLStyleElement.cpp:
+        (WebCore::HTMLStyleElement::styleLoadEventSender):
+        (WebCore::HTMLStyleElement::dispatchPendingEvent):
+        (WebCore::styleLoadEventSender): Deleted.
+        (WebCore::HTMLStyleElement::dispatchPendingLoadEvents): Deleted.
+        * html/HTMLStyleElement.h:
+        * loader/ImageLoader.cpp:
+        (WebCore::ImageLoader::beforeLoadEventSender):
+        (WebCore::ImageLoader::loadEventSender):
+        (WebCore::ImageLoader::errorEventSender):
+        (WebCore::ImageLoader::dispatchPendingEvent):
+        (WebCore::beforeLoadEventSender): Deleted.
+        (WebCore::loadEventSender): Deleted.
+        (WebCore::errorEventSender): Deleted.
+        (WebCore::ImageLoader::dispatchPendingBeforeLoadEvents): Deleted.
+        (WebCore::ImageLoader::dispatchPendingLoadEvents): Deleted.
+        (WebCore::ImageLoader::dispatchPendingErrorEvents): Deleted.
+        * loader/ImageLoader.h:
+
+        * xml/parser/XMLDocumentParser.cpp:
+        (WebCore::XMLDocumentParser::append): Remove an early call to the EventSender for image beforeload
+        events. This was a performance optimization, but is no longer safe since the document (and thus
+        the event sender) may not be available in a synchronous document write.
+
 2014-07-15  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Replay: make calls into FrameLoader::checkLoadComplete() deterministic
         https://bugs.webkit.org/show_bug.cgi?id=129451
 
         Reviewed by NOBODY (OOPS!).
 
         To ensure deterministic JavaScript execution, calls to checkLoadComplete()
         that originate from asynchronous Timer firings should be captured and replayed.
 
diff --git a/Source/WebCore/WebCore.xcodeproj/project.pbxproj b/Source/WebCore/WebCore.xcodeproj/project.pbxproj
index 891d99d..7330d9e 100644
--- a/Source/WebCore/WebCore.xcodeproj/project.pbxproj
+++ b/Source/WebCore/WebCore.xcodeproj/project.pbxproj
@@ -5528,20 +5528,23 @@
 		C348612315FDE21E007A1CC9 /* InputTypeNames.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C348612115FDE21E007A1CC9 /* InputTypeNames.cpp */; };
 		C348612415FDE21E007A1CC9 /* InputTypeNames.h in Headers */ = {isa = PBXBuildFile; fileRef = C348612215FDE21E007A1CC9 /* InputTypeNames.h */; };
 		C375D7FD16639519006184AB /* TypeAhead.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C375D7FB16639519006184AB /* TypeAhead.cpp */; };
 		C375D7FE16639519006184AB /* TypeAhead.h in Headers */ = {isa = PBXBuildFile; fileRef = C375D7FC16639519006184AB /* TypeAhead.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C37CDEBD149EF2030042090D /* ColorChooserClient.h in Headers */ = {isa = PBXBuildFile; fileRef = C37CDEBC149EF2030042090D /* ColorChooserClient.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C3CF17A415B0063F00276D39 /* IdTargetObserver.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C3CF17A015B0063F00276D39 /* IdTargetObserver.cpp */; };
 		C3CF17A515B0063F00276D39 /* IdTargetObserver.h in Headers */ = {isa = PBXBuildFile; fileRef = C3CF17A115B0063F00276D39 /* IdTargetObserver.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C3CF17A615B0063F00276D39 /* IdTargetObserverRegistry.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C3CF17A215B0063F00276D39 /* IdTargetObserverRegistry.cpp */; };
 		C3CF17A715B0063F00276D39 /* IdTargetObserverRegistry.h in Headers */ = {isa = PBXBuildFile; fileRef = C3CF17A315B0063F00276D39 /* IdTargetObserverRegistry.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C400D10918F1C8F60090D863 /* EventLoopInput.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C400D10818F1C8F60090D863 /* EventLoopInput.cpp */; };
+		C49474A119A2847C009B3DE8 /* SharedEventSenders.h in Headers */ = {isa = PBXBuildFile; fileRef = C49474A019A2847C009B3DE8 /* SharedEventSenders.h */; };
+		C49474A819A2D612009B3DE8 /* EventSender.h in Headers */ = {isa = PBXBuildFile; fileRef = CE5CB1B314EDAB6F00BB2795 /* EventSender.h */; };
+		C49474AA19A2E2E5009B3DE8 /* SharedEventSenders.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C49474A919A2E2E5009B3DE8 /* SharedEventSenders.cpp */; };
 		C4CD629A18383766007EBAF1 /* FrameSnapshotting.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4CD629818383766007EBAF1 /* FrameSnapshotting.cpp */; };
 		C4CD629B18383766007EBAF1 /* FrameSnapshotting.h in Headers */ = {isa = PBXBuildFile; fileRef = C4CD629918383766007EBAF1 /* FrameSnapshotting.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C4D4F52B1975C88B003EF5BC /* ReplayableTimer.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4D4F5271975C88B003EF5BC /* ReplayableTimer.cpp */; };
 		C4D4F52C1975C88B003EF5BC /* ReplayableTimer.h in Headers */ = {isa = PBXBuildFile; fileRef = C4D4F5281975C88B003EF5BC /* ReplayableTimer.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C4D4F52D1975C88B003EF5BC /* ReplayableTimers.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4D4F5291975C88B003EF5BC /* ReplayableTimers.cpp */; };
 		C4D4F52E1975C88B003EF5BC /* ReplayableTimers.h in Headers */ = {isa = PBXBuildFile; fileRef = C4D4F52A1975C88B003EF5BC /* ReplayableTimers.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C50B561612119D23008B46E0 /* GroupSettings.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C50B561412119D23008B46E0 /* GroupSettings.cpp */; };
 		C50B561712119D23008B46E0 /* GroupSettings.h in Headers */ = {isa = PBXBuildFile; fileRef = C50B561512119D23008B46E0 /* GroupSettings.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C50D0E820FF4272900AC2644 /* StorageNamespace.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C50D0E800FF4272900AC2644 /* StorageNamespace.cpp */; };
 		C50D0E830FF4272900AC2644 /* StorageNamespace.h in Headers */ = {isa = PBXBuildFile; fileRef = C50D0E810FF4272900AC2644 /* StorageNamespace.h */; settings = {ATTRIBUTES = (Private, ); }; };
@@ -12956,20 +12959,22 @@
 		C348612215FDE21E007A1CC9 /* InputTypeNames.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InputTypeNames.h; sourceTree = "<group>"; };
 		C375D7FB16639519006184AB /* TypeAhead.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = TypeAhead.cpp; sourceTree = "<group>"; };
 		C375D7FC16639519006184AB /* TypeAhead.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TypeAhead.h; sourceTree = "<group>"; };
 		C37CDEBC149EF2030042090D /* ColorChooserClient.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ColorChooserClient.h; sourceTree = "<group>"; };
 		C3CF17A015B0063F00276D39 /* IdTargetObserver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = IdTargetObserver.cpp; sourceTree = "<group>"; };
 		C3CF17A115B0063F00276D39 /* IdTargetObserver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = IdTargetObserver.h; sourceTree = "<group>"; };
 		C3CF17A215B0063F00276D39 /* IdTargetObserverRegistry.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = IdTargetObserverRegistry.cpp; sourceTree = "<group>"; };
 		C3CF17A315B0063F00276D39 /* IdTargetObserverRegistry.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = IdTargetObserverRegistry.h; sourceTree = "<group>"; };
 		C3E61C653A64807A83E76FB8 /* MathMLMencloseElement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MathMLMencloseElement.cpp; sourceTree = "<group>"; };
 		C400D10818F1C8F60090D863 /* EventLoopInput.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = EventLoopInput.cpp; sourceTree = "<group>"; };
+		C49474A019A2847C009B3DE8 /* SharedEventSenders.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SharedEventSenders.h; sourceTree = "<group>"; };
+		C49474A919A2E2E5009B3DE8 /* SharedEventSenders.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SharedEventSenders.cpp; sourceTree = "<group>"; };
 		C4CD629818383766007EBAF1 /* FrameSnapshotting.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FrameSnapshotting.cpp; sourceTree = "<group>"; };
 		C4CD629918383766007EBAF1 /* FrameSnapshotting.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FrameSnapshotting.h; sourceTree = "<group>"; };
 		C4D4F5271975C88B003EF5BC /* ReplayableTimer.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ReplayableTimer.cpp; sourceTree = "<group>"; };
 		C4D4F5281975C88B003EF5BC /* ReplayableTimer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ReplayableTimer.h; sourceTree = "<group>"; };
 		C4D4F5291975C88B003EF5BC /* ReplayableTimers.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ReplayableTimers.cpp; sourceTree = "<group>"; };
 		C4D4F52A1975C88B003EF5BC /* ReplayableTimers.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ReplayableTimers.h; sourceTree = "<group>"; };
 		C50B561412119D23008B46E0 /* GroupSettings.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GroupSettings.cpp; sourceTree = "<group>"; };
 		C50B561512119D23008B46E0 /* GroupSettings.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GroupSettings.h; sourceTree = "<group>"; };
 		C50D0E800FF4272900AC2644 /* StorageNamespace.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = StorageNamespace.cpp; sourceTree = "<group>"; };
 		C50D0E810FF4272900AC2644 /* StorageNamespace.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StorageNamespace.h; sourceTree = "<group>"; };
@@ -22843,20 +22848,22 @@
 				8A413ADF1207BBA50082016E /* ScriptRunner.cpp */,
 				8A413ADE1207BBA50082016E /* ScriptRunner.h */,
 				976F36E814686225005E93B4 /* SecurityContext.cpp */,
 				976F36E914686225005E93B4 /* SecurityContext.h */,
 				2D5BC42516F882BE007048D0 /* SecurityPolicyViolationEvent.h */,
 				2D5BC42616F882BE007048D0 /* SecurityPolicyViolationEvent.idl */,
 				E45322A9140CE267005A0F92 /* SelectorQuery.cpp */,
 				E45322AA140CE267005A0F92 /* SelectorQuery.h */,
 				A6D169611346B49B000EB770 /* ShadowRoot.cpp */,
 				A6D169631346B4C1000EB770 /* ShadowRoot.h */,
+				C49474A919A2E2E5009B3DE8 /* SharedEventSenders.cpp */,
+				C49474A019A2847C009B3DE8 /* SharedEventSenders.h */,
 				31741AAB16635E45008A5B7E /* SimulatedClickOptions.h */,
 				D01A27AB10C9BFD800026A42 /* SpaceSplitString.cpp */,
 				D01A27AC10C9BFD800026A42 /* SpaceSplitString.h */,
 				BC7FA62C0D1F0EFF00DB22A9 /* StaticNodeList.cpp */,
 				BC7FA62B0D1F0EFF00DB22A9 /* StaticNodeList.h */,
 				8102C5871325BB1100DDE67A /* StringCallback.cpp */,
 				81AC6C35131C57D30009A7E0 /* StringCallback.h */,
 				81AC6C34131C57C20009A7E0 /* StringCallback.idl */,
 				A8C4A7EC09D563270003AC8D /* StyledElement.cpp */,
 				A8C4A7EB09D563270003AC8D /* StyledElement.h */,
@@ -23434,20 +23441,21 @@
 				7EE6846112D26E3800E79415 /* AuthenticationChallenge.h in Headers */,
 				934F713A0D5A6F1000018D69 /* AuthenticationChallengeBase.h in Headers */,
 				E124748410AA161D00B79493 /* AuthenticationClient.h in Headers */,
 				514C764C0CE9234E007EF3CD /* AuthenticationMac.h in Headers */,
 				A501920E132EBF2E008BFE55 /* Autocapitalize.h in Headers */,
 				45830D4E1679B4F800ACF8C3 /* AutoscrollController.h in Headers */,
 				A8CFF04E0A154F09000A4234 /* AutoTableLayout.h in Headers */,
 				070363E0181A1CDC00C074A5 /* AVAudioCaptureSource.h in Headers */,
 				070363E2181A1CDC00C074A5 /* AVCaptureDeviceManager.h in Headers */,
 				070363E4181A1CDC00C074A5 /* AVMediaCaptureSource.h in Headers */,
+				C49474A819A2D612009B3DE8 /* EventSender.h in Headers */,
 				CD336F6217F9F64700DDDCD0 /* AVTrackPrivateAVFObjCImpl.h in Headers */,
 				070363E6181A1CDC00C074A5 /* AVVideoCaptureSource.h in Headers */,
 				29A812380FBB9C1D00510293 /* AXObjectCache.h in Headers */,
 				51741D0F0B07259A00ED442C /* BackForwardClient.h in Headers */,
 				BCA8C81E11E3D36900812FB7 /* BackForwardController.h in Headers */,
 				077AF14318F4B1BB0001ED61 /* SerializedPlatformRepresentationMac.h in Headers */,
 				BCA8CA6011E4E6D100812FB7 /* BackForwardList.h in Headers */,
 				BC124EE80C2641CD009E2349 /* BarProp.h in Headers */,
 				379E61CA126CA5C400B63E8D /* BaseButtonInputType.h in Headers */,
 				379E61CC126CA5C400B63E8D /* BaseCheckableInputType.h in Headers */,
@@ -26479,20 +26487,21 @@
 				1419D2C50CEA6F6100FF507A /* TreeShared.h in Headers */,
 				854FE7390A2297BE0058D7AD /* TreeWalker.h in Headers */,
 				2D76BB821945632400CFD29A /* RunLoopObserver.h in Headers */,
 				C375D7FE16639519006184AB /* TypeAhead.h in Headers */,
 				37C28A6810F659CC008C7813 /* TypesettingFeatures.h in Headers */,
 				93309E1A099E64920056E581 /* TypingCommand.h in Headers */,
 				85031B4E0A44EFC700F992E0 /* UIEvent.h in Headers */,
 				85031B4F0A44EFC700F992E0 /* UIEventWithKeyState.h in Headers */,
 				AA4739D21757AFEC00E76767 /* UIRequestEvent.h in Headers */,
 				9B2D8A7914997CCF00ECEF3E /* UndoStep.h in Headers */,
+				C49474A119A2847C009B3DE8 /* SharedEventSenders.h in Headers */,
 				A863E2011343412000274926 /* UnicodeBidi.h in Headers */,
 				E4AFCFA50DAF29A300F5F55C /* UnitBezier.h in Headers */,
 				D086FE9809D53AAB005BC74D /* UnlinkCommand.h in Headers */,
 				FD1762E0176686D900D836A8 /* UpSampler.h in Headers */,
 				6593923809AE4346002C531F /* URL.h in Headers */,
 				BCBD21AB0E417AD400A070F2 /* URLHash.h in Headers */,
 				F55B3DDE1251F12D003EF269 /* URLInputType.h in Headers */,
 				A72763BF16689BFB002FCACB /* UserActionElementSet.h in Headers */,
 				868160D618766A130021E79D /* UserActivity.h in Headers */,
 				26255F0318878E110006E1FD /* UserAgent.h in Headers */,
@@ -28151,20 +28160,21 @@
 				BE6DF713171CA2DA00DD52B8 /* JSAudioTrackListCustom.cpp in Sources */,
 				BC124EFF0C26447A009E2349 /* JSBarProp.cpp in Sources */,
 				BC946346107A934B00857193 /* JSBeforeLoadEvent.cpp in Sources */,
 				70F546E8B8B5D7DC54EE144E /* JSBeforeUnloadEvent.cpp in Sources */,
 				FDF09DC81399B62200688E5B /* JSBiquadFilterNode.cpp in Sources */,
 				FD8AA63C1695148E00D2EA68 /* JSBiquadFilterNodeCustom.cpp in Sources */,
 				2E2D99CD10E2BBDA00496337 /* JSBlob.cpp in Sources */,
 				8931DE5B14C44C44000DC9D2 /* JSBlobCustom.cpp in Sources */,
 				1449E287107D4DB400B5793F /* JSCallbackData.cpp in Sources */,
 				65DF323909D1DE65000BE325 /* JSCanvasGradient.cpp in Sources */,
+				C49474AA19A2E2E5009B3DE8 /* SharedEventSenders.cpp in Sources */,
 				65DF323B09D1DE65000BE325 /* JSCanvasPattern.cpp in Sources */,
 				49EED1421051969400099FAB /* JSCanvasRenderingContext.cpp in Sources */,
 				49EED1441051969400099FAB /* JSCanvasRenderingContext2D.cpp in Sources */,
 				49EED14E1051971A00099FAB /* JSCanvasRenderingContext2DCustom.cpp in Sources */,
 				49EED1501051971A00099FAB /* JSCanvasRenderingContextCustom.cpp in Sources */,
 				073AB4B717F92ECF006E0D6F /* JSCapabilityRange.cpp in Sources */,
 				93F9B7A00BA6032600854064 /* JSCDATASection.cpp in Sources */,
 				93BA59B20F2AA5FE008E8E99 /* JSCDATASectionCustom.cpp in Sources */,
 				FDA15EA112B03EE1003A583A /* JSChannelMergerNode.cpp in Sources */,
 				FDA15EA312B03EE1003A583A /* JSChannelSplitterNode.cpp in Sources */,
diff --git a/Source/WebCore/dom/Document.cpp b/Source/WebCore/dom/Document.cpp
index aa30785..bcfc450 100644
--- a/Source/WebCore/dom/Document.cpp
+++ b/Source/WebCore/dom/Document.cpp
@@ -131,20 +131,21 @@
 #include "ScriptController.h"
 #include "ScriptRunner.h"
 #include "ScriptSourceCode.h"
 #include "ScrollingCoordinator.h"
 #include "SecurityOrigin.h"
 #include "SecurityPolicy.h"
 #include "SegmentedString.h"
 #include "SelectorQuery.h"
 #include "Settings.h"
 #include "ShadowRoot.h"
+#include "SharedEventSenders.h"
 #include "StyleProperties.h"
 #include "StyleResolver.h"
 #include "StyleSheetContents.h"
 #include "StyleSheetList.h"
 #include "TextResourceDecoder.h"
 #include "TransformSource.h"
 #include "TreeWalker.h"
 #include "VisitedLinkState.h"
 #include "XMLDocumentParser.h"
 #include "XMLNSNames.h"
@@ -464,20 +465,21 @@ Document::Document(Frame* frame, const URL& url, unsigned documentClasses, unsig
 #endif
     , m_createRenderers(true)
     , m_inPageCache(false)
     , m_accessKeyMapValid(false)
     , m_documentClasses(documentClasses)
     , m_isSynthesized(constructionFlags & Synthesized)
     , m_isNonRenderedPlaceholder(constructionFlags & NonRenderedPlaceholder)
     , m_sawElementsInKnownNamespaces(false)
     , m_isSrcdocDocument(false)
     , m_eventQueue(*this)
+    , m_sharedEventSenders(std::make_unique<SharedEventSenders>(*this))
     , m_weakFactory(this)
 #if ENABLE(FULLSCREEN_API)
     , m_areKeysEnabledInFullScreen(0)
     , m_fullScreenRenderer(nullptr)
     , m_fullScreenChangeDelayTimer(this, &Document::fullScreenChangeDelayTimerFired)
     , m_isAnimatingFullScreen(false)
 #endif
     , m_loadEventDelayCount(0)
     , m_loadEventDelayTimer(this, &Document::loadEventDelayTimerFired)
     , m_referrerPolicy(ReferrerPolicyDefault)
@@ -2377,26 +2379,26 @@ void Document::implicitClose()
     //  -When the <head> finishes parsing
     //  -When any new HTMLLinkElement is inserted into the document
     // But those add a dynamic component to the favicon that has UI 
     // ramifications, and we need to decide what is the Right Thing To Do(tm)
     Frame* f = frame();
     if (f) {
         f->loader().icon().startLoader();
         f->animation().startAnimationsIfNotSuspended(this);
     }
 
-    ImageLoader::dispatchPendingBeforeLoadEvents();
-    ImageLoader::dispatchPendingLoadEvents();
-    ImageLoader::dispatchPendingErrorEvents();
+    sharedEventSenders().imageBeforeloadEventSender().dispatchPendingEvents();
+    sharedEventSenders().imageLoadEventSender().dispatchPendingEvents();
+    sharedEventSenders().imageErrorEventSender().dispatchPendingEvents();
 
-    HTMLLinkElement::dispatchPendingLoadEvents();
-    HTMLStyleElement::dispatchPendingLoadEvents();
+    sharedEventSenders().linkLoadEventSender().dispatchPendingEvents();
+    sharedEventSenders().styleLoadEventSender().dispatchPendingEvents();
 
     // To align the HTML load event and the SVGLoad event for the outermost <svg> element, fire it from
     // here, instead of doing it from SVGElement::finishedParsingChildren (if externalResourcesRequired="false",
     // which is the default, for ='true' its fired at a later time, once all external resources finished loading).
     if (svgExtensions())
         accessSVGExtensions()->dispatchSVGLoadEventToOutermostSVGElements();
 
     dispatchWindowLoadEvent();
     enqueuePageshowEvent(PageshowEventNotPersisted);
     enqueuePopstateEvent(m_pendingStateObject ? m_pendingStateObject.release() : SerializedScriptValue::nullValue());
diff --git a/Source/WebCore/dom/Document.h b/Source/WebCore/dom/Document.h
index a666fd8..472086c 100644
--- a/Source/WebCore/dom/Document.h
+++ b/Source/WebCore/dom/Document.h
@@ -138,20 +138,21 @@ class RenderView;
 class RenderFullScreen;
 class ScriptableDocumentParser;
 class ScriptElementData;
 class ScriptRunner;
 class SecurityOrigin;
 class SelectorQuery;
 class SelectorQueryCache;
 class SerializedScriptValue;
 class SegmentedString;
 class Settings;
+class SharedEventSenders;
 class StyleResolver;
 class StyleSheet;
 class StyleSheetContents;
 class StyleSheetList;
 class SVGDocumentExtensions;
 class Text;
 class TextResourceDecoder;
 class TreeWalker;
 class VisitedLinkState;
 class WebKitNamedFlow;
@@ -1110,20 +1111,22 @@ public:
     void setContainsValidityStyleRules() { m_containsValidityStyleRules = true; }
 
     void enqueueWindowEvent(PassRefPtr<Event>);
     void enqueueDocumentEvent(PassRefPtr<Event>);
     void enqueueOverflowEvent(PassRefPtr<Event>);
     void enqueuePageshowEvent(PageshowEventPersistence);
     void enqueueHashchangeEvent(const String& oldURL, const String& newURL);
     void enqueuePopstateEvent(PassRefPtr<SerializedScriptValue> stateObject);
     virtual DocumentEventQueue& eventQueue() const override { return m_eventQueue; }
 
+    SharedEventSenders& sharedEventSenders() const { return *m_sharedEventSenders; }
+
     WEBCORE_EXPORT void addMediaCanStartListener(MediaCanStartListener*);
     WEBCORE_EXPORT void removeMediaCanStartListener(MediaCanStartListener*);
     MediaCanStartListener* takeAnyMediaCanStartListener();
 
 #if ENABLE(FULLSCREEN_API)
     bool webkitIsFullScreen() const { return m_fullScreenElement.get(); }
     bool webkitFullScreenKeyboardInputAllowed() const { return m_fullScreenElement.get() && m_areKeysEnabledInFullScreen; }
     Element* webkitCurrentFullScreenElement() const { return m_fullScreenElement.get(); }
     
     enum FullScreenCheckType {
@@ -1559,20 +1562,22 @@ private:
 
     bool m_isSynthesized;
     bool m_isNonRenderedPlaceholder;
 
     bool m_sawElementsInKnownNamespaces;
     bool m_isSrcdocDocument;
 
     RenderPtr<RenderView> m_renderView;
     mutable DocumentEventQueue m_eventQueue;
 
+    const std::unique_ptr<SharedEventSenders> m_sharedEventSenders;
+
     WeakPtrFactory<Document> m_weakFactory;
 
     HashSet<MediaCanStartListener*> m_mediaCanStartListeners;
 
 #if ENABLE(FULLSCREEN_API)
     bool m_areKeysEnabledInFullScreen;
     RefPtr<Element> m_fullScreenElement;
     Vector<RefPtr<Element>> m_fullScreenElementStack;
     RenderFullScreen* m_fullScreenRenderer;
     Timer<Document> m_fullScreenChangeDelayTimer;
diff --git a/Source/WebCore/dom/EventSender.h b/Source/WebCore/dom/EventSender.h
index 2cb5aaf..97a6a8b 100644
--- a/Source/WebCore/dom/EventSender.h
+++ b/Source/WebCore/dom/EventSender.h
@@ -1,12 +1,13 @@
 /*
  * Copyright (C) 2012 Apple Inc. All rights reserved.
+ * Copyright (C) 2014 University of Washington. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  *
@@ -19,96 +20,104 @@
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef EventSender_h
 #define EventSender_h
 
-#include "Timer.h"
+#include "ReplayableTimer.h"
 #include <wtf/Vector.h>
 
 namespace WebCore {
 
-template<typename T> class EventSender {
+class Document;
+
+template <typename T>
+class EventSender {
     WTF_MAKE_NONCOPYABLE(EventSender); WTF_MAKE_FAST_ALLOCATED;
 public:
-    explicit EventSender(const AtomicString& eventType);
+    EventSender(Document& document, const AtomicString& eventType)
+        : m_document(document)
+        , m_eventType(eventType)
+        , m_timer(this, &EventSender::timerFired)
+    {
+    }
 
     const AtomicString& eventType() const { return m_eventType; }
     void dispatchEventSoon(T*);
     void cancelEvent(T*);
     void dispatchPendingEvents();
 
 #ifndef NDEBUG
-    bool hasPendingEvents(T* sender) const
+    bool hasPendingEvents(T* client) const
     {
-        return m_dispatchSoonList.find(sender) != notFound || m_dispatchingList.find(sender) != notFound;
+        return m_dispatchSoonList.find(client) != notFound || m_dispatchingList.find(client) != notFound;
     }
 #endif
 
 private:
-    void timerFired(Timer<EventSender<T>>&) { dispatchPendingEvents(); }
+    void timerFired(ReplayableTimer<EventSender<T>>&) { dispatchPendingEvents(); }
 
+    Document& m_document;
     AtomicString m_eventType;
-    Timer<EventSender<T>> m_timer;
+    ReplayableTimer<EventSender<T>> m_timer;
     Vector<T*> m_dispatchSoonList;
     Vector<T*> m_dispatchingList;
 };
 
-template<typename T> EventSender<T>::EventSender(const AtomicString& eventType)
-    : m_eventType(eventType)
-    , m_timer(this, &EventSender::timerFired)
+template <typename T>
+void EventSender<T>::dispatchEventSoon(T* client)
 {
-}
+    ASSERT_ARG(client, client);
 
-template<typename T> void EventSender<T>::dispatchEventSoon(T* sender)
-{
-    m_dispatchSoonList.append(sender);
+    m_dispatchSoonList.append(client);
     if (!m_timer.isActive())
-        m_timer.startOneShot(0);
+        m_timer.startOneShot(0, &m_document);
 }
 
-template<typename T> void EventSender<T>::cancelEvent(T* sender)
+template<typename T>
+void EventSender<T>::cancelEvent(T* client)
 {
-    // Remove instances of this sender from both lists.
+    ASSERT_ARG(client, client);
+
+    // Remove instances of this client from both lists.
     // Use loops because we allow multiple instances to get into the lists.
     size_t size = m_dispatchSoonList.size();
     for (size_t i = 0; i < size; ++i) {
-        if (m_dispatchSoonList[i] == sender)
-            m_dispatchSoonList[i] = 0;
+        if (m_dispatchSoonList[i] == client)
+            m_dispatchSoonList[i] = nullptr;
     }
     size = m_dispatchingList.size();
     for (size_t i = 0; i < size; ++i) {
-        if (m_dispatchingList[i] == sender)
-            m_dispatchingList[i] = 0;
+        if (m_dispatchingList[i] == client)
+            m_dispatchingList[i] = nullptr;
     }
 }
 
-template<typename T> void EventSender<T>::dispatchPendingEvents()
+template<typename T>
+void EventSender<T>::dispatchPendingEvents()
 {
     // Need to avoid re-entering this function; if new dispatches are
     // scheduled before the parent finishes processing the list, they
     // will set a timer and eventually be processed.
     if (!m_dispatchingList.isEmpty())
         return;
 
     m_timer.stop();
 
-    m_dispatchSoonList.checkConsistency();
-
     m_dispatchingList.swap(m_dispatchSoonList);
     size_t size = m_dispatchingList.size();
     for (size_t i = 0; i < size; ++i) {
-        if (T* sender = m_dispatchingList[i]) {
-            m_dispatchingList[i] = 0;
-            sender->dispatchPendingEvent(this);
+        if (T* client = m_dispatchingList[i]) {
+            m_dispatchingList[i] = nullptr;
+            client->dispatchPendingEvent(*this);
         }
     }
     m_dispatchingList.clear();
 }
 
 } // namespace WebCore
 
 #endif // EventSender_h
diff --git a/Source/WebCore/dom/SharedEventSenders.cpp b/Source/WebCore/dom/SharedEventSenders.cpp
new file mode 100644
index 0000000..5c74901
--- /dev/null
+++ b/Source/WebCore/dom/SharedEventSenders.cpp
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2014 University of Washington. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "SharedEventSenders.h"
+
+#include "HTMLLinkElement.h"
+#include "HTMLStyleElement.h"
+#include "ImageLoader.h"
+
+namespace WebCore {
+
+EventSender<HTMLLinkElement>& SharedEventSenders::linkLoadEventSender()
+{
+    if (!m_linkLoadEventSender)
+        m_linkLoadEventSender = std::make_unique<EventSender<HTMLLinkElement>>(m_document, eventNames().loadEvent);
+
+    return *m_linkLoadEventSender;
+}
+
+EventSender<HTMLStyleElement>& SharedEventSenders::styleLoadEventSender()
+{
+    if (!m_styleLoadEventSender)
+        m_styleLoadEventSender = std::make_unique<EventSender<HTMLStyleElement>>(m_document, eventNames().loadEvent);
+
+    return *m_styleLoadEventSender;
+}
+
+EventSender<ImageLoader>& SharedEventSenders::imageBeforeloadEventSender()
+{
+    if (!m_imageBeforeloadEventSender)
+        m_imageBeforeloadEventSender = std::make_unique<EventSender<ImageLoader>>(m_document, eventNames().beforeloadEvent);
+
+    return *m_imageBeforeloadEventSender;
+}
+
+EventSender<ImageLoader>& SharedEventSenders::imageLoadEventSender()
+{
+    if (!m_imageLoadEventSender)
+        m_imageLoadEventSender = std::make_unique<EventSender<ImageLoader>>(m_document, eventNames().loadEvent);
+
+    return *m_imageLoadEventSender;
+}
+
+EventSender<ImageLoader>& SharedEventSenders::imageErrorEventSender()
+{
+    if (!m_imageErrorEventSender)
+        m_imageErrorEventSender = std::make_unique<EventSender<ImageLoader>>(m_document, eventNames().errorEvent);
+
+    return *m_imageErrorEventSender;
+}
+
+} // namespace WebCore
diff --git a/Source/WebCore/dom/SharedEventSenders.h b/Source/WebCore/dom/SharedEventSenders.h
new file mode 100644
index 0000000..c9d3a94
--- /dev/null
+++ b/Source/WebCore/dom/SharedEventSenders.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2014 University of Washington. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef SharedEventSenders_h
+#define SharedEventSenders_h
+
+#include "EventNames.h"
+#include "EventSender.h"
+
+namespace WebCore {
+
+class HTMLLinkElement;
+class HTMLStyleElement;
+class ImageLoader;
+
+class SharedEventSenders {
+    WTF_MAKE_NONCOPYABLE(SharedEventSenders); WTF_MAKE_FAST_ALLOCATED;
+public:
+    explicit SharedEventSenders(Document& document)
+        : m_document(document)
+    {
+    }
+
+    EventSender<HTMLLinkElement>& linkLoadEventSender();
+    EventSender<HTMLStyleElement>& styleLoadEventSender();
+    EventSender<ImageLoader>& imageBeforeloadEventSender();
+    EventSender<ImageLoader>& imageLoadEventSender();
+    EventSender<ImageLoader>& imageErrorEventSender();
+private:
+    Document& m_document;
+    std::unique_ptr<EventSender<HTMLLinkElement>> m_linkLoadEventSender;
+    std::unique_ptr<EventSender<HTMLStyleElement>> m_styleLoadEventSender;
+    std::unique_ptr<EventSender<ImageLoader>> m_imageBeforeloadEventSender;
+    std::unique_ptr<EventSender<ImageLoader>> m_imageLoadEventSender;
+    std::unique_ptr<EventSender<ImageLoader>> m_imageErrorEventSender;
+};
+
+} // namespace WebCore
+
+#endif // SharedEventSenders_h
diff --git a/Source/WebCore/html/HTMLLinkElement.cpp b/Source/WebCore/html/HTMLLinkElement.cpp
index b851145..2c3f119 100644
--- a/Source/WebCore/html/HTMLLinkElement.cpp
+++ b/Source/WebCore/html/HTMLLinkElement.cpp
@@ -40,34 +40,34 @@
 #include "FrameTree.h"
 #include "FrameView.h"
 #include "HTMLNames.h"
 #include "HTMLParserIdioms.h"
 #include "MediaList.h"
 #include "MediaQueryEvaluator.h"
 #include "Page.h"
 #include "RenderStyle.h"
 #include "SecurityOrigin.h"
 #include "Settings.h"
+#include "SharedEventSenders.h"
 #include "StyleInheritedData.h"
 #include "StyleResolveForDocument.h"
 #include "StyleSheetContents.h"
 #include <wtf/Ref.h>
 #include <wtf/StdLibExtras.h>
 
 namespace WebCore {
 
 using namespace HTMLNames;
 
-static LinkEventSender& linkLoadEventSender()
+LinkEventSender& HTMLLinkElement::linkLoadEventSender() const
 {
-    DEPRECATED_DEFINE_STATIC_LOCAL(LinkEventSender, sharedLoadEventSender, (eventNames().loadEvent));
-    return sharedLoadEventSender;
+    return document().sharedEventSenders().linkLoadEventSender();
 }
 
 inline HTMLLinkElement::HTMLLinkElement(const QualifiedName& tagName, Document& document, bool createdByParser)
     : HTMLElement(tagName, document)
     , m_linkLoader(this)
     , m_sizes(DOMSettableTokenList::create())
     , m_disabledState(Unset)
     , m_loading(false)
     , m_createdByParser(createdByParser)
     , m_isInShadowTree(false)
@@ -354,28 +354,23 @@ void HTMLLinkElement::linkLoadingErrored()
 
 bool HTMLLinkElement::sheetLoaded()
 {
     if (!styleSheetIsLoading()) {
         removePendingSheet();
         return true;
     }
     return false;
 }
 
-void HTMLLinkElement::dispatchPendingLoadEvents()
+void HTMLLinkElement::dispatchPendingEvent(LinkEventSender& eventSender)
 {
-    linkLoadEventSender().dispatchPendingEvents();
-}
-
-void HTMLLinkElement::dispatchPendingEvent(LinkEventSender* eventSender)
-{
-    ASSERT_UNUSED(eventSender, eventSender == &linkLoadEventSender());
+    ASSERT_UNUSED(eventSender, &eventSender == &linkLoadEventSender());
     if (m_loadedSheet)
         linkLoaded();
     else
         linkLoadingErrored();
 }
 
 void HTMLLinkElement::notifyLoadedSheetAndAllCriticalSubresources(bool errorOccurred)
 {
     if (m_firedLoad)
         return;
diff --git a/Source/WebCore/html/HTMLLinkElement.h b/Source/WebCore/html/HTMLLinkElement.h
index 65b3241..a429fab 100644
--- a/Source/WebCore/html/HTMLLinkElement.h
+++ b/Source/WebCore/html/HTMLLinkElement.h
@@ -61,22 +61,22 @@ public:
 
     CSSStyleSheet* sheet() const { return m_sheet.get(); }
 
     bool styleSheetIsLoading() const;
 
     bool isDisabled() const { return m_disabledState == Disabled; }
     bool isEnabledViaScript() const { return m_disabledState == EnabledViaScript; }
     void setSizes(const String&);
     DOMSettableTokenList* sizes() const;
 
-    void dispatchPendingEvent(LinkEventSender*);
-    static void dispatchPendingLoadEvents();
+    void dispatchPendingEvent(LinkEventSender&);
+    LinkEventSender& linkLoadEventSender() const;
 
 private:
     virtual void parseAttribute(const QualifiedName&, const AtomicString&) override;
 
     virtual bool shouldLoadLink() override;
     void process();
     static void processCallback(Node*);
     void clearSheet();
 
     virtual InsertionNotificationRequest insertedInto(ContainerNode&) override;
diff --git a/Source/WebCore/html/HTMLStyleElement.cpp b/Source/WebCore/html/HTMLStyleElement.cpp
index c59ef16..706ed90 100644
--- a/Source/WebCore/html/HTMLStyleElement.cpp
+++ b/Source/WebCore/html/HTMLStyleElement.cpp
@@ -26,30 +26,30 @@
 
 #include "Attribute.h"
 #include "Document.h"
 #include "Event.h"
 #include "EventSender.h"
 #include "HTMLNames.h"
 #include "MediaList.h"
 #include "RuntimeEnabledFeatures.h"
 #include "ScriptableDocumentParser.h"
 #include "ShadowRoot.h"
+#include "SharedEventSenders.h"
 #include "StyleSheetContents.h"
 
 namespace WebCore {
 
 using namespace HTMLNames;
 
-static StyleEventSender& styleLoadEventSender()
+StyleEventSender& HTMLStyleElement::styleLoadEventSender() const
 {
-    DEPRECATED_DEFINE_STATIC_LOCAL(StyleEventSender, sharedLoadEventSender, (eventNames().loadEvent));
-    return sharedLoadEventSender;
+    return document().sharedEventSenders().styleLoadEventSender();
 }
 
 inline HTMLStyleElement::HTMLStyleElement(const QualifiedName& tagName, Document& document, bool createdByParser)
     : HTMLElement(tagName, document)
     , m_styleSheetOwner(document, createdByParser)
     , m_firedLoad(false)
     , m_loadedSheet(false)
 {
     ASSERT(hasTagName(styleTag));
 }
@@ -107,28 +107,23 @@ void HTMLStyleElement::removedFrom(ContainerNode& insertionPoint)
     if (insertionPoint.inDocument())
         m_styleSheetOwner.removedFromDocument(document(), *this);
 }
 
 void HTMLStyleElement::childrenChanged(const ChildChange& change)
 {
     HTMLElement::childrenChanged(change);
     m_styleSheetOwner.childrenChanged(*this);
 }
 
-void HTMLStyleElement::dispatchPendingLoadEvents()
+void HTMLStyleElement::dispatchPendingEvent(StyleEventSender& eventSender)
 {
-    styleLoadEventSender().dispatchPendingEvents();
-}
-
-void HTMLStyleElement::dispatchPendingEvent(StyleEventSender* eventSender)
-{
-    ASSERT_UNUSED(eventSender, eventSender == &styleLoadEventSender());
+    ASSERT_UNUSED(eventSender, &eventSender == &styleLoadEventSender());
     if (m_loadedSheet)
         dispatchEvent(Event::create(eventNames().loadEvent, false, false));
     else
         dispatchEvent(Event::create(eventNames().errorEvent, false, false));
 }
 
 void HTMLStyleElement::notifyLoadedSheetAndAllCriticalSubresources(bool errorOccurred)
 {
     if (m_firedLoad)
         return;
diff --git a/Source/WebCore/html/HTMLStyleElement.h b/Source/WebCore/html/HTMLStyleElement.h
index 9957ba5..2d7eaa9 100644
--- a/Source/WebCore/html/HTMLStyleElement.h
+++ b/Source/WebCore/html/HTMLStyleElement.h
@@ -37,22 +37,23 @@ typedef EventSender<HTMLStyleElement> StyleEventSender;
 class HTMLStyleElement final : public HTMLElement {
 public:
     static PassRefPtr<HTMLStyleElement> create(const QualifiedName&, Document&, bool createdByParser);
     virtual ~HTMLStyleElement();
 
     CSSStyleSheet* sheet() const { return m_styleSheetOwner.sheet(); }
 
     bool disabled() const;
     void setDisabled(bool);
 
-    void dispatchPendingEvent(StyleEventSender*);
-    static void dispatchPendingLoadEvents();
+    void dispatchPendingEvent(StyleEventSender&);
+
+    StyleEventSender& styleLoadEventSender() const;
 
 private:
     HTMLStyleElement(const QualifiedName&, Document&, bool createdByParser);
 
     // overload from HTMLElement
     virtual void parseAttribute(const QualifiedName&, const AtomicString&) override;
     virtual InsertionNotificationRequest insertedInto(ContainerNode&) override;
     virtual void removedFrom(ContainerNode&) override;
     virtual void childrenChanged(const ChildChange&) override;
 
diff --git a/Source/WebCore/loader/ImageLoader.cpp b/Source/WebCore/loader/ImageLoader.cpp
index 7d94fc8..aa5a469 100644
--- a/Source/WebCore/loader/ImageLoader.cpp
+++ b/Source/WebCore/loader/ImageLoader.cpp
@@ -31,20 +31,21 @@
 #include "Event.h"
 #include "EventSender.h"
 #include "Frame.h"
 #include "HTMLNames.h"
 #include "HTMLObjectElement.h"
 #include "HTMLParserIdioms.h"
 #include "Page.h"
 #include "RenderImage.h"
 #include "RenderSVGImage.h"
 #include "SecurityOrigin.h"
+#include "SharedEventSenders.h"
 #include <wtf/NeverDestroyed.h>
 
 #if ENABLE(VIDEO)
 #include "RenderVideo.h"
 #endif
 
 #if !ASSERT_DISABLED
 // ImageLoader objects are allocated as members of other objects, so generic pointer check would always fail.
 namespace WTF {
 
@@ -56,36 +57,33 @@ template<> struct ValueCheck<WebCore::ImageLoader*> {
             return;
         ValueCheck<WebCore::Element*>::checkConsistency(&p->element());
     }
 };
 
 }
 #endif
 
 namespace WebCore {
 
-static ImageEventSender& beforeLoadEventSender()
+ImageEventSender& ImageLoader::beforeLoadEventSender() const
 {
-    static NeverDestroyed<ImageEventSender> sender(eventNames().beforeloadEvent);
-    return sender;
+    return m_element.document().sharedEventSenders().imageBeforeloadEventSender();
 }
 
-static ImageEventSender& loadEventSender()
+ImageEventSender& ImageLoader::loadEventSender() const
 {
-    static NeverDestroyed<ImageEventSender> sender(eventNames().loadEvent);
-    return sender;
+    return m_element.document().sharedEventSenders().imageLoadEventSender();
 }
 
-static ImageEventSender& errorEventSender()
+ImageEventSender& ImageLoader::errorEventSender() const
 {
-    static NeverDestroyed<ImageEventSender> sender(eventNames().errorEvent);
-    return sender;
+    return m_element.document().sharedEventSenders().imageErrorEventSender();
 }
 
 static inline bool pageIsBeingDismissed(Document& document)
 {
     Frame* frame = document.frame();
     return frame && frame->loader().pageDismissalEventBeingDispatched() != FrameLoader::NoDismissal;
 }
 
 ImageLoader::ImageLoader(Element& element)
     : m_element(element)
@@ -372,24 +370,24 @@ void ImageLoader::updatedHasPendingEvent()
         ASSERT(!m_derefElementTimer.isActive());
         m_derefElementTimer.startOneShot(0);
     }   
 }
 
 void ImageLoader::timerFired(Timer<ImageLoader>&)
 {
     element().deref();
 }
 
-void ImageLoader::dispatchPendingEvent(ImageEventSender* eventSender)
+void ImageLoader::dispatchPendingEvent(ImageEventSender& eventSender)
 {
-    ASSERT(eventSender == &beforeLoadEventSender() || eventSender == &loadEventSender() || eventSender == &errorEventSender());
-    const AtomicString& eventType = eventSender->eventType();
+    ASSERT(&eventSender == &beforeLoadEventSender() || &eventSender == &loadEventSender() || &eventSender == &errorEventSender());
+    const AtomicString& eventType = eventSender.eventType();
     if (eventType == eventNames().beforeloadEvent)
         dispatchPendingBeforeLoadEvent();
     if (eventType == eventNames().loadEvent)
         dispatchPendingLoadEvent();
     if (eventType == eventNames().errorEvent)
         dispatchPendingErrorEvent();
 }
 
 void ImageLoader::dispatchPendingBeforeLoadEvent()
 {
@@ -441,35 +439,20 @@ void ImageLoader::dispatchPendingErrorEvent()
         return;
     m_hasPendingErrorEvent = false;
     if (element().document().hasLivingRenderTree())
         element().dispatchEvent(Event::create(eventNames().errorEvent, false, false));
 
     // Only consider updating the protection ref-count of the Element immediately before returning
     // from this function as doing so might result in the destruction of this ImageLoader.
     updatedHasPendingEvent();
 }
 
-void ImageLoader::dispatchPendingBeforeLoadEvents()
-{
-    beforeLoadEventSender().dispatchPendingEvents();
-}
-
-void ImageLoader::dispatchPendingLoadEvents()
-{
-    loadEventSender().dispatchPendingEvents();
-}
-
-void ImageLoader::dispatchPendingErrorEvents()
-{
-    errorEventSender().dispatchPendingEvents();
-}
-
 void ImageLoader::elementDidMoveToNewDocument()
 {
     clearFailedLoadURL();
     setImage(0);
 }
 
 inline void ImageLoader::clearFailedLoadURL()
 {
     m_failedLoadURL = AtomicString();
 }
diff --git a/Source/WebCore/loader/ImageLoader.h b/Source/WebCore/loader/ImageLoader.h
index 5f3724c..36ba58e 100644
--- a/Source/WebCore/loader/ImageLoader.h
+++ b/Source/WebCore/loader/ImageLoader.h
@@ -58,25 +58,25 @@ public:
     bool imageComplete() const { return m_imageComplete; }
 
     CachedImage* image() const { return m_image.get(); }
     void setImage(CachedImage*); // Cancels pending beforeload and load events, and doesn't dispatch new ones.
 
     void setLoadManually(bool loadManually) { m_loadManually = loadManually; }
 
     bool hasPendingBeforeLoadEvent() const { return m_hasPendingBeforeLoadEvent; }
     bool hasPendingActivity() const { return m_hasPendingLoadEvent || m_hasPendingErrorEvent; }
 
-    void dispatchPendingEvent(ImageEventSender*);
+    void dispatchPendingEvent(ImageEventSender&);
 
-    static void dispatchPendingBeforeLoadEvents();
-    static void dispatchPendingLoadEvents();
-    static void dispatchPendingErrorEvents();
+    ImageEventSender& beforeLoadEventSender() const;
+    ImageEventSender& loadEventSender() const;
+    ImageEventSender& errorEventSender() const;
 
 protected:
     explicit ImageLoader(Element&);
     virtual void notifyFinished(CachedResource*) override;
 
 private:
     virtual void dispatchLoadEvent() = 0;
     virtual String sourceURI(const AtomicString&) const = 0;
 
     void updatedHasPendingEvent();
diff --git a/Source/WebCore/xml/parser/XMLDocumentParser.cpp b/Source/WebCore/xml/parser/XMLDocumentParser.cpp
index 11e347e..45ea995 100644
--- a/Source/WebCore/xml/parser/XMLDocumentParser.cpp
+++ b/Source/WebCore/xml/parser/XMLDocumentParser.cpp
@@ -41,20 +41,21 @@
 #include "HTMLStyleElement.h"
 #include "ImageLoader.h"
 #include "ProcessingInstruction.h"
 #include "ResourceError.h"
 #include "ResourceRequest.h"
 #include "ResourceResponse.h"
 #include "SVGNames.h"
 #include "SVGStyleElement.h"
 #include "ScriptElement.h"
 #include "ScriptSourceCode.h"
+#include "SharedEventSenders.h"
 #include "TextResourceDecoder.h"
 #include "TreeDepthLimit.h"
 #include <wtf/Ref.h>
 #include <wtf/StringExtras.h>
 #include <wtf/Threading.h>
 #include <wtf/Vector.h>
 
 namespace WebCore {
 
 using namespace HTMLNames;
@@ -113,23 +114,20 @@ void XMLDocumentParser::append(PassRefPtr<StringImpl> inputSource)
 
     if (isStopped() || m_sawXSLTransform)
         return;
 
     if (m_parserPaused) {
         m_pendingSrc.append(source);
         return;
     }
 
     doWrite(source.toString());
-
-    // After parsing, go ahead and dispatch image beforeload events.
-    ImageLoader::dispatchPendingBeforeLoadEvents();
 }
 
 void XMLDocumentParser::handleError(XMLErrors::ErrorType type, const char* m, TextPosition position)
 {
     if (!m_xmlErrors)
         m_xmlErrors = std::make_unique<XMLErrors>(document());
     m_xmlErrors->handleError(type, m, position);
     if (type != XMLErrors::warning)
         m_sawError = true;
     if (type == XMLErrors::fatal)
-- 
2.0.1

