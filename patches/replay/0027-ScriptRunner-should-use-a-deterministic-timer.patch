From f646a68fd4e43abecd13a80227f63f8834579417 Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Thu, 18 Sep 2014 21:43:08 -0700
Subject: [PATCH] ScriptRunner should use a deterministic timer.

---
 Source/WebCore/dom/ScriptRunner.cpp | 6 +++---
 Source/WebCore/dom/ScriptRunner.h   | 6 +++---
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/Source/WebCore/dom/ScriptRunner.cpp b/Source/WebCore/dom/ScriptRunner.cpp
index 9948963..d181cf6 100644
--- a/Source/WebCore/dom/ScriptRunner.cpp
+++ b/Source/WebCore/dom/ScriptRunner.cpp
@@ -71,39 +71,39 @@ void ScriptRunner::queueScriptForExecution(ScriptElement* scriptElement, CachedR
 }
 
 void ScriptRunner::suspend()
 {
     m_timer.stop();
 }
 
 void ScriptRunner::resume()
 {
     if (hasPendingScripts())
-        m_timer.startOneShot(0);
+        m_timer.startOneShot(0, &m_document);
 }
 
 void ScriptRunner::notifyScriptReady(ScriptElement* scriptElement, ExecutionType executionType)
 {
     switch (executionType) {
     case ASYNC_EXECUTION:
         ASSERT(m_pendingAsyncScripts.contains(scriptElement));
         m_scriptsToExecuteSoon.append(m_pendingAsyncScripts.take(scriptElement));
         break;
 
     case IN_ORDER_EXECUTION:
         ASSERT(!m_scriptsToExecuteInOrder.isEmpty());
         break;
     }
-    m_timer.startOneShot(0);
+    m_timer.startOneShot(0, &m_document);
 }
 
-void ScriptRunner::timerFired(Timer<ScriptRunner>& timer)
+void ScriptRunner::timerFired(ReplayableTimer<ScriptRunner>& timer)
 {
     ASSERT_UNUSED(timer, &timer == &m_timer);
 
     Ref<Document> protect(m_document);
 
     Vector<PendingScript> scripts;
     scripts.swap(m_scriptsToExecuteSoon);
 
     size_t numInOrderScriptsToExecute = 0;
     for (; numInOrderScriptsToExecute < m_scriptsToExecuteInOrder.size() && m_scriptsToExecuteInOrder[numInOrderScriptsToExecute].cachedScript()->isLoaded(); ++numInOrderScriptsToExecute)
diff --git a/Source/WebCore/dom/ScriptRunner.h b/Source/WebCore/dom/ScriptRunner.h
index d7e692c..1ac829a 100644
--- a/Source/WebCore/dom/ScriptRunner.h
+++ b/Source/WebCore/dom/ScriptRunner.h
@@ -20,21 +20,21 @@
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
  */
 
 #ifndef ScriptRunner_h
 #define ScriptRunner_h
 
 #include "CachedResourceHandle.h"
-#include "Timer.h"
+#include "ReplayableTimer.h"
 #include <wtf/HashMap.h>
 #include <wtf/Noncopyable.h>
 #include <wtf/PassRefPtr.h>
 #include <wtf/Vector.h>
 
 namespace WebCore {
 
 class CachedScript;
 class Document;
 class PendingScript;
@@ -47,22 +47,22 @@ public:
     ~ScriptRunner();
 
     enum ExecutionType { ASYNC_EXECUTION, IN_ORDER_EXECUTION };
     void queueScriptForExecution(ScriptElement*, CachedResourceHandle<CachedScript>, ExecutionType);
     bool hasPendingScripts() const { return !m_scriptsToExecuteSoon.isEmpty() || !m_scriptsToExecuteInOrder.isEmpty() || !m_pendingAsyncScripts.isEmpty(); }
     void suspend();
     void resume();
     void notifyScriptReady(ScriptElement*, ExecutionType);
 
 private:
-    void timerFired(Timer<ScriptRunner>&);
+    void timerFired(ReplayableTimer<ScriptRunner>&);
 
     Document& m_document;
     Vector<PendingScript> m_scriptsToExecuteInOrder;
     Vector<PendingScript> m_scriptsToExecuteSoon; // http://www.whatwg.org/specs/web-apps/current-work/#set-of-scripts-that-will-execute-as-soon-as-possible
     HashMap<ScriptElement*, PendingScript> m_pendingAsyncScripts;
-    Timer<ScriptRunner> m_timer;
+    ReplayableTimer<ScriptRunner> m_timer;
 };
 
 }
 
 #endif
-- 
2.0.1

