From d59275b65c28c0d59b8aac8eaf4bf333f5008351 Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Wed, 27 Aug 2014 15:49:33 -0700
Subject: [PATCH] Web Replay: capture and replay changes to the page's
 ViewState https://bugs.webkit.org/show_bug.cgi?id=129694

Reviewed by NOBODY (OOPS!).

Source/WebCore:

Generate encoding traits for ViewState::Flags. It is used in WebKit2 inputs.

* WebCore.exp.in:
* replay/WebInputs.json:

Source/WebKit2:

SetViewState can cause DOM events like focus and blur to be fired, so
we want these changes to be captured and replayed.

WIP note: haven't tested this. Does it cause bad things to happen when
we suppress or fake up view state changes? Particularly worried about
drawing area calls.

* WebProcess/Replay/WKInputs.json:
* WebProcess/Replay/WKReplayInputDispatchMethods.cpp:
(WebKit::HandleViewStateChange::dispatchOnWebPage): Added.
* WebProcess/WebPage/WebPage.cpp:
(WebKit::WebPage::handleViewStateChange): Added.
(WebKit::WebPage::setViewState):
* WebProcess/WebPage/WebPage.h:
---
 Source/WebCore/ChangeLog                           | 12 ++++++++++++
 Source/WebCore/WebCore.exp.in                      |  2 ++
 Source/WebCore/replay/WebInputs.json               | 14 ++++++++++++++
 Source/WebKit2/ChangeLog                           | 22 ++++++++++++++++++++++
 Source/WebKit2/WebProcess/Replay/WKInputs.json     | 22 ++++++++++++++++++++++
 .../Replay/WKReplayInputDispatchMethods.cpp        |  6 ++++++
 Source/WebKit2/WebProcess/WebPage/WebPage.cpp      | 22 ++++++++++++++++++++--
 Source/WebKit2/WebProcess/WebPage/WebPage.h        |  1 +
 8 files changed, 99 insertions(+), 2 deletions(-)

diff --git a/Source/WebCore/ChangeLog b/Source/WebCore/ChangeLog
index 75934e3..57eb7dc 100644
--- a/Source/WebCore/ChangeLog
+++ b/Source/WebCore/ChangeLog
@@ -1,12 +1,24 @@
 2014-08-27  Brian J. Burg  <burg@cs.washington.edu>
 
+        Web Replay: capture and replay changes to the page's ViewState
+        https://bugs.webkit.org/show_bug.cgi?id=129694
+
+        Reviewed by NOBODY (OOPS!).
+
+        Generate encoding traits for ViewState::Flags. It is used in WebKit2 inputs.
+
+        * WebCore.exp.in:
+        * replay/WebInputs.json:
+
+2014-08-27  Brian J. Burg  <burg@cs.washington.edu>
+
         Web Replay: only generate EncodingTraits for enums defined in the target framework
         https://bugs.webkit.org/show_bug.cgi?id=136311
 
         Reviewed by NOBODY (OOPS!).
 
         Duplicate the definitions for some enumerations used in WebKit but not in WebCore.
         Add enum encoding traits symbols to the export file.
 
         Covered by existing generator tests.
 
diff --git a/Source/WebCore/WebCore.exp.in b/Source/WebCore/WebCore.exp.in
index 9b3fff6..277f177 100644
--- a/Source/WebCore/WebCore.exp.in
+++ b/Source/WebCore/WebCore.exp.in
@@ -3564,20 +3564,22 @@ __ZN3JSC14EncodingTraitsIN7WebCore15KeypressCommandEE11encodeValueERKS2_
 __ZN3JSC14EncodingTraitsIN7WebCore15ScrollDirectionEE11decodeValueERNS_12EncodedValueERS2_
 __ZN3JSC14EncodingTraitsIN7WebCore15ScrollDirectionEE11encodeValueERKS2_
 __ZN3JSC14EncodingTraitsIN7WebCore16FrameLoadRequestEE11decodeValueERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
 __ZN3JSC14EncodingTraitsIN7WebCore16FrameLoadRequestEE11encodeValueERKS2_
 __ZN3JSC14EncodingTraitsIN7WebCore17ScrollGranularityEE11decodeValueERNS_12EncodedValueERS2_
 __ZN3JSC14EncodingTraitsIN7WebCore17ScrollGranularityEE11encodeValueERKS2_
 __ZN3JSC14EncodingTraitsIN7WebCore8IntPointEE11decodeValueERNS_12EncodedValueERS2_
 __ZN3JSC14EncodingTraitsIN7WebCore8IntPointEE11encodeValueERKS2_
 __ZN3JSC14EncodingTraitsIN7WebCore9FloatSizeEE11decodeValueERNS_12EncodedValueERS2_
 __ZN3JSC14EncodingTraitsIN7WebCore9FloatSizeEE11encodeValueERKS2_
+__ZN3JSC14EncodingTraitsINS_7PhantomIN7WebCore14UncheckedEnumsELS3_0EEEE11decodeValueERNS_12EncodedValueERj
+__ZN3JSC14EncodingTraitsINS_7PhantomIN7WebCore14UncheckedEnumsELS3_0EEEE11encodeValueERKj
 __ZN7WebCore19frameFromFrameIndexEPNS_4PageEj
 __ZN7WebCore19frameIndexFromFrameEPKNS_5FrameE
 __ZN7WebCore20EventLoopInputExtentC1ERN3JSC11InputCursorE
 __ZN7WebCore20EventLoopInputExtentD1Ev
 __ZNK7WebCore14ResourceLoader17activeInputCursorEv
 __ZNK7WebCore16ReplayController17activeInputCursorEv
 #endif
 
 #if ENABLE(WEB_TIMING)
 __ZNK7WebCore20ResourceResponseBase18resourceLoadTimingEv
diff --git a/Source/WebCore/replay/WebInputs.json b/Source/WebCore/replay/WebInputs.json
index 19bcbde..24ae72f 100644
--- a/Source/WebCore/replay/WebInputs.json
+++ b/Source/WebCore/replay/WebInputs.json
@@ -129,20 +129,34 @@
                 "values": [
                     "Data",
                     "EncodedFile",
                     "EncodedBlob"
                 ],
                 "header": "platform/network/FormData.h"
             },
             {
                 "name": "URL", "mode": "HEAVY_SCALAR",
                 "header": "platform/URL.h"
+            },
+            {
+                "name": "Flags", "mode": "SCALAR",
+                "flags": ["ENUM", "UNCHECKED"],
+                "enclosing_class": "ViewState",
+                "values": [
+                    "WindowIsActive",
+                    "IsFocused",
+                    "IsVisible",
+                    "IsVisibleOrOccluded",
+                    "IsInWindow",
+                    "IsVisuallyIdle"
+                ],
+                "header": "page/ViewState.h"
             }
         ]
     },
 
     "inputs": [
         {
             "name": "AsyncTimerFired",
             "description": "A ReplayableTimer instance fired that was associated with the specified frame.",
             "queue": "EVENT_LOOP",
             "members": [
diff --git a/Source/WebKit2/ChangeLog b/Source/WebKit2/ChangeLog
index dc3a883..4415fcf 100644
--- a/Source/WebKit2/ChangeLog
+++ b/Source/WebKit2/ChangeLog
@@ -1,10 +1,32 @@
+2014-08-27  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Replay: capture and replay changes to the page's ViewState
+        https://bugs.webkit.org/show_bug.cgi?id=129694
+
+        Reviewed by NOBODY (OOPS!).
+
+        SetViewState can cause DOM events like focus and blur to be fired, so
+        we want these changes to be captured and replayed.
+
+        WIP note: haven't tested this. Does it cause bad things to happen when
+        we suppress or fake up view state changes? Particularly worried about
+        drawing area calls.
+
+        * WebProcess/Replay/WKInputs.json:
+        * WebProcess/Replay/WKReplayInputDispatchMethods.cpp:
+        (WebKit::HandleViewStateChange::dispatchOnWebPage): Added.
+        * WebProcess/WebPage/WebPage.cpp:
+        (WebKit::WebPage::handleViewStateChange): Added.
+        (WebKit::WebPage::setViewState):
+        * WebProcess/WebPage/WebPage.h:
+
 2015-01-11  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Replay: capture and dispatch navigation inputs from WebPage
         Need the bug URL (OOPS!).
 
         Reviewed by NOBODY (OOPS!).
 
         Finish moving interception methods from UserInputBridge into WebPage.
         Add handle* interception methods for navigation inputs and route through them.
 
diff --git a/Source/WebKit2/WebProcess/Replay/WKInputs.json b/Source/WebKit2/WebProcess/Replay/WKInputs.json
index c004f9e..f34a756 100644
--- a/Source/WebKit2/WebProcess/Replay/WKInputs.json
+++ b/Source/WebKit2/WebProcess/Replay/WKInputs.json
@@ -24,20 +24,34 @@
                 "name": "ScrollGranularity", "mode": "SCALAR", "storage": "uint8_t",
                 "flags": ["ENUM"],
                 "values": [
                     "ScrollByLine",
                     "ScrollByPage",
                     "ScrollByDocument",
                     "ScrollByPixel",
                     "ScrollByPrecisePixel"
                 ],
                 "header": "platform/ScrollTypes.h"
+            },
+            {
+                "name": "Flags", "mode": "SCALAR",
+                "flags": ["ENUM", "UNCHECKED"],
+                "enclosing_class": "ViewState",
+                "values": [
+                    "WindowIsActive",
+                    "IsFocused",
+                    "IsVisible",
+                    "IsVisibleOrOccluded",
+                    "IsInWindow",
+                    "IsVisuallyIdle"
+                ],
+                "header": "page/ViewState.h"
             }
         ],
         "WebKit": [
             {
                 "name": "WebMouseEvent", "mode": "OWNED",
                 "header": "Shared/WebEvent.h"
             },
             {
                 "name": "Modifiers", "mode": "SCALAR", "storage": "uint8_t",
                 "enclosing_class": "WebEvent",
@@ -164,17 +178,25 @@
         },
         {
             "name": "HandleWheelEvent",
             "description": "A wheel event is forwarded to the web page.",
             "queue": "EVENT_LOOP",
             "members": [
                 { "name": "wheelEvent", "type": "WebWheelEvent" }
             ]
         },
         {
+            "name": "HandleViewStateChange",
+            "description": "View state of the page changed. See ViewState.h for possible changes.",
+            "queue": "EVENT_LOOP",
+            "members": [
+                { "name": "state", "type": "ViewState::Flags" }
+            ]
+        },
+        {
             "name": "TryClosePage",
             "description": "The embedder requested that the page should be closed (subject to beforeunload cancellation).",
             "queue": "EVENT_LOOP",
             "members": [ ]
         }
     ]
 }
diff --git a/Source/WebKit2/WebProcess/Replay/WKReplayInputDispatchMethods.cpp b/Source/WebKit2/WebProcess/Replay/WKReplayInputDispatchMethods.cpp
index a193929..a98d195 100644
--- a/Source/WebKit2/WebProcess/Replay/WKReplayInputDispatchMethods.cpp
+++ b/Source/WebKit2/WebProcess/Replay/WKReplayInputDispatchMethods.cpp
@@ -72,18 +72,24 @@ void HandleFrameReload::dispatch(WebPage& page)
 void HandleFrameStop::dispatch(WebPage& page)
 {
     WebCore::Frame* frame = WebCore::frameFromFrameIndex(page.corePage(), m_frameIndex);
     ASSERT(frame);
     if (!frame)
         return;
 
     page.handleFrameStop(*frame, WebPage::ActionSource::Synthetic);
 }
 
+void HandleViewStateChange::dispatch(WebPage& page)
+{
+    Vector<uint64_t> empty;
+    page.handleViewStateChange(state(), false, empty, WebPage::ActionSource::Synthetic);
+}
+
 void TryClosePage::dispatch(WebPage& page)
 {
     page.handleTryClose(WebPage::ActionSource::Synthetic);
 }
 
 } // namespace WebKit
 
 #endif // ENABLE(WEB_REPLAY)
diff --git a/Source/WebKit2/WebProcess/WebPage/WebPage.cpp b/Source/WebKit2/WebProcess/WebPage/WebPage.cpp
index 9204fbe..9d09ccc 100644
--- a/Source/WebKit2/WebProcess/WebPage/WebPage.cpp
+++ b/Source/WebKit2/WebProcess/WebPage/WebPage.cpp
@@ -2471,38 +2471,56 @@ void WebPage::updateIsInWindow(bool isInitialState)
         if (m_mayStartMediaWhenInWindow)
             m_setCanStartMediaTimer.startOneShot(0);
 
         WebProcess::shared().pageDidEnterWindow(m_pageID);
     }
 
     if (isInWindow)
         layoutIfNeeded();
 }
 
-void WebPage::setViewState(ViewState::Flags viewState, bool wantsDidUpdateViewState, const Vector<uint64_t>& callbackIDs)
+void WebPage::handleViewStateChange(ViewState::Flags viewState, bool wantsDidUpdateViewState, const Vector<uint64_t>& callbackIDs, ActionSource source)
 {
-    ViewState::Flags changed = m_viewState ^ viewState;
+#if ENABLE(WEB_REPLAY)
+    // Don't try to handle view state changes if the web content is being replayed.
+    InputCursor& cursor = corePage()->replayController().activeInputCursor();
+    if (cursor.isReplaying() && source != ActionSource::Synthetic)
+        return;
+    if (cursor.isCapturing())
+        cursor.appendInput<HandleViewStateChange>(viewState);
+    EventLoopInputExtent extent(cursor);
+#else
+    UNUSED_PARAM(source);
+#endif
+
+    ViewState::Flags changed = static_cast<ViewState::Flags>(m_viewState ^ viewState);
     m_viewState = viewState;
 
     if (changed)
         updateUserActivity();
 
     m_page->setViewState(viewState);
     for (auto* pluginView : m_pluginViews)
         pluginView->viewStateDidChange(changed);
 
     m_drawingArea->viewStateDidChange(changed, wantsDidUpdateViewState, callbackIDs);
 
     if (changed & ViewState::IsInWindow)
         updateIsInWindow();
 }
 
+
+void WebPage::setViewState(uint32_t viewStateFlags, bool wantsDidUpdateViewState, const Vector<uint64_t>& callbackIDs)
+{
+    handleViewStateChange(static_cast<ViewState::Flags>(viewStateFlags), wantsDidUpdateViewState, callbackIDs, ActionSource::User);
+}
+
 void WebPage::setLayerHostingMode(unsigned layerHostingMode)
 {
     m_layerHostingMode = static_cast<LayerHostingMode>(layerHostingMode);
 
     m_drawingArea->setLayerHostingMode(m_layerHostingMode);
 
     for (auto* pluginView : m_pluginViews)
         pluginView->setLayerHostingMode(m_layerHostingMode);
 }
 
diff --git a/Source/WebKit2/WebProcess/WebPage/WebPage.h b/Source/WebKit2/WebProcess/WebPage/WebPage.h
index 3bb9d8d..c32fb1a 100644
--- a/Source/WebKit2/WebProcess/WebPage/WebPage.h
+++ b/Source/WebKit2/WebProcess/WebPage/WebPage.h
@@ -874,20 +874,21 @@ public:
     // Entry points for actions that can be simulated during web replay.
     bool handleMouseEvent(const WebMouseEvent&, ActionSource);
     bool handleKeyEvent(const WebKeyboardEvent&, ActionSource);
     bool handleWheelEvent(const WebWheelEvent&, ActionSource);
     bool handleScroll(WebCore::ScrollDirection, WebCore::ScrollGranularity, ActionSource = ActionSource::User);
 
     void handleFrameLoad(const WebCore::FrameLoadRequest&, ActionSource);
     void handleFrameReload(WebCore::Frame&, bool endToEndReload, ActionSource);
     void handleFrameStop(WebCore::Frame&, ActionSource);
     bool handleTryClose(ActionSource);
+    void handleViewStateChange(WebCore::ViewState::Flags, bool wantsDidUpdateViewState, const Vector<uint64_t>& callbackIds, ActionSource);
 
     
 private:
     WebPage(uint64_t pageID, const WebPageCreationParameters&);
 
     // IPC::MessageSender
     virtual IPC::Connection* messageSenderConnection() override;
     virtual uint64_t messageSenderDestinationID() override;
 
     void platformInitialize();
-- 
2.0.1

