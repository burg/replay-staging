From 90df1e0603f454a2c3aabe87119d5116ae399487 Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Thu, 24 Jul 2014 09:23:12 -0700
Subject: [PATCH] [WIP] Convert ReplayManager.{create,switch}Session to a
 promise-based API.

---
 .../UserInterface/Controllers/ReplayManager.js     | 62 +++++++++++++++-------
 .../UserInterface/Views/ReplayDashboardView.js     | 25 ++++-----
 2 files changed, 52 insertions(+), 35 deletions(-)

diff --git a/Source/WebInspectorUI/UserInterface/Controllers/ReplayManager.js b/Source/WebInspectorUI/UserInterface/Controllers/ReplayManager.js
index e59c1d9..a288e24 100644
--- a/Source/WebInspectorUI/UserInterface/Controllers/ReplayManager.js
+++ b/Source/WebInspectorUI/UserInterface/Controllers/ReplayManager.js
@@ -157,54 +157,91 @@ WebInspector.ReplayManager.prototype = {
         console.assert(this._initialized);
         this._playbackSpeed = value;
     },
 
     get currentPosition()
     {
         console.assert(this._initialized);
         return this._currentPosition;
     },
 
-    // These return promises even if the relevant instance is already created.
-    waitUntilInitialized: function()
+
+    // Public - Asynchronous API
+    //
+    // Methods in this section return promises and require the manager to be initialized.
+
+    // Return a promise that resolves when the manager is fully initialized.
+    waitUntilInitialized: function() // --> ()
     {
         return this._initializationPromise;
     },
 
-    getSession: function(sessionId)
+    getSession: function(sessionId) // --> (WebInspector.ReplaySession)
     {
+        console.assert(this._initialized);
+
         if (this._sessionPromises.has(sessionId))
             return this._sessionPromises.get(sessionId);
 
-        var newPromise = ReplayAgent.getSessionData.promise(sessionId)
+        var newPromise = ReplayAgent.getSessionData(sessionId)
             .then(function(payload) {
                 return Promise.resolve(WebInspector.ReplaySession.fromPayload(sessionId, payload));
             });
 
         this._sessionPromises.set(sessionId, newPromise);
         return newPromise;
     },
 
-    getSegment: function(segmentId)
+    getSegment: function(segmentId) // --> (WebInspector.ReplaySessionSegment)
     {
+        console.assert(this._initialized);
+
         if (this._segmentPromises.has(segmentId))
             return this._segmentPromises.get(segmentId);
 
-        var newPromise = ReplayAgent.getSegmentData.promise(segmentId)
+        var newPromise = ReplayAgent.getSegmentData(segmentId)
             .then(function(payload) {
                 return Promise.resolve(new WebInspector.ReplaySessionSegment(segmentId, payload));
             });
 
         this._segmentPromises.set(segmentId, newPromise);
         return newPromise;
     },
 
+    // Create a new session. Returns a promise that can resolve to the created session identifier.
+    createSession: function() // --> (sessionId)
+    {
+        console.assert(this._initialized);
+
+        return ReplayAgent.createSession()
+            .then(function unwrapPayload(payload) {
+                return payload.sessionIdentifier;
+            })
+            .catch(function(error) {
+                console.error("Failed to create new session: ", error);
+            });
+    },
+
+    switchSession: function(sessionId) {
+        console.assert(this.sessionState === WebInspector.ReplayManager.SessionState.Inactive);
+        console.assert(this.segmentState === WebInspector.ReplayManager.SegmentState.Unloaded);
+
+        // Ensure that the session's data has been loaded before switching to it.
+        return this.getSession(sessionId)
+            .then(function () {
+                return ReplayAgent.switchSession(sessionId);
+            })
+            .catch(function(error) {
+                console.error("Failed to switch to session: ", error);
+            });
+    },
+
     // Protected (called by ReplayObserver)
 
     // Since these methods update session and segment state, they depend on the manager
     // being properly initialized. So, each function body is prepended with a retry guard.
     // This makes call sites simpler and avoids an extra event loop turn in the common case.
 
     captureStarted: function()
     {
         if (!this._initialized)
             return this.waitUntilInitialized().then(this.captureStarted.bind(this));
@@ -474,33 +511,20 @@ WebInspector.ReplayManager.prototype = {
     },
 
     stopPlayback: function()
     {
         console.assert(this.sessionState === WebInspector.ReplayManager.SessionState.Replaying);
         console.assert(this.segmentState === WebInspector.ReplayManager.SegmentState.Loaded);
 
         ReplayAgent.stopPlayback();
     },
 
-    createSession: function()
-    {
-        ReplayAgent.createSession();
-    },
-
-    switchSession: function(sessionId) {
-        console.assert(this.sessionState === WebInspector.ReplayManager.SessionState.Inactive);
-        console.assert(this.segmentState === WebInspector.ReplayManager.SegmentState.Unloaded);
-        console.assert(this._sessions.has(sessionId), "Unknown session identifier:", sessionId);
-
-        ReplayAgent.switchSession(sessionId);
-    },
-
     // Private
 
     _changeSessionState: function(newState)
     {
         // Warn about no-op state changes. We shouldn't be seeing them.
         var isAllowed = this._sessionState !== newState;
 
         switch (this._sessionState) {
         case WebInspector.ReplayManager.SessionState.Capturing:
             isAllowed &= newState === WebInspector.ReplayManager.SessionState.Inactive;
diff --git a/Source/WebInspectorUI/UserInterface/Views/ReplayDashboardView.js b/Source/WebInspectorUI/UserInterface/Views/ReplayDashboardView.js
index dcffc0e..4b3df43 100644
--- a/Source/WebInspectorUI/UserInterface/Views/ReplayDashboardView.js
+++ b/Source/WebInspectorUI/UserInterface/Views/ReplayDashboardView.js
@@ -102,37 +102,30 @@ WebInspector.ReplayDashboardView.prototype = {
             WebInspector.replayManager.pausePlayback();
         else
             WebInspector.replayManager.replayToCompletion();
     },
 
     _ejectButtonItemClicked: function(event)
     {
         console.assert(WebInspector.replayManager.sessionState !== WebInspector.ReplayManager.SessionState.Capturing, "Tried to eject session while SessionState is Capturing!");
 
         // Debounce.
-        this._ejectButtonItem.enabled = false;
-
         var button = this._ejectButtonItem;
-
-        new Promise(function createEmptySession(resolve, reject) {
-            // FIXME: this listener should not be necessary when ReplayManager API becomes fully async.
-            WebInspector.replayManager.addSingleFireEventListener(WebInspector.ReplayManager.Event.SessionAdded, resolve);
-            WebInspector.replayManager.createSession();
-        }).then(function forceSessionToBeLoaded(event) {
-            var sessionId = event.data.sessionId;
-            return WebInspector.replayManager.getSession(sessionId);
-        }).then(function switchToEmptySession(session) {
-            WebInspector.replayManager.switchSession(session.identifier);
-            button.enabled = true;
-        }).catch(function(error) {
-            console.error("Failed to eject currect recording: ", error);
-        });
+        button.enabled = false;
+
+        WebInspector.replayManager.createSession()
+            .then(function switchToEmptySession(sessionId) {
+                button.enabled = true;
+                return WebInspector.replayManager.switchSession(sessionId);
+            }).catch(function(error) {
+                console.error("Failed to eject currect recording: ", error);
+            });
     },
 
     _captureStarted: function()
     {
         this._captureButtonItem.hidden = false;
         this._captureButtonItem.activated = true;
         this._replayButtonItem.hidden = true;
         this._ejectButtonItem.hidden = true;
     },
 
-- 
2.0.1

