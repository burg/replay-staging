From efa6601c40b562109137e079aa07887189427ca1 Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Wed, 23 Jul 2014 18:17:46 -0700
Subject: [PATCH] Web Replay: log and enforce session/segment state machine
 transitions https://bugs.webkit.org/show_bug.cgi?id=135224

Reviewed by NOBODY (OOPS!).

For debugging purposes, log session and segment state transitions.
Assert that segment state transitions are valid.

No new tests. No behavior was changed.

* replay/ReplayController.cpp:
(WebCore::logDispatchedDOMEvent):
(WebCore::sessionStateToString):
(WebCore::segmentStateToString):
(WebCore::ReplayController::setSessionState):
(WebCore::ReplayController::setSegmentState):
(WebCore::ReplayController::createSegment):
(WebCore::ReplayController::completeSegment): Remove a wrong state transition.
(WebCore::ReplayController::loadSegmentAtIndex):
(WebCore::ReplayController::unloadSegment): Fix a now-erroneous assertion.
(WebCore::ReplayController::startPlayback):
(WebCore::ReplayController::pausePlayback):
(WebCore::ReplayController::willDispatchEvent):
(WebCore::ReplayController::cancelPlayback):
* replay/ReplayController.h:
---
 Source/WebCore/ChangeLog                   | 28 ++++++++++
 Source/WebCore/replay/ReplayController.cpp | 82 +++++++++++++++++++++++++-----
 Source/WebCore/replay/ReplayController.h   |  1 +
 3 files changed, 98 insertions(+), 13 deletions(-)

diff --git a/Source/WebCore/ChangeLog b/Source/WebCore/ChangeLog
index 952fc3e..3003484 100644
--- a/Source/WebCore/ChangeLog
+++ b/Source/WebCore/ChangeLog
@@ -1,12 +1,40 @@
 2014-07-23  Brian J. Burg  <burg@cs.washington.edu>
 
+        Web Replay: log and enforce session/segment state machine transitions
+        https://bugs.webkit.org/show_bug.cgi?id=135224
+
+        Reviewed by NOBODY (OOPS!).
+
+        For debugging purposes, log session and segment state transitions.
+        Assert that segment state transitions are valid.
+
+        No new tests. No behavior was changed.
+
+        * replay/ReplayController.cpp:
+        (WebCore::logDispatchedDOMEvent):
+        (WebCore::sessionStateToString):
+        (WebCore::segmentStateToString):
+        (WebCore::ReplayController::setSessionState):
+        (WebCore::ReplayController::setSegmentState):
+        (WebCore::ReplayController::createSegment):
+        (WebCore::ReplayController::completeSegment): Remove a wrong state transition.
+        (WebCore::ReplayController::loadSegmentAtIndex):
+        (WebCore::ReplayController::unloadSegment): Fix a now-erroneous assertion.
+        (WebCore::ReplayController::startPlayback):
+        (WebCore::ReplayController::pausePlayback):
+        (WebCore::ReplayController::willDispatchEvent):
+        (WebCore::ReplayController::cancelPlayback):
+        * replay/ReplayController.h:
+
+2014-07-23  Brian J. Burg  <burg@cs.washington.edu>
+
         Web Inspector: ReplayManager shouldn't assume replay status when the inspector is opened
         https://bugs.webkit.org/show_bug.cgi?id=135212
 
         Reviewed by NOBODY (OOPS!).
 
         The frontend should be able to introspect the session and segment state machines,
         currently loaded segment and session identifiers, and replay position.
 
         * inspector/InspectorReplayAgent.cpp:
         (WebCore::buildInspectorObjectForSessionState): Added.
diff --git a/Source/WebCore/replay/ReplayController.cpp b/Source/WebCore/replay/ReplayController.cpp
index 3c328f7..9cdce32 100644
--- a/Source/WebCore/replay/ReplayController.cpp
+++ b/Source/WebCore/replay/ReplayController.cpp
@@ -51,49 +51,73 @@
 #include "WebReplayInputs.h"
 #include <replay/EmptyInputCursor.h>
 #include <wtf/text/CString.h>
 
 #if ENABLE(ASYNC_SCROLLING)
 #include "ScrollingCoordinator.h"
 #endif
 
 namespace WebCore {
 
+#if !LOG_DISABLED
 static void logDispatchedDOMEvent(const Event& event, bool eventIsUnrelated)
 {
-#if !LOG_DISABLED
     EventTarget* target = event.target();
     if (!target)
         return;
 
     // A DOM event is unrelated if it is being dispatched to a document that is neither capturing nor replaying.
     if (Node* node = target->toNode()) {
         LOG(WebReplay, "%-20s --->%s DOM event: type=%s, target=%u/node[%p] %s\n", "ReplayEvents",
             (eventIsUnrelated) ? "Unrelated" : "Dispatching",
             event.type().string().utf8().data(),
             frameIndexFromDocument((node->inDocument()) ? &node->document() : node->ownerDocument()),
             node,
             node->nodeName().utf8().data());
     } else if (DOMWindow* window = target->toDOMWindow()) {
         LOG(WebReplay, "%-20s --->%s DOM event: type=%s, target=%u/window[%p] %s\n", "ReplayEvents",
             (eventIsUnrelated) ? "Unrelated" : "Dispatching",
             event.type().string().utf8().data(),
             frameIndexFromDocument(window->document()),
             window,
             window->location()->href().utf8().data());
     }
-#else
-    UNUSED_PARAM(event);
-    UNUSED_PARAM(eventIsUnrelated);
-#endif
 }
 
+static const char* sessionStateToString(SessionState state)
+{
+    switch (state) {
+    case SessionState::Capturing:
+        return "Capturing";
+    case SessionState::Inactive:
+        return "Inactive";
+    case SessionState::Replaying:
+        return "Replaying";
+    }
+}
+
+static const char* segmentStateToString(SegmentState state)
+{
+    switch (state) {
+    case SegmentState::Appending:
+        return "Appending";
+    case SegmentState::Unloaded:
+        return "Unloaded";
+    case SegmentState::Loaded:
+        return "Loaded";
+    case SegmentState::Dispatching:
+        return "Dispatching";
+    }
+}
+
+#endif // !LOG_DISABLED
+
 ReplayController::ReplayController(Page& page)
     : m_page(page)
     , m_loadedSegment(nullptr)
     , m_loadedSession(ReplaySession::create())
     , m_emptyCursor(EmptyInputCursor::create())
     , m_activeCursor(nullptr)
     , m_targetPosition(ReplayPosition(0, 0))
     , m_currentPosition(ReplayPosition(0, 0))
     , m_segmentState(SegmentState::Unloaded)
     , m_sessionState(SessionState::Inactive)
@@ -119,20 +143,22 @@ void ReplayController::setForceDeterministicSettings(bool shouldForceDeterminist
 #if ENABLE(ASYNC_SCROLLING)
     if (ScrollingCoordinator* scrollingCoordinator = m_page.scrollingCoordinator())
         scrollingCoordinator->replaySessionStateDidChange();
 #endif
 }
 
 void ReplayController::setSessionState(SessionState state)
 {
     ASSERT(state != m_sessionState);
 
+    LOG(WebReplay, "%-20s SessionState transition: %10s --> %10s.\n", "ReplayController", sessionStateToString(m_sessionState), sessionStateToString(state));
+
     switch (m_sessionState) {
     case SessionState::Capturing:
         ASSERT(state == SessionState::Inactive);
 
         m_sessionState = state;
         m_page.userInputBridge().setState(UserInputBridge::State::Open);
         break;
 
     case SessionState::Inactive:
         m_sessionState = state;
@@ -141,38 +167,65 @@ void ReplayController::setSessionState(SessionState state)
 
     case SessionState::Replaying:
         ASSERT(state == SessionState::Inactive);
 
         m_sessionState = state;
         m_page.userInputBridge().setState(UserInputBridge::State::Open);
         break;
     }
 }
 
+void ReplayController::setSegmentState(SegmentState state)
+{
+    ASSERT(state != m_segmentState);
+
+    LOG(WebReplay, "%-20s SegmentState transition: %10s --> %10s.\n", "ReplayController", segmentStateToString(m_segmentState), segmentStateToString(state));
+
+    switch (m_segmentState) {
+    case SegmentState::Appending:
+        ASSERT(state == SegmentState::Unloaded);
+        break;
+
+    case SegmentState::Unloaded:
+        ASSERT(state == SegmentState::Appending || state == SegmentState::Loaded);
+        break;
+
+    case SegmentState::Loaded:
+        ASSERT(state == SegmentState::Unloaded || state == SegmentState::Dispatching);
+        break;
+
+    case SegmentState::Dispatching:
+        ASSERT(state == SegmentState::Loaded);
+        break;
+    }
+
+    m_segmentState = state;
+}
+
 void ReplayController::switchSession(PassRefPtr<ReplaySession> session)
 {
     ASSERT(m_segmentState == SegmentState::Unloaded);
     ASSERT(m_sessionState == SessionState::Inactive);
 
     m_loadedSession = session;
     m_currentPosition = ReplayPosition(0, 0);
 
     LOG(WebReplay, "%-20sSwitching sessions from %p to %p.\n", "ReplayController", m_loadedSession.get(), session.get());
     InspectorInstrumentation::sessionLoaded(&m_page, m_loadedSession);
 }
 
 void ReplayController::createSegment()
 {
     ASSERT(m_sessionState == SessionState::Capturing);
     ASSERT(m_segmentState == SegmentState::Unloaded);
 
-    m_segmentState = SegmentState::Appending;
+    setSegmentState(SegmentState::Appending);
 
     // Create a new segment but don't associate it with the current session
     // until we stop appending to it. This preserves the invariant that
     // segments associated with a replay session have immutable data.
     m_loadedSegment = ReplaySessionSegment::create();
 
     LOG(WebReplay, "%-20s Created segment: %p.\n", "ReplayController", m_loadedSegment.get());
     InspectorInstrumentation::segmentCreated(&m_page, m_loadedSegment);
 
     m_activeCursor = m_loadedSegment->createCapturingCursor(m_page);
@@ -192,21 +245,20 @@ void ReplayController::createSegment()
 
 void ReplayController::completeSegment()
 {
     ASSERT(m_sessionState == SessionState::Capturing);
     ASSERT(m_segmentState == SegmentState::Appending);
 
     m_activeCursor->appendInput<EndSegmentSentinel>();
 
     // Hold on to a reference so unloading the segment doesn't deallocate it.
     RefPtr<ReplaySessionSegment> segment = m_loadedSegment;
-    m_segmentState = SegmentState::Loaded;
     bool shouldSuppressNotifications = true;
     unloadSegment(shouldSuppressNotifications);
 
     LOG(WebReplay, "%-20s Completed segment: %p.\n", "ReplayController", segment.get());
     InspectorInstrumentation::segmentCompleted(&m_page, segment);
 
     m_loadedSession->appendSegment(segment);
     InspectorInstrumentation::sessionModified(&m_page, m_loadedSession);
 }
 
@@ -214,37 +266,37 @@ void ReplayController::loadSegmentAtIndex(size_t segmentIndex)
 {
     ASSERT(segmentIndex < m_loadedSession->size());
     RefPtr<ReplaySessionSegment> segment = m_loadedSession->at(segmentIndex);
 
     ASSERT(m_sessionState == SessionState::Replaying);
     ASSERT(m_segmentState == SegmentState::Unloaded);
     ASSERT(segment);
     ASSERT(!m_loadedSegment);
 
     m_loadedSegment = segment;
-    m_segmentState = SegmentState::Loaded;
+    setSegmentState(SegmentState::Loaded);
 
     m_currentPosition.segmentOffset = segmentIndex;
     m_currentPosition.inputOffset = 0;
 
     m_activeCursor = m_loadedSegment->createReplayingCursor(m_page, this);
 
     LOG(WebReplay, "%-20sLoading segment: %p.\n", "ReplayController", segment.get());
     InspectorInstrumentation::segmentLoaded(&m_page, segment);
 }
 
 void ReplayController::unloadSegment(bool suppressNotifications)
 {
     ASSERT(m_sessionState != SessionState::Inactive);
-    ASSERT(m_segmentState == SegmentState::Loaded);
+    ASSERT(m_segmentState == SegmentState::Loaded || m_segmentState == SegmentState::Appending);
 
-    m_segmentState = SegmentState::Unloaded;
+    setSegmentState(SegmentState::Unloaded);
 
     LOG(WebReplay, "%-20s Clearing input cursors for page: %p\n", "ReplayController", &m_page);
 
     m_activeCursor = nullptr;
     RefPtr<ReplaySessionSegment> unloadedSegment = m_loadedSegment.release();
     for (Frame* frame = &m_page.mainFrame(); frame; frame = frame->tree().traverseNext()) {
         frame->script().globalObject(mainThreadNormalWorld())->setInputCursor(m_emptyCursor);
         frame->document()->setInputCursor(m_emptyCursor);
     }
 
@@ -284,38 +336,38 @@ void ReplayController::stopCapturing()
 
     LOG(WebReplay, "%-20s Stopping capture.\n", "ReplayController");
     InspectorInstrumentation::captureStopped(&m_page);
 }
 
 void ReplayController::startPlayback()
 {
     ASSERT(m_sessionState == SessionState::Replaying);
     ASSERT(m_segmentState == SegmentState::Loaded);
 
-    m_segmentState = SegmentState::Dispatching;
+    setSegmentState(SegmentState::Dispatching);
 
     LOG(WebReplay, "%-20s Starting playback to position (segment: %d, input: %d).\n", "ReplayController", m_targetPosition.segmentOffset, m_targetPosition.inputOffset);
     InspectorInstrumentation::playbackStarted(&m_page);
 
     dispatcher().setDispatchSpeed(m_dispatchSpeed);
     dispatcher().run();
 }
 
 void ReplayController::pausePlayback()
 {
     ASSERT(m_sessionState == SessionState::Replaying);
     ASSERT(m_segmentState == SegmentState::Dispatching);
 
     if (dispatcher().isRunning())
         dispatcher().pause();
 
-    m_segmentState = SegmentState::Loaded;
+    setSegmentState(SegmentState::Loaded);
 
     LOG(WebReplay, "%-20s Pausing playback at position (segment: %d, input: %d).\n", "ReplayController", m_currentPosition.segmentOffset, m_currentPosition.inputOffset);
     InspectorInstrumentation::playbackPaused(&m_page, m_currentPosition);
 }
 
 void ReplayController::cancelPlayback()
 {
     ASSERT(m_sessionState == SessionState::Replaying);
     ASSERT(m_segmentState != SegmentState::Appending);
 
@@ -409,24 +461,28 @@ void ReplayController::willDispatchEvent(const Event& event, Frame* frame)
         return;
 
     Document* document = frame ? frame->document() : nullptr;
     // Fetch the document from the event target, because the target could be detached.
     if (Node* node = target->toNode())
         document = node->inDocument() ? &node->document() : node->ownerDocument();
     else if (DOMWindow* window = target->toDOMWindow())
         document = window->document();
 
     ASSERT(document);
-
     InputCursor& cursor = document->inputCursor();
+
+#if !LOG_DISABLED
     bool eventIsUnrelated = !cursor.isCapturing() && !cursor.isReplaying();
     logDispatchedDOMEvent(event, eventIsUnrelated);
+#else
+    UNUSED_PARAM(cursor);
+#endif
 
 #if ENABLE_AGGRESSIVE_DETERMINISM_CHECKS
     // To ensure deterministic JS execution, all DOM events must be dispatched deterministically.
     // If these assertions fail, then this DOM event is being dispatched by a nondeterministic EventLoop
     // cycle, and may cause program execution to diverge if any JS code runs because of the DOM event.
     if (cursor.isCapturing())
         ASSERT(static_cast<CapturingInputCursor&>(cursor).withinEventLoopInputExtent());
     else if (cursor.isReplaying())
         ASSERT(dispatcher().isDispatching());
 #endif
diff --git a/Source/WebCore/replay/ReplayController.h b/Source/WebCore/replay/ReplayController.h
index 478dab2..70a60d8 100644
--- a/Source/WebCore/replay/ReplayController.h
+++ b/Source/WebCore/replay/ReplayController.h
@@ -154,20 +154,21 @@ private:
 
     void createSegment();
     void completeSegment();
 
     void loadSegmentAtIndex(size_t);
     void unloadSegment(bool suppressNotifications = false);
 
     EventLoopInputDispatcher& dispatcher() const;
 
     void setSessionState(SessionState);
+    void setSegmentState(SegmentState);
     void setForceDeterministicSettings(bool);
 
     struct SavedSettings {
         bool usesMemoryCache;
         bool usesPageCache;
 
         SavedSettings()
             : usesMemoryCache(false)
             , usesPageCache(false)
         { }
-- 
2.0.1

