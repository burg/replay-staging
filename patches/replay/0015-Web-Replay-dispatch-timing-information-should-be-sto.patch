From 517a9b231d4052d7f0de50fa3a86f74ded9a391f Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Fri, 25 Jul 2014 11:20:00 -0700
Subject: [PATCH] Web Replay: dispatch timing information should be stored
 out-of-line in a replay segment
 https://bugs.webkit.org/show_bug.cgi?id=135295

Reviewed by NOBODY (OOPS!).

We need to save a timestamp for each event loop input so that replay can
simulate the original user and network delays. Currently that timestamp
is stored on each EventLoopInput instance.

This patch stores timestamp data in a separate vector attached to the segment.
The event loop input class is now immutable, and new auxiliary data can be added
without adding members to the EventLoopInput class.

As part of the refactoring, InputCursors now keep a reference to the relevant
session segment instead of a reference to their input storage. InputCursors can
be created directly, instead of through ReplaySessionSegment.

No new tests. No behavior was changed.

* inspector/InspectorReplayAgent.cpp:
(WebCore::buildInspectorObjectForInput): Don't send the timestamp with the input.
(WebCore::buildInspectorObjectForSegment):
* inspector/protocol/Replay.json: Remove optional timestamp field for ReplayInput.
* replay/CapturingInputCursor.cpp:
(WebCore::CapturingInputCursor::CapturingInputCursor):
(WebCore::CapturingInputCursor::create):
(WebCore::CapturingInputCursor::storeInput): Save event loop input timings here.
* replay/CapturingInputCursor.h:
* replay/EventLoopInput.h:
(WebCore::EventLoopInputBase::EventLoopInputBase): Deleted.
(WebCore::EventLoopInputBase::timestamp): Deleted.
(WebCore::EventLoopInputBase::setTimestamp): Deleted.
* replay/EventLoopInputDispatcher.cpp: Use a struct for dispatch information.
(WebCore::EventLoopInputDispatcher::EventLoopInputDispatcher):
(WebCore::EventLoopInputDispatcher::dispatchInputSoon):
(WebCore::EventLoopInputDispatcher::dispatchInput):
* replay/EventLoopInputDispatcher.h:
* replay/FunctorInputCursor.h:
(WebCore::FunctorInputCursor::forEachInputInQueue):
(WebCore::FunctorInputCursor::FunctorInputCursor):
* replay/ReplayController.cpp:
(WebCore::ReplayController::createSegment):
(WebCore::ReplayController::loadSegmentAtIndex):
(WebCore::ReplayController::unloadSegment): Deleted.
(WebCore::ReplayController::startPlayback): Deleted.
* replay/ReplaySessionSegment.cpp:
(WebCore::ReplaySessionSegment::createCapturingCursor): Deleted.
(WebCore::ReplaySessionSegment::createReplayingCursor): Deleted.
(WebCore::ReplaySessionSegment::createFunctorCursor): Deleted.
* replay/ReplaySessionSegment.h:
(WebCore::ReplaySessionSegment::storage):
(WebCore::ReplaySessionSegment::eventLoopTimings):
* replay/ReplayingInputCursor.cpp:
(WebCore::ReplayingInputCursor::ReplayingInputCursor):
(WebCore::ReplayingInputCursor::create):
(WebCore::ReplayingInputCursor::uncheckedLoadInput):
(WebCore::ReplayingInputCursor::loadEventLoopInput): Added. This method collates
and returns the next event loop input with its associated dispatch information.
* replay/ReplayingInputCursor.h:
---
 Source/WebCore/ChangeLog                           | 62 ++++++++++++++++++++++
 Source/WebCore/inspector/InspectorReplayAgent.cpp  |  5 +-
 Source/WebCore/inspector/protocol/Replay.json      |  1 -
 Source/WebCore/replay/CapturingInputCursor.cpp     | 22 +++++---
 Source/WebCore/replay/CapturingInputCursor.h       | 14 ++---
 Source/WebCore/replay/EventLoopInput.h             | 10 ----
 Source/WebCore/replay/EventLoopInputDispatcher.cpp | 27 +++++-----
 Source/WebCore/replay/EventLoopInputDispatcher.h   |  6 +--
 Source/WebCore/replay/FunctorInputCursor.h         | 17 +++---
 Source/WebCore/replay/ReplayController.cpp         |  4 +-
 Source/WebCore/replay/ReplaySessionSegment.cpp     | 19 +------
 Source/WebCore/replay/ReplaySessionSegment.h       | 14 +++--
 Source/WebCore/replay/ReplayingInputCursor.cpp     | 26 ++++++---
 Source/WebCore/replay/ReplayingInputCursor.h       | 20 ++++---
 14 files changed, 161 insertions(+), 86 deletions(-)

diff --git a/Source/WebCore/ChangeLog b/Source/WebCore/ChangeLog
index 2415082..87d121f 100644
--- a/Source/WebCore/ChangeLog
+++ b/Source/WebCore/ChangeLog
@@ -1,10 +1,72 @@
+2014-07-25  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Replay: dispatch timing information should be stored out-of-line in a replay segment
+        https://bugs.webkit.org/show_bug.cgi?id=135295
+
+        Reviewed by NOBODY (OOPS!).
+
+        We need to save a timestamp for each event loop input so that replay can
+        simulate the original user and network delays. Currently that timestamp
+        is stored on each EventLoopInput instance.
+
+        This patch stores timestamp data in a separate vector attached to the segment.
+        The event loop input class is now immutable, and new auxiliary data can be added
+        without adding members to the EventLoopInput class.
+
+        As part of the refactoring, InputCursors now keep a reference to the relevant
+        session segment instead of a reference to their input storage. InputCursors can
+        be created directly, instead of through ReplaySessionSegment.
+
+        No new tests. No behavior was changed.
+
+        * inspector/InspectorReplayAgent.cpp:
+        (WebCore::buildInspectorObjectForInput): Don't send the timestamp with the input.
+        (WebCore::buildInspectorObjectForSegment):
+        * inspector/protocol/Replay.json: Remove optional timestamp field for ReplayInput.
+        * replay/CapturingInputCursor.cpp:
+        (WebCore::CapturingInputCursor::CapturingInputCursor):
+        (WebCore::CapturingInputCursor::create):
+        (WebCore::CapturingInputCursor::storeInput): Save event loop input timings here.
+        * replay/CapturingInputCursor.h:
+        * replay/EventLoopInput.h:
+        (WebCore::EventLoopInputBase::EventLoopInputBase): Deleted.
+        (WebCore::EventLoopInputBase::timestamp): Deleted.
+        (WebCore::EventLoopInputBase::setTimestamp): Deleted.
+        * replay/EventLoopInputDispatcher.cpp: Use a struct for dispatch information.
+        (WebCore::EventLoopInputDispatcher::EventLoopInputDispatcher):
+        (WebCore::EventLoopInputDispatcher::dispatchInputSoon):
+        (WebCore::EventLoopInputDispatcher::dispatchInput):
+        * replay/EventLoopInputDispatcher.h:
+        * replay/FunctorInputCursor.h:
+        (WebCore::FunctorInputCursor::forEachInputInQueue):
+        (WebCore::FunctorInputCursor::FunctorInputCursor):
+        * replay/ReplayController.cpp:
+        (WebCore::ReplayController::createSegment):
+        (WebCore::ReplayController::loadSegmentAtIndex):
+        (WebCore::ReplayController::unloadSegment): Deleted.
+        (WebCore::ReplayController::startPlayback): Deleted.
+        * replay/ReplaySessionSegment.cpp:
+        (WebCore::ReplaySessionSegment::createCapturingCursor): Deleted.
+        (WebCore::ReplaySessionSegment::createReplayingCursor): Deleted.
+        (WebCore::ReplaySessionSegment::createFunctorCursor): Deleted.
+        * replay/ReplaySessionSegment.h:
+        (WebCore::ReplaySessionSegment::storage):
+        (WebCore::ReplaySessionSegment::eventLoopTimings):
+        * replay/ReplayingInputCursor.cpp:
+        (WebCore::ReplayingInputCursor::ReplayingInputCursor):
+        (WebCore::ReplayingInputCursor::create):
+        (WebCore::ReplayingInputCursor::uncheckedLoadInput):
+        (WebCore::ReplayingInputCursor::loadEventLoopInput): Added. This method collates
+        and returns the next event loop input with its associated dispatch information.
+        * replay/ReplayingInputCursor.h:
+
 2014-07-24  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Inspector: convert ReplayManager to a promise-based API
         https://bugs.webkit.org/show_bug.cgi?id=135249
 
         Reviewed by NOBODY (OOPS!).
 
         Fix some assertions to match ReplayController's preconditions.
 
         * inspector/InspectorReplayAgent.cpp:
diff --git a/Source/WebCore/inspector/InspectorReplayAgent.cpp b/Source/WebCore/inspector/InspectorReplayAgent.cpp
index 6c78ea4e..1586493 100644
--- a/Source/WebCore/inspector/InspectorReplayAgent.cpp
+++ b/Source/WebCore/inspector/InspectorReplayAgent.cpp
@@ -64,23 +64,20 @@ static PassRefPtr<TypeBuilder::Replay::ReplayPosition> buildInspectorObjectForPo
 }
 
 static PassRefPtr<TypeBuilder::Replay::ReplayInput> buildInspectorObjectForInput(const NondeterministicInputBase& input, size_t offset)
 {
     EncodedValue encodedInput = EncodingTraits<NondeterministicInputBase>::encodeValue(input);
     RefPtr<TypeBuilder::Replay::ReplayInput> inputObject = TypeBuilder::Replay::ReplayInput::create()
         .setType(input.type())
         .setOffset(offset)
         .setData(encodedInput.asObject());
 
-    if (input.queue() == InputQueue::EventLoopInput)
-        inputObject->setTimestamp(static_cast<const EventLoopInputBase&>(input).timestamp());
-
     return inputObject.release();
 }
 
 static PassRefPtr<TypeBuilder::Replay::ReplaySession> buildInspectorObjectForSession(PassRefPtr<ReplaySession> prpSession)
 {
     RefPtr<ReplaySession> session = prpSession;
     RefPtr<TypeBuilder::Array<SegmentIdentifier>> segments = TypeBuilder::Array<SegmentIdentifier>::create();
 
     for (auto it = session->begin(); it != session->end(); ++it)
         segments->addItem((*it)->identifier());
@@ -134,21 +131,21 @@ private:
 };
 
 static PassRefPtr<TypeBuilder::Replay::SessionSegment> buildInspectorObjectForSegment(PassRefPtr<ReplaySessionSegment> prpSegment)
 {
     RefPtr<ReplaySessionSegment> segment = prpSegment;
     RefPtr<TypeBuilder::Array<TypeBuilder::Replay::ReplayInputQueue>> queuesObject = TypeBuilder::Array<TypeBuilder::Replay::ReplayInputQueue>::create();
 
     for (size_t i = 0; i < static_cast<size_t>(InputQueue::Count); i++) {
         SerializeInputToJSONFunctor collector;
         InputQueue queue = static_cast<InputQueue>(i);
-        RefPtr<FunctorInputCursor> functorCursor = segment->createFunctorCursor();
+        RefPtr<FunctorInputCursor> functorCursor = FunctorInputCursor::create(segment);
         RefPtr<TypeBuilder::Array<TypeBuilder::Replay::ReplayInput>> queueInputs = functorCursor->forEachInputInQueue(queue, collector);
 
         RefPtr<TypeBuilder::Replay::ReplayInputQueue> queueObject = TypeBuilder::Replay::ReplayInputQueue::create()
             .setType(EncodingTraits<InputQueue>::encodeValue(queue).convertTo<String>())
             .setInputs(queueInputs);
 
         queuesObject->addItem(queueObject.release());
     }
 
     RefPtr<TypeBuilder::Replay::SessionSegment> segmentObject = TypeBuilder::Replay::SessionSegment::create()
diff --git a/Source/WebCore/inspector/protocol/Replay.json b/Source/WebCore/inspector/protocol/Replay.json
index 65ba289..1c9a7a5 100644
--- a/Source/WebCore/inspector/protocol/Replay.json
+++ b/Source/WebCore/inspector/protocol/Replay.json
@@ -27,21 +27,20 @@
                { "name": "segmentOffset", "type": "integer", "description": "Offset for a segment within the currently-loaded replay session." },
                { "name": "inputOffset", "type": "integer", "description": "Offset for an event loop input within the specified session segment." }
             ]
         },
         {
             "id": "ReplayInput",
             "type": "object",
             "properties": [
                 { "name": "type", "type": "string", "description": "Input type." },
                 { "name": "offset", "type": "integer", "description": "Offset of this input in its respective queue."},
-                { "name": "timestamp", "type": "number", "optional": true, "description": "The timestamp of this input." },
                 { "name": "data", "type": "object", "description": "Per-input payload." }
             ]
         },
         {
             "id": "ReplayInputQueue",
             "type": "object",
             "properties": [
                 { "name": "type", "type": "string", "description": "Queue type" },
                 { "name": "inputs", "type": "array", "items": { "$ref": "ReplayInput"}, "description": "Inputs belonging to this queue." }
             ]
diff --git a/Source/WebCore/replay/CapturingInputCursor.cpp b/Source/WebCore/replay/CapturingInputCursor.cpp
index daa06bc..40db3b6 100644
--- a/Source/WebCore/replay/CapturingInputCursor.cpp
+++ b/Source/WebCore/replay/CapturingInputCursor.cpp
@@ -23,46 +23,56 @@
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "CapturingInputCursor.h"
 
 #if ENABLE(WEB_REPLAY)
 
+#include "EventLoopInput.h"
 #include "Logging.h"
+#include "ReplaySessionSegment.h"
 #include "SegmentedInputStorage.h"
+#include <wtf/CurrentTime.h>
 
 namespace WebCore {
 
-CapturingInputCursor::CapturingInputCursor(SegmentedInputStorage& storage)
-    : m_storage(storage)
+CapturingInputCursor::CapturingInputCursor(PassRefPtr<ReplaySessionSegment> segment)
+    : m_segment(segment)
     , m_withinEventLoopInputExtent(false)
 {
     LOG(WebReplay, "%-30sCreated capture cursor=%p.\n", "[ReplayController]", this);
 }
 
 CapturingInputCursor::~CapturingInputCursor()
 {
     LOG(WebReplay, "%-30sDestroyed capture cursor=%p.\n", "[ReplayController]", this);
 }
 
-PassRefPtr<CapturingInputCursor> CapturingInputCursor::create(SegmentedInputStorage& storage)
+PassRefPtr<CapturingInputCursor> CapturingInputCursor::create(PassRefPtr<ReplaySessionSegment> segment)
 {
-    return adoptRef(new CapturingInputCursor(storage));
+    return adoptRef(new CapturingInputCursor(segment));
 }
 
 void CapturingInputCursor::storeInput(std::unique_ptr<NondeterministicInputBase> input)
 {
-    ASSERT(input);
-    m_storage.store(WTF::move(input));
+    ASSERT_ARG(input, input);
+
+    if (input->queue() == InputQueue::EventLoopInput) {
+        // FIXME: rewrite this (and related dispatch code) to use std::chrono.
+        double now = monotonicallyIncreasingTime();
+        m_segment->eventLoopTimings().append(now);
+    }
+
+    m_segment->storage().store(WTF::move(input));
 }
 
 NondeterministicInputBase* CapturingInputCursor::loadInput(InputQueue, const AtomicString&)
 {
     // Can't load inputs from capturing cursor.
     ASSERT_NOT_REACHED();
     return nullptr;
 }
 
 NondeterministicInputBase* CapturingInputCursor::uncheckedLoadInput(InputQueue)
diff --git a/Source/WebCore/replay/CapturingInputCursor.h b/Source/WebCore/replay/CapturingInputCursor.h
index fc7289a..59e6d4c 100644
--- a/Source/WebCore/replay/CapturingInputCursor.h
+++ b/Source/WebCore/replay/CapturingInputCursor.h
@@ -29,41 +29,43 @@
 #define CapturingInputCursor_h
 
 #if ENABLE(WEB_REPLAY)
 
 #include <replay/InputCursor.h>
 #include <wtf/Noncopyable.h>
 
 namespace WebCore {
 
 class EventLoopInputExtent;
-class SegmentedInputStorage;
+class Page;
+class ReplaySessionSegment;
 
 class CapturingInputCursor final : public InputCursor {
     WTF_MAKE_NONCOPYABLE(CapturingInputCursor);
 public:
-    static PassRefPtr<CapturingInputCursor> create(SegmentedInputStorage&);
+    static PassRefPtr<CapturingInputCursor> create(PassRefPtr<ReplaySessionSegment>);
     virtual ~CapturingInputCursor();
 
     virtual bool isCapturing() const override { return true; }
     virtual bool isReplaying() const override { return false; }
 
     void setWithinEventLoopInputExtent(bool);
     bool withinEventLoopInputExtent() const { return m_withinEventLoopInputExtent; }
 
-    virtual NondeterministicInputBase* uncheckedLoadInput(InputQueue) override;
-    virtual void storeInput(std::unique_ptr<NondeterministicInputBase>) override;
 protected:
     virtual NondeterministicInputBase* loadInput(InputQueue, const AtomicString& type) override;
 
 private:
-    explicit CapturingInputCursor(SegmentedInputStorage&);
+    CapturingInputCursor(PassRefPtr<ReplaySessionSegment>);
+
+    virtual NondeterministicInputBase* uncheckedLoadInput(InputQueue) override;
+    virtual void storeInput(std::unique_ptr<NondeterministicInputBase>) override;
 
-    SegmentedInputStorage& m_storage;
+    RefPtr<ReplaySessionSegment> m_segment;
     bool m_withinEventLoopInputExtent;
 };
 
 } // namespace WebCore
 
 #endif // ENABLE(WEB_REPLAY)
 
 #endif // CapturingInputCursor_h
diff --git a/Source/WebCore/replay/EventLoopInput.h b/Source/WebCore/replay/EventLoopInput.h
index 0795d53..250a3db 100644
--- a/Source/WebCore/replay/EventLoopInput.h
+++ b/Source/WebCore/replay/EventLoopInput.h
@@ -48,34 +48,24 @@ class EventLoopInputExtent {
     WTF_MAKE_NONCOPYABLE(EventLoopInputExtent);
 public:
     EventLoopInputExtent(JSC::InputCursor&);
     ~EventLoopInputExtent();
 private:
     JSC::InputCursor& m_cursor;
 };
 
 class EventLoopInputBase : public NondeterministicInputBase {
 public:
-    EventLoopInputBase()
-        : m_timestamp(monotonicallyIncreasingTime())
-    {
-    }
-
     virtual ~EventLoopInputBase() { }
     virtual InputQueue queue() const override final { return InputQueue::EventLoopInput; }
 
     virtual void dispatch(ReplayController&) = 0;
-
-    double timestamp() const { return m_timestamp; }
-    void setTimestamp(double timestamp) { m_timestamp = timestamp; }
-protected:
-    double m_timestamp;
 };
 
 template <typename InputType>
 class EventLoopInput : public EventLoopInputBase {
     virtual const AtomicString& type() const override final
     {
         return InputTraits<InputType>::type();
     }
 };
 
diff --git a/Source/WebCore/replay/EventLoopInputDispatcher.cpp b/Source/WebCore/replay/EventLoopInputDispatcher.cpp
index 8502197..7f23a15 100644
--- a/Source/WebCore/replay/EventLoopInputDispatcher.cpp
+++ b/Source/WebCore/replay/EventLoopInputDispatcher.cpp
@@ -42,27 +42,28 @@
 #include <wtf/text/CString.h>
 #endif
 
 namespace WebCore {
 
 EventLoopInputDispatcher::EventLoopInputDispatcher(Page& page, ReplayingInputCursor& cursor, EventLoopInputDispatcherClient* client)
     : m_page(page)
     , m_client(client)
     , m_cursor(cursor)
     , m_timer(this, &EventLoopInputDispatcher::timerFired)
-    , m_runningInput(nullptr)
     , m_dispatching(false)
     , m_running(false)
     , m_speed(DispatchSpeed::FastForward)
     , m_previousDispatchStartTime(0.0)
     , m_previousInputTimestamp(0.0)
 {
+    m_currentWork.input = nullptr;
+    m_currentWork.timestamp = 0.0;
 }
 
 void EventLoopInputDispatcher::run()
 {
     ASSERT(!m_running);
     m_running = true;
 
     LOG(WebReplay, "%-20s Starting dispatch of event loop inputs for page: %p\n", "ReplayEvents", &m_page);
     dispatchInputSoon();
 }
@@ -81,86 +82,86 @@ void EventLoopInputDispatcher::pause()
 void EventLoopInputDispatcher::timerFired(Timer<EventLoopInputDispatcher>*)
 {
     dispatchInput();
 }
 
 void EventLoopInputDispatcher::dispatchInputSoon()
 {
     ASSERT(m_running);
 
     // We may already have an input if replay was paused just before dispatching.
-    if (!m_runningInput)
-        m_runningInput = static_cast<EventLoopInputBase*>(m_cursor.uncheckedLoadInput(InputQueue::EventLoopInput));
+    if (!m_currentWork.input)
+        m_currentWork = m_cursor.loadEventLoopInput();
 
     if (m_timer.isActive())
         m_timer.stop();
 
     double waitInterval = 0;
 
     if (m_speed == DispatchSpeed::RealTime) {
         // The goal is to reproduce the dispatch delay between inputs as it was
         // was observed during the recording. So, we need to compute how much time
         // to wait such that the elapsed time plus the wait time will equal the
         // observed delay between the previous and current input.
 
         if (!m_previousInputTimestamp)
-            m_previousInputTimestamp = m_runningInput->timestamp();
+            m_previousInputTimestamp = m_currentWork.timestamp;
 
-        double targetInterval = m_runningInput->timestamp() - m_previousInputTimestamp;
+        double targetInterval = m_currentWork.timestamp - m_previousInputTimestamp;
         double elapsed = monotonicallyIncreasingTime() - m_previousDispatchStartTime;
         waitInterval = targetInterval - elapsed;
     }
 
     // A negative wait time means that dispatch took longer on replay than on
     // capture. In this case, proceed without waiting at all.
     if (waitInterval < 0)
         waitInterval = 0;
 
     if (waitInterval > 1000.0) {
         LOG_ERROR("%-20s Tried to wait for over 1000 seconds before dispatching next event loop input; this is probably a bug.", "ReplayEvents");
         waitInterval = 0;
     }
 
     LOG(WebReplay, "%-20s (WAIT: %.3f ms)", "ReplayEvents", waitInterval * 1000.0);
     m_timer.startOneShot(waitInterval);
 }
 
 void EventLoopInputDispatcher::dispatchInput()
 {
-    ASSERT(m_runningInput);
+    ASSERT(m_currentWork.input);
     ASSERT(!m_dispatching);
 
     if (m_speed == DispatchSpeed::RealTime) {
         m_previousDispatchStartTime = monotonicallyIncreasingTime();
-        m_previousInputTimestamp = m_runningInput->timestamp();
+        m_previousInputTimestamp = m_currentWork.timestamp;
     }
 
 #if !LOG_DISABLED
-    EncodedValue encodedInput = EncodingTraits<NondeterministicInputBase>::encodeValue(*m_runningInput);
+    EncodedValue encodedInput = EncodingTraits<NondeterministicInputBase>::encodeValue(*m_currentWork.input);
     String jsonString = encodedInput.asObject()->toJSONString();
 
     LOG(WebReplay, "%-20s ----------------------------------------------", "ReplayEvents");
-    LOG(WebReplay, "%-20s >DISPATCH: %s %s\n", "ReplayEvents", m_runningInput->type().string().utf8().data(), jsonString.utf8().data());
+    LOG(WebReplay, "%-20s >DISPATCH: %s %s\n", "ReplayEvents", m_currentWork.input->type().string().utf8().data(), jsonString.utf8().data());
 #endif
 
-    m_client->willDispatchInput(*m_runningInput);
+    m_client->willDispatchInput(*m_currentWork.input);
     // Client could stop replay in the previous callback, so check again.
     if (!m_running)
         return;
 
     {
         TemporaryChange<bool> change(m_dispatching, true);
-        m_runningInput->dispatch(m_page.replayController());
+        m_currentWork.input->dispatch(m_page.replayController());
     }
 
-    EventLoopInputBase* dispatchedInput = m_runningInput;
-    m_runningInput = nullptr;
+    EventLoopInputBase* dispatchedInput = m_currentWork.input;
+    m_currentWork.input = nullptr;
 
     // Notify clients that the event was dispatched.
     m_client->didDispatchInput(*dispatchedInput);
     if (dispatchedInput->type() == inputTypes().EndSegmentSentinel) {
         m_running = false;
         m_dispatching = false;
         m_client->didDispatchFinalInput();
         return;
     }
 
diff --git a/Source/WebCore/replay/EventLoopInputDispatcher.h b/Source/WebCore/replay/EventLoopInputDispatcher.h
index d641361..f43062e 100644
--- a/Source/WebCore/replay/EventLoopInputDispatcher.h
+++ b/Source/WebCore/replay/EventLoopInputDispatcher.h
@@ -24,29 +24,29 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef EventLoopInputDispatcher_h
 #define EventLoopInputDispatcher_h
 
 #if ENABLE(WEB_REPLAY)
 
 #include "EventLoopInput.h"
+#include "ReplayingInputCursor.h"
 #include "Timer.h"
 #include <wtf/Noncopyable.h>
 #include <wtf/Vector.h>
 #include <wtf/text/WTFString.h>
 
 namespace WebCore {
 
 class Page;
-class ReplayingInputCursor;
 
 enum class DispatchSpeed {
     RealTime,
     FastForward,
 };
 
 class EventLoopInputDispatcherClient {
 public:
     EventLoopInputDispatcherClient() { }
     virtual ~EventLoopInputDispatcherClient() { }
@@ -72,22 +72,22 @@ public:
 private:
     void dispatchInputSoon();
     void dispatchInput();
     void timerFired(Timer<EventLoopInputDispatcher>*);
 
     Page& m_page;
     EventLoopInputDispatcherClient* m_client;
     ReplayingInputCursor& m_cursor;
     Timer<EventLoopInputDispatcher> m_timer;
 
-    // This pointer is valid when an event loop input is presently dispatching.
-    EventLoopInputBase* m_runningInput;
+    // This data is valid when an event loop input is presently dispatching.
+    EventLoopInputData m_currentWork;
     // Whether the dispatcher is currently calling out to an inputs' dispatch() method.
     bool m_dispatching;
     // Whether the dispatcher is waiting to dispatch or actively dispatching inputs.
     bool m_running;
 
     DispatchSpeed m_speed;
     // The time at which the last input dispatch() method was called.
     double m_previousDispatchStartTime;
     // The timestamp specified by the last dispatched input.
     double m_previousInputTimestamp;
diff --git a/Source/WebCore/replay/FunctorInputCursor.h b/Source/WebCore/replay/FunctorInputCursor.h
index d07821d..c8df903 100644
--- a/Source/WebCore/replay/FunctorInputCursor.h
+++ b/Source/WebCore/replay/FunctorInputCursor.h
@@ -23,65 +23,66 @@
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef FunctorInputCursor_h
 #define FunctorInputCursor_h
 
 #if ENABLE(WEB_REPLAY)
 
+#include "ReplaySessionSegment.h"
 #include "SegmentedInputStorage.h"
 #include <replay/InputCursor.h>
 #include <replay/NondeterministicInput.h>
 #include <wtf/Assertions.h>
 #include <wtf/Noncopyable.h>
 #include <wtf/Vector.h>
 
 namespace WebCore {
 
 class FunctorInputCursor final : public InputCursor {
     WTF_MAKE_NONCOPYABLE(FunctorInputCursor);
 public:
-    static PassRefPtr<FunctorInputCursor> create(SegmentedInputStorage& storage)
+    static PassRefPtr<FunctorInputCursor> create(PassRefPtr<ReplaySessionSegment> segment)
     {
-        return adoptRef(new FunctorInputCursor(storage));
+        return adoptRef(new FunctorInputCursor(segment));
     }
 
     // InputCursor
     virtual bool isCapturing() const override { return false; }
     virtual bool isReplaying() const override { return false; }
 
     virtual void storeInput(std::unique_ptr<NondeterministicInputBase>) override;
     virtual NondeterministicInputBase* uncheckedLoadInput(InputQueue) override;
 
     template<typename Functor>
     typename Functor::ReturnType forEachInputInQueue(InputQueue, Functor&);
 protected:
     virtual NondeterministicInputBase* loadInput(InputQueue, const AtomicString&) override;
 private:
-    FunctorInputCursor(SegmentedInputStorage&);
+    FunctorInputCursor(PassRefPtr<ReplaySessionSegment>);
 
-    SegmentedInputStorage& m_storage;
+    RefPtr<ReplaySessionSegment> m_segment;
 };
 
 template<typename Functor> inline
 typename Functor::ReturnType FunctorInputCursor::forEachInputInQueue(InputQueue queue, Functor& functor)
 {
-    for (size_t i = 0; i < m_storage.queueSize(queue); i++)
-        functor(i, m_storage.queue(queue).at(i).get());
+    for (size_t i = 0; i < m_segment->storage().queueSize(queue); i++)
+        functor(i, m_segment->storage().queue(queue).at(i).get());
 
     return functor.returnValue();
 }
 
-inline FunctorInputCursor::FunctorInputCursor(SegmentedInputStorage& storage)
-    : m_storage(storage)
+inline FunctorInputCursor::FunctorInputCursor(PassRefPtr<ReplaySessionSegment> segment)
+    : m_segment(segment)
 {
 }
 
 inline void FunctorInputCursor::storeInput(std::unique_ptr<NondeterministicInputBase>)
 {
     ASSERT_NOT_REACHED();
 }
 
 inline NondeterministicInputBase* FunctorInputCursor::loadInput(InputQueue, const AtomicString&)
 {
diff --git a/Source/WebCore/replay/ReplayController.cpp b/Source/WebCore/replay/ReplayController.cpp
index 9cdce32..29e9b5f 100644
--- a/Source/WebCore/replay/ReplayController.cpp
+++ b/Source/WebCore/replay/ReplayController.cpp
@@ -221,21 +221,21 @@ void ReplayController::createSegment()
     setSegmentState(SegmentState::Appending);
 
     // Create a new segment but don't associate it with the current session
     // until we stop appending to it. This preserves the invariant that
     // segments associated with a replay session have immutable data.
     m_loadedSegment = ReplaySessionSegment::create();
 
     LOG(WebReplay, "%-20s Created segment: %p.\n", "ReplayController", m_loadedSegment.get());
     InspectorInstrumentation::segmentCreated(&m_page, m_loadedSegment);
 
-    m_activeCursor = m_loadedSegment->createCapturingCursor(m_page);
+    m_activeCursor = CapturingInputCursor::create(m_loadedSegment);
     m_activeCursor->appendInput<BeginSegmentSentinel>();
 
     // Dispatching this input saves history, clears all but the current item, appends saved
     // history item to the back/forward list, then moves the current item cursor to the last entry.
     std::unique_ptr<InitializeHistory> historyInput = InitializeHistory::createFromPage(m_page);
     historyInput->dispatch(*this);
     m_activeCursor->storeInput(std::move(historyInput));
 
     // Dispatching this input schedules navigation of the main frame, causing a refresh.
     std::unique_ptr<InitialNavigation> navigationInput = InitialNavigation::createFromPage(m_page);
@@ -271,21 +271,21 @@ void ReplayController::loadSegmentAtIndex(size_t segmentIndex)
     ASSERT(m_segmentState == SegmentState::Unloaded);
     ASSERT(segment);
     ASSERT(!m_loadedSegment);
 
     m_loadedSegment = segment;
     setSegmentState(SegmentState::Loaded);
 
     m_currentPosition.segmentOffset = segmentIndex;
     m_currentPosition.inputOffset = 0;
 
-    m_activeCursor = m_loadedSegment->createReplayingCursor(m_page, this);
+    m_activeCursor = ReplayingInputCursor::create(m_loadedSegment, m_page, this);
 
     LOG(WebReplay, "%-20sLoading segment: %p.\n", "ReplayController", segment.get());
     InspectorInstrumentation::segmentLoaded(&m_page, segment);
 }
 
 void ReplayController::unloadSegment(bool suppressNotifications)
 {
     ASSERT(m_sessionState != SessionState::Inactive);
     ASSERT(m_segmentState == SegmentState::Loaded || m_segmentState == SegmentState::Appending);
 
diff --git a/Source/WebCore/replay/ReplaySessionSegment.cpp b/Source/WebCore/replay/ReplaySessionSegment.cpp
index ab0d477..b90e88f 100644
--- a/Source/WebCore/replay/ReplaySessionSegment.cpp
+++ b/Source/WebCore/replay/ReplaySessionSegment.cpp
@@ -28,20 +28,22 @@
 #include "config.h"
 #include "ReplaySessionSegment.h"
 
 #if ENABLE(WEB_REPLAY)
 
 #include "CapturingInputCursor.h"
 #include "FunctorInputCursor.h"
 #include "ReplayingInputCursor.h"
 #include "SegmentedInputStorage.h"
 #include <wtf/CurrentTime.h>
+#include <wtf/PassRefPtr.h>
+#include <wtf/Vector.h>
 
 namespace WebCore {
 
 static unsigned s_nextSegmentIdentifier = 1;
 
 PassRefPtr<ReplaySessionSegment> ReplaySessionSegment::create()
 {
     return adoptRef(new ReplaySessionSegment);
 }
 
@@ -50,30 +52,13 @@ ReplaySessionSegment::ReplaySessionSegment()
     , m_identifier(s_nextSegmentIdentifier++)
     , m_canCapture(true)
     , m_timestamp(currentTimeMS())
 {
 }
 
 ReplaySessionSegment::~ReplaySessionSegment()
 {
 }
 
-PassRefPtr<CapturingInputCursor> ReplaySessionSegment::createCapturingCursor(Page&)
-{
-    ASSERT(m_canCapture);
-    m_canCapture = false;
-    return CapturingInputCursor::create(*m_storage);
-}
-
-PassRefPtr<ReplayingInputCursor> ReplaySessionSegment::createReplayingCursor(Page& page, EventLoopInputDispatcherClient* client)
-{
-    return ReplayingInputCursor::create(*m_storage, page, client);
-}
-
-PassRefPtr<FunctorInputCursor> ReplaySessionSegment::createFunctorCursor()
-{
-    return FunctorInputCursor::create(*m_storage);
-}
-
 } // namespace WebCore
 
 #endif // ENABLE(WEB_REPLAY)
diff --git a/Source/WebCore/replay/ReplaySessionSegment.h b/Source/WebCore/replay/ReplaySessionSegment.h
index 5de60a1..5d45041 100644
--- a/Source/WebCore/replay/ReplaySessionSegment.h
+++ b/Source/WebCore/replay/ReplaySessionSegment.h
@@ -23,47 +23,53 @@
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef ReplaySessionSegment_h
 #define ReplaySessionSegment_h
 
 #if ENABLE(WEB_REPLAY)
 
-#include <replay/NondeterministicInput.h>
+#include <wtf/Forward.h>
 #include <wtf/RefCounted.h>
+#include <wtf/Vector.h>
 
 namespace WebCore {
 
 class CapturingInputCursor;
 class EventLoopInputDispatcherClient;
 class FunctorInputCursor;
 class Page;
 class ReplayingInputCursor;
 class SegmentedInputStorage;
 
 class ReplaySessionSegment : public RefCounted<ReplaySessionSegment> {
+friend class CapturingInputCursor;
+friend class FunctorInputCursor;
+friend class ReplayingInputCursor;
 public:
     static PassRefPtr<ReplaySessionSegment> create();
     ~ReplaySessionSegment();
 
     unsigned identifier() const { return m_identifier; }
     double timestamp() const { return m_timestamp; }
+protected:
+    SegmentedInputStorage& storage() { return *m_storage; }
+    Vector<double, 0>& eventLoopTimings() { return m_eventLoopTimings; }
 
-    PassRefPtr<CapturingInputCursor> createCapturingCursor(Page&);
-    PassRefPtr<ReplayingInputCursor> createReplayingCursor(Page&, EventLoopInputDispatcherClient*);
-    PassRefPtr<FunctorInputCursor> createFunctorCursor();
 private:
     ReplaySessionSegment();
 
     std::unique_ptr<SegmentedInputStorage> m_storage;
+    Vector<double, 0> m_eventLoopTimings;
+
     unsigned m_identifier;
     bool m_canCapture;
     double m_timestamp;
 };
 
 } // namespace WebCore
 
 #endif // ENABLE(WEB_REPLAY)
 
 #endif // ReplaySessionSegment_h
diff --git a/Source/WebCore/replay/ReplayingInputCursor.cpp b/Source/WebCore/replay/ReplayingInputCursor.cpp
index a4f2db3..1b18c02 100644
--- a/Source/WebCore/replay/ReplayingInputCursor.cpp
+++ b/Source/WebCore/replay/ReplayingInputCursor.cpp
@@ -24,42 +24,43 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "ReplayingInputCursor.h"
 
 #if ENABLE(WEB_REPLAY)
 
 #include "EventLoopInputDispatcher.h"
+#include "ReplaySessionSegment.h"
 #include "SegmentedInputStorage.h"
 #include "SerializationMethods.h"
 #include "WebReplayInputs.h"
 #include <wtf/text/CString.h>
 
 namespace WebCore {
 
-ReplayingInputCursor::ReplayingInputCursor(SegmentedInputStorage& storage, Page& page, EventLoopInputDispatcherClient* client)
-    : m_storage(storage)
+ReplayingInputCursor::ReplayingInputCursor(PassRefPtr<ReplaySessionSegment> segment, Page& page, EventLoopInputDispatcherClient* client)
+    : m_segment(segment)
     , m_dispatcher(std::make_unique<EventLoopInputDispatcher>(page, *this, client))
 {
     for (size_t i = 0; i < static_cast<size_t>(InputQueue::Count); i++)
         m_positions.append(0);
 }
 
 ReplayingInputCursor::~ReplayingInputCursor()
 {
 }
 
-PassRefPtr<ReplayingInputCursor> ReplayingInputCursor::create(SegmentedInputStorage& storage, Page& page, EventLoopInputDispatcherClient* client)
+PassRefPtr<ReplayingInputCursor> ReplayingInputCursor::create(PassRefPtr<ReplaySessionSegment> segment, Page& page, EventLoopInputDispatcherClient* client)
 {
-    return adoptRef(new ReplayingInputCursor(storage, page, client));
+    return adoptRef(new ReplayingInputCursor(segment, page, client));
 }
 
 void ReplayingInputCursor::storeInput(std::unique_ptr<NondeterministicInputBase>)
 {
     // Cannot store inputs from a replaying input cursor.
     ASSERT_NOT_REACHED();
 }
 
 NondeterministicInputBase* ReplayingInputCursor::loadInput(InputQueue queue, const AtomicString& type)
 {
@@ -68,22 +69,35 @@ NondeterministicInputBase* ReplayingInputCursor::loadInput(InputQueue queue, con
     if (input->type() != type) {
         LOG_ERROR("%-25s ERROR: Expected replay input of type %s, but got type %s\n", "[ReplayingInputCursor]", type.string().ascii().data(), input->type().string().ascii().data());
         return nullptr;
     }
 
     return input;
 }
 
 NondeterministicInputBase* ReplayingInputCursor::uncheckedLoadInput(InputQueue queue)
 {
-    if (m_positions[static_cast<size_t>(queue)] >= m_storage.queueSize(queue)) {
+    if (m_positions[static_cast<size_t>(queue)] >= m_segment->storage().queueSize(queue)) {
         String queueString = EncodingTraits<InputQueue>::encodeValue(queue).convertTo<String>();
         LOG_ERROR("%-30s ERROR No more inputs remain for determinism queue %s, but one was requested.", "[ReplayingInputCursor]", queueString.ascii().data());
         return nullptr;
     }
 
-    return m_storage.load(queue, m_positions[static_cast<size_t>(queue)]++);
+    return m_segment->storage().load(queue, m_positions[static_cast<size_t>(queue)]++);
+}
+
+EventLoopInputData ReplayingInputCursor::loadEventLoopInput()
+{
+    ASSERT(m_segment);
+
+    size_t offset = m_positions.at(static_cast<size_t>(InputQueue::EventLoopInput));
+    ASSERT(offset < m_segment->eventLoopTimings().size());
+
+    EventLoopInputData data;
+    data.timestamp = m_segment->eventLoopTimings().at(offset);
+    data.input = static_cast<EventLoopInputBase*>(uncheckedLoadInput(InputQueue::EventLoopInput));
+    return data;
 }
 
 }; // namespace WebCore
 
 #endif // ENABLE(WEB_REPLAY)
diff --git a/Source/WebCore/replay/ReplayingInputCursor.h b/Source/WebCore/replay/ReplayingInputCursor.h
index 14757ba3..9c71f41 100644
--- a/Source/WebCore/replay/ReplayingInputCursor.h
+++ b/Source/WebCore/replay/ReplayingInputCursor.h
@@ -29,43 +29,51 @@
 #define ReplayingInputCursor_h
 
 #if ENABLE(WEB_REPLAY)
 
 #include <replay/InputCursor.h>
 #include <wtf/Vector.h>
 #include <wtf/text/AtomicString.h>
 
 namespace WebCore {
 
+class EventLoopInputBase;
 class EventLoopInputDispatcher;
 class EventLoopInputDispatcherClient;
 class Page;
-class SegmentedInputStorage;
+class ReplaySessionSegment;
+
+struct EventLoopInputData {
+    EventLoopInputBase* input;
+    double timestamp;
+};
 
 class ReplayingInputCursor final : public InputCursor {
     WTF_MAKE_NONCOPYABLE(ReplayingInputCursor);
 public:
-    static PassRefPtr<ReplayingInputCursor> create(SegmentedInputStorage&, Page&, EventLoopInputDispatcherClient*);
+    static PassRefPtr<ReplayingInputCursor> create(PassRefPtr<ReplaySessionSegment>, Page&, EventLoopInputDispatcherClient*);
     virtual ~ReplayingInputCursor();
 
     virtual bool isCapturing() const override { return false; }
     virtual bool isReplaying() const override { return true; }
 
     EventLoopInputDispatcher& dispatcher() const { return *m_dispatcher; }
 
-    virtual void storeInput(std::unique_ptr<NondeterministicInputBase>) override;
-    virtual NondeterministicInputBase* uncheckedLoadInput(InputQueue) override;
+    EventLoopInputData loadEventLoopInput();
 protected:
     virtual NondeterministicInputBase* loadInput(InputQueue, const AtomicString& type) override;
 private:
-    ReplayingInputCursor(SegmentedInputStorage&, Page&, EventLoopInputDispatcherClient*);
+    ReplayingInputCursor(PassRefPtr<ReplaySessionSegment>, Page&, EventLoopInputDispatcherClient*);
+
+    virtual void storeInput(std::unique_ptr<NondeterministicInputBase>) override;
+    virtual NondeterministicInputBase* uncheckedLoadInput(InputQueue) override;
 
-    SegmentedInputStorage& m_storage;
+    RefPtr<ReplaySessionSegment> m_segment;
     std::unique_ptr<EventLoopInputDispatcher> m_dispatcher;
     Vector<size_t> m_positions;
 };
 
 } // namespace WebCore
 
 #endif // ENABLE(WEB_REPLAY)
 
 #endif // ReplayingInputCursor_h
-- 
2.0.1

