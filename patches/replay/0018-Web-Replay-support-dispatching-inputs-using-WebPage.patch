From d0fc6950d03fb288618bb77eefd3c9ebafbc916d Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Thu, 21 Aug 2014 16:12:31 -0700
Subject: [PATCH] Web Replay: support dispatching inputs using WebPage

---
 .../replay/scripts/CodeGeneratorReplayInputs.py    | 44 ++++++++++++++-----
 ...enerate-enum-with-guard.json-TestReplayInputs.h |  2 +-
 Source/WebCore/replay/EventLoopInput.h             | 11 +++--
 .../replay/WebReplayInputDispatchMethods.cpp       | 44 +++++++++----------
 Source/WebKit2/CMakeLists.txt                      | 14 +++---
 Source/WebKit2/WebKit2.xcodeproj/project.pbxproj   |  5 +++
 .../Replay/WKReplayInputDispatchMethods.cpp        | 43 ++++++++++++++++++
 .../WebProcess/Replay/WebEventLoopInput.h}         | 51 +++++++---------------
 .../WebProcess/WebCoreSupport/WebReplayClient.cpp  | 12 ++++-
 9 files changed, 143 insertions(+), 83 deletions(-)
 create mode 100644 Source/WebKit2/WebProcess/Replay/WKReplayInputDispatchMethods.cpp
 copy Source/{WebCore/replay/EventLoopInput.h => WebKit2/WebProcess/Replay/WebEventLoopInput.h} (60%)

diff --git a/Source/JavaScriptCore/replay/scripts/CodeGeneratorReplayInputs.py b/Source/JavaScriptCore/replay/scripts/CodeGeneratorReplayInputs.py
index 9dd6c75..784ee48 100644
--- a/Source/JavaScriptCore/replay/scripts/CodeGeneratorReplayInputs.py
+++ b/Source/JavaScriptCore/replay/scripts/CodeGeneratorReplayInputs.py
@@ -41,29 +41,32 @@ except ImportError:
 # Configuration values are first looked up in the framework configuration,
 # and then in the global configuration if there is no framework-specific value.
 GLOBAL_CONFIG = {
     "baseFilename": "ReplayInputs",
     "guardCondition": "ENABLE(WEB_REPLAY)",
     "traitsFrameworkName": "JavaScriptCore",
 
     # These are formatted as ([allowed_frameworks], (framework, header_path)).
     # The generator can figure out how to format the includes.
     "headerIncludes": [
-        (["WebKit", "WebCore"],
-            ("WebCore", "replay/EventLoopInput.h")
+        (["WebKit"],
+            ("WebKit", "WebProcess/Replay/WebEventLoopInput.h")
         ),
-        (["WebKit", "WebCore", "JavaScriptCore"],
-            ("JavaScriptCore", "replay/EncodedValue.h")
+        (["WebCore"],
+            ("WebCore", "replay/EventLoopInput.h")
         ),
         (["JavaScriptCore"],
             ("JavaScriptCore", "replay/NondeterministicInput.h")
         ),
+        (["WebKit", "WebCore", "JavaScriptCore"],
+            ("JavaScriptCore", "replay/EncodedValue.h")
+        ),
         (["WebCore"],
             ("WTF", "wtf/text/WTFString.h")
         ),
 
         # Testing fixtures.
         (["Test"],
             ("WebCore", "platform/ExternalNamespaceHeaderIncludeDummy.h")
         ),
         (["Test"],
             ("Test", "platform/InternalNamespaceHeaderIncludeDummy.h")
@@ -709,43 +712,54 @@ class Generator:
             lines.append("namespace %s {" % framework.setting('namespace'))
             lines.extend(decls_by_framework[framework])
             lines.append("}")
             lines.append("")
 
         return "\n".join(lines)
 
     def generate_class_declaration(self, _input):
         extra_declarations = []
         if _input.queue == InputQueues.EVENT_LOOP:
-            extra_declarations.extend([
-                "",
-                "    // EventLoopInput API",
-                "    virtual void dispatch(WebCore::Page&) override final;",
-            ])
+            if self.target_framework is Frameworks.WebKit:
+                extra_declarations.extend([
+                    "",
+                    "    // WebEventLoopInput API",
+                    "    virtual void dispatchOnWebPage(WebKit::WebPage&) override final;",
+                ])
+            else:
+                extra_declarations.extend([
+                    "",
+                    "    // EventLoopInput API",
+                    "    virtual void dispatchOnPage(WebCore::Page&) override final;",
+                ])
 
             if _input.setting('CREATE_FROM_PAGE'):
                 extra_declarations.extend([
                     "    static std::unique_ptr<%s> createFromPage(const WebCore::Page&);" % _input.name
                 ])
+            if _input.setting('CREATE_FROM_WEBPAGE'):
+                extra_declarations.extend([
+                    "    static std::unique_ptr<%s> createFromWebPage(const WebKit::WebPage&);" % _input.name
+                ])
 
         member_getters = [self.generate_input_member_getter(_member) for _member in _input.members]
 
         member_declarations = [self.generate_input_member_declaration(_member) for _member in _input.members]
         if len(member_declarations) > 0:
             member_declarations.insert(0, "private:")
 
         template_arguments = {
             'inputConstructor': self.generate_input_constructor_declaration(_input),
             'inputDestructor': self.generate_input_destructor_declaration(_input),
             'inputName': _input.name,
             'inputQueue': _input.setting('enumValue'),
-            'baseClass': _input.setting('baseClass') % _input.name,
+            'baseClass': self.base_class_string_for_input(_input),
             'extraDeclarations': "\n".join(extra_declarations),
             'memberGetters': "\n".join(member_getters),
             'memberDeclarations': "\n".join(member_declarations),
         }
 
         return wrap_with_guard(Template(Templates.InputClassDeclaration).substitute(template_arguments), _input.guard)
 
     def generate_input_constructor_declaration(self, _input):
         formals_list = self.generate_constructor_formals_list(_input)
         terms = []
@@ -769,20 +783,28 @@ class Generator:
 
     def generate_input_member_tuples(self, _input):
         return [(_member, self._model.get_type_for_member(_member)) for _member in _input.members]
 
     def qualified_input_name(self, _input):
         if self.target_framework == self.traits_framework:
             return _input.name
         else:
             return "%s::%s" % (self.target_framework.setting('namespace'), _input.name)
 
+    def base_class_string_for_input(self, _input):
+        base_class_template = _input.setting('baseClass')
+        # Special override for this subclass since it shares the same queue.
+        if self.target_framework is Frameworks.WebKit and _input.queue is InputQueues.EVENT_LOOP:
+            base_class_template = 'WebKit::WebEventLoopInput<%s>'
+
+        return base_class_template % _input.name
+
     def generate_input_trait_declaration(self, _input):
         decl_type = ['struct']
         if len(self.setting('exportMacro')) > 0:
             decl_type.append(self.setting('exportMacro'))
 
         template_arguments = {
             'structOrClass': " ".join(decl_type),
             'queueType': _input.queue.setting('enumValue'),
             'qualifiedInputName': self.qualified_input_name(_input),
         }
@@ -932,21 +954,21 @@ class Generator:
 
         if len(steps) == 0:
             steps.extend([
                 "    UNUSED_PARAM(encodedValue);",
             ])
 
         return "\n".join(steps)
 
     def generate_constructor_initializer_list(self, _input):
         initializers = []
-        initializers.append("    : %s()" % (_input.setting('baseClass') % _input.name))
+        initializers.append("    : %s()" % self.base_class_string_for_input(_input))
         for _member in _input.members:
             initializers.append("    , m_%s(%s)" % (_member.memberName, self.generate_member_move_expression(_member)))
 
         return "\n".join(initializers)
 
     def generate_constructor_formals_list(self, _input):
         formals_list = []
         for (_member, _type) in self.generate_input_member_tuples(_input):
             shouldQualifyType = self.target_framework is not _type.framework
             formals_list.append("%s %s" % (_type.argument_type(shouldQualifyType), _member.memberName))
diff --git a/Source/JavaScriptCore/replay/scripts/tests/expected/generate-enum-with-guard.json-TestReplayInputs.h b/Source/JavaScriptCore/replay/scripts/tests/expected/generate-enum-with-guard.json-TestReplayInputs.h
index 4d46bf7..50a4cf7 100644
--- a/Source/JavaScriptCore/replay/scripts/tests/expected/generate-enum-with-guard.json-TestReplayInputs.h
+++ b/Source/JavaScriptCore/replay/scripts/tests/expected/generate-enum-with-guard.json-TestReplayInputs.h
@@ -62,21 +62,21 @@ template<> struct EncodingTraits<WebCore::PlatformWheelEventPhase> {
 #endif // ENABLE(DUMMY_FEATURE)
 } // namespace JSC
 
 namespace Test {
 class HandleWheelEvent : public WebCore::EventLoopInput<HandleWheelEvent> {
 public:
     HandleWheelEvent(std::unique_ptr<WebCore::PlatformWheelEvent> platformEvent);
     virtual ~HandleWheelEvent();
 
     // EventLoopInput API
-    virtual void dispatch(WebCore::Page&) override final;
+    virtual void dispatchOnPage(WebCore::Page&) override final;
     const WebCore::PlatformWheelEvent& platformEvent() const { return *m_platformEvent; }
 private:
     std::unique_ptr<WebCore::PlatformWheelEvent> m_platformEvent;
 };
 } // namespace Test
 
 #define TEST_REPLAY_INPUT_NAMES_FOR_EACH(macro) \
     macro(HandleWheelEvent) \
     \
 // end of TEST_REPLAY_INPUT_NAMES_FOR_EACH
diff --git a/Source/WebCore/replay/EventLoopInput.h b/Source/WebCore/replay/EventLoopInput.h
index 26a5318..78a11e8 100644
--- a/Source/WebCore/replay/EventLoopInput.h
+++ b/Source/WebCore/replay/EventLoopInput.h
@@ -24,56 +24,61 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef EventLoopInput_h
 #define EventLoopInput_h
 
 #if ENABLE(WEB_REPLAY)
 
 #include <replay/NondeterministicInput.h>
-#include <wtf/CurrentTime.h>
 
 namespace JSC {
 class InputCursor;
 };
 
 namespace WebCore {
 
 class EventLoopInputBase;
 class Page;
-class ReplayController;
 
 // This is an RAII helper used during capturing which sets a flag on the input cursor
 // to track the dynamic extent of a captured event loop input. This extent approximates
 // the interval in which EventLoopInputDispatcher::dispatching() is true.
 class EventLoopInputExtent {
     WTF_MAKE_NONCOPYABLE(EventLoopInputExtent);
 public:
     EventLoopInputExtent(JSC::InputCursor&);
     EventLoopInputExtent(JSC::InputCursor*);
     ~EventLoopInputExtent();
 private:
     JSC::InputCursor* m_cursor;
 };
 
 struct EventLoopInputData {
     EventLoopInputBase* input;
     double timestamp;
 };
 
+enum class InputDispatchContext {
+    WebCore,
+    WebKit
+};
+
 class EventLoopInputBase : public NondeterministicInputBase {
 public:
     virtual ~EventLoopInputBase() { }
+
+    virtual InputDispatchContext context() const { return InputDispatchContext::WebCore; }
     virtual InputQueue queue() const override final { return InputQueue::EventLoopInput; }
 
-    virtual void dispatch(Page&) = 0;
+    virtual void dispatchOnPage(Page&) = 0;
 };
 
 template <typename InputType>
 class EventLoopInput : public EventLoopInputBase {
     virtual const AtomicString& type() const override final
     {
         return InputTraits<InputType>::type();
     }
 };
 
diff --git a/Source/WebCore/replay/WebReplayInputDispatchMethods.cpp b/Source/WebCore/replay/WebReplayInputDispatchMethods.cpp
index 7b5662c..063e139 100644
--- a/Source/WebCore/replay/WebReplayInputDispatchMethods.cpp
+++ b/Source/WebCore/replay/WebReplayInputDispatchMethods.cpp
@@ -57,158 +57,158 @@ static ResourceLoader* resourceLoaderForOrdinal(Page& page, unsigned long ordina
     ASSERT(frame);
 
     const Vector<unsigned long>& usedIdentifiers = frame->mainFrame().loader().activeDocumentLoader()->usedIdentifiers();
     ASSERT(ordinal < usedIdentifiers.size());
 
     RefPtr<ResourceLoader> loader = frame->loader().activeDocumentLoader()->loaderForIdentifier(usedIdentifiers.at(ordinal));
     return loader ? loader.get() : nullptr;
 }
 
 // Sentinel inputs.
-void BeginSegmentSentinel::dispatch(Page&)
+void BeginSegmentSentinel::dispatchOnPage(Page&)
 {
 }
 
-void EndSegmentSentinel::dispatch(Page&)
+void EndSegmentSentinel::dispatchOnPage(Page&)
 {
 }
 
 // Navigation inputs.
-void InitialNavigation::dispatch(Page& page)
+void InitialNavigation::dispatchOnPage(Page& page)
 {
     page.mainFrame().navigationScheduler().scheduleLocationChange(m_securityOrigin.get(), m_url, m_referrer);
 }
 
-void LoadURLRequest::dispatch(Page& page)
+void LoadURLRequest::dispatchOnPage(Page& page)
 {
     page.userInputBridge().loadRequest(*m_loadRequest);
 }
 
-void ReloadFrame::dispatch(Page& page)
+void ReloadFrame::dispatchOnPage(Page& page)
 {
     Frame* frame = frameFromFrameIndex(&page, m_frameIndex);
     ASSERT(frame);
 
     page.userInputBridge().reloadFrame(frame, m_endToEndReload, InputSource::Synthetic);
 }
 
-void StopLoadingFrame::dispatch(Page& page)
+void StopLoadingFrame::dispatchOnPage(Page& page)
 {
     Frame* frame = frameFromFrameIndex(&page, m_frameIndex);
     ASSERT(frame);
 
     page.userInputBridge().stopLoadingFrame(frame, InputSource::Synthetic);
 }
 
-void TryClosePage::dispatch(Page& page)
+void TryClosePage::dispatchOnPage(Page& page)
 {
     page.userInputBridge().tryClosePage(InputSource::Synthetic);
 }
 
-void InitializeHistory::dispatch(Page& page)
+void InitializeHistory::dispatchOnPage(Page& page)
 {
     return; // HACK
 
     // FIXME: Load the empty document, so that when we prune the back-forward list it
     // is the single remaining entry. <https://webkit.org/b/131989>
     page.backForward().clear();
 
     for (RefPtr<HistoryItem> historyEntry : m_entries)
         page.backForward().addItem(historyEntry->copy());
 
     page.mainFrame().loader().history().setCurrentItem(page.backForward().currentItem());
 }
 
-void HandleKeyPress::dispatch(Page& page)
+void HandleKeyPress::dispatchOnPage(Page& page)
 {
     page.userInputBridge().handleKeyEvent(platformEvent(), InputSource::Synthetic);
 }
 
 // User interaction inputs.
-void HandleMouseMove::dispatch(Page& page)
+void HandleMouseMove::dispatchOnPage(Page& page)
 {
     if (m_scrollbarTargeted)
         page.userInputBridge().handleMouseMoveOnScrollbarEvent(platformEvent(), InputSource::Synthetic);
     else
         page.userInputBridge().handleMouseMoveEvent(platformEvent(), InputSource::Synthetic);
 }
 
-void HandleMousePress::dispatch(Page& page)
+void HandleMousePress::dispatchOnPage(Page& page)
 {
     page.userInputBridge().handleMousePressEvent(platformEvent(), InputSource::Synthetic);
 }
 
-void HandleMouseRelease::dispatch(Page& page)
+void HandleMouseRelease::dispatchOnPage(Page& page)
 {
     page.userInputBridge().handleMouseReleaseEvent(platformEvent(), InputSource::Synthetic);
 }
 
-void HandleWheelEvent::dispatch(Page& page)
+void HandleWheelEvent::dispatchOnPage(Page& page)
 {
     page.userInputBridge().handleWheelEvent(platformEvent(), InputSource::Synthetic);
 }
 
-void LogicalScrollPage::dispatch(Page& page)
+void LogicalScrollPage::dispatchOnPage(Page& page)
 {
     page.userInputBridge().logicalScrollRecursively(direction(), granularity(), InputSource::Synthetic);
 }
 
-void ScrollPage::dispatch(Page& page)
+void ScrollPage::dispatchOnPage(Page& page)
 {
     page.userInputBridge().scrollRecursively(direction(), granularity(), InputSource::Synthetic);
 }
 
 // Network inputs.
-void ResourceLoaderDidFail::dispatch(Page& page)
+void ResourceLoaderDidFail::dispatchOnPage(Page& page)
 {
     if (ResourceLoader* loader = resourceLoaderForOrdinal(page, ordinal(), frameIndex()))
         loader->didFail(m_error->copy());
     // FIXME: signal error if the callback couldn't be fired.
 }
 
-void ResourceLoaderDidFinishLoading::dispatch(Page& page)
+void ResourceLoaderDidFinishLoading::dispatchOnPage(Page& page)
 {
     if (ResourceLoader* loader = resourceLoaderForOrdinal(page, ordinal(), frameIndex()))
         loader->didFinishLoading(m_finishTime);
     // FIXME: signal error if the callback couldn't be fired.
 }
 
-void ResourceLoaderDidReceiveData::dispatch(Page& page)
+void ResourceLoaderDidReceiveData::dispatchOnPage(Page& page)
 {
     if (ResourceLoader* loader = resourceLoaderForOrdinal(page, ordinal(), frameIndex()))
         loader->didReceiveData(buffer()->data(), buffer()->size(), encodedLength(), DataPayloadBytes);
     // FIXME: signal error if the callback couldn't be fired.
 }
 
-void ResourceLoaderDidReceiveResponse::dispatch(Page& page)
+void ResourceLoaderDidReceiveResponse::dispatchOnPage(Page& page)
 {
     if (ResourceLoader* loader = resourceLoaderForOrdinal(page, ordinal(), frameIndex()))
         loader->didReceiveResponse(*m_response);
     // FIXME: signal error if the callback couldn't be fired.
 }
 
-void ResourceLoaderDidSendData::dispatch(Page& page)
+void ResourceLoaderDidSendData::dispatchOnPage(Page& page)
 {
     if (ResourceLoader* loader = resourceLoaderForOrdinal(page, ordinal(), frameIndex()))
         loader->didSendData(m_bytesSent, m_totalBytesToBeSent);
     // FIXME: signal error if the callback couldn't be fired.
 }
 
 // Other event loop inputs.
-void AsyncTimerFired::dispatch(Page& page)
+void AsyncTimerFired::dispatchOnPage(Page& page)
 {
     Document* document = documentFromFrameIndex(&page, m_frameIndex);
     if (!document || !document->replayableTimers().fireTimer(m_ordinal))
         LOG_ERROR("%-30s REPLAY DIVERGENCE! Couldn't find async timer %d/%" PRIu64 ".\n", "[ReplayController]", m_frameIndex, m_ordinal);
 }
 
-void DOMTimerFired::dispatch(Page& page)
+void DOMTimerFired::dispatchOnPage(Page& page)
 {
     Document* document = documentFromFrameIndex(&page, m_frameIndex);
     DOMTimer* timer = document->findTimeout(m_timerIdentifier);
     if (timer)
         timer->fired();
     else
        LOG_ERROR("REPLAY DIVERGENCE! Couldn't find and fire DOM timer %" PRIu32 "/%" PRIu32 ".\n", m_frameIndex, m_timerIdentifier);
 }
 
 } // namespace WebCore
diff --git a/Source/WebKit2/CMakeLists.txt b/Source/WebKit2/CMakeLists.txt
index cb4406b..dc8d6b9 100644
--- a/Source/WebKit2/CMakeLists.txt
+++ b/Source/WebKit2/CMakeLists.txt
@@ -47,21 +47,20 @@ set(WebKit2_INCLUDE_DIRECTORIES
     "${WEBKIT2_DIR}/WebProcess/InjectedBundle/API"
     "${WEBKIT2_DIR}/WebProcess/InjectedBundle/API/c"
     "${WEBKIT2_DIR}/WebProcess/InjectedBundle/DOM"
     "${WEBKIT2_DIR}/WebProcess/Launching"
     "${WEBKIT2_DIR}/WebProcess/MediaCache"
     "${WEBKIT2_DIR}/WebProcess/Network"
     "${WEBKIT2_DIR}/WebProcess/Notifications"
     "${WEBKIT2_DIR}/WebProcess/OriginData"
     "${WEBKIT2_DIR}/WebProcess/Plugins"
     "${WEBKIT2_DIR}/WebProcess/Plugins/Netscape"
-    "${WEBKIT2_DIR}/WebProcess/Replay"
     "${WEBKIT2_DIR}/WebProcess/ResourceCache"
     "${WEBKIT2_DIR}/WebProcess/Storage"
     "${WEBKIT2_DIR}/WebProcess/UserContent"
     "${WEBKIT2_DIR}/WebProcess/WebCoreSupport"
     "${WEBKIT2_DIR}/WebProcess/WebPage"
     "${WEBCORE_DIR}"
     "${WEBCORE_DIR}/Modules/battery"
     "${WEBCORE_DIR}/Modules/mediastream"
     "${WEBCORE_DIR}/Modules/networkinfo"
     "${WEBCORE_DIR}/Modules/notifications"
@@ -738,37 +737,34 @@ if (ENABLE_PLUGIN_PROCESS)
     target_link_libraries(PluginProcess ${PluginProcess_LIBRARIES})
     set_target_properties(PluginProcess PROPERTIES FOLDER "WebKit")
     install(TARGETS PluginProcess DESTINATION "${LIBEXEC_INSTALL_DIR}")
 
     if (WebKit2_PluginProcess_OUTPUT_NAME)
       set_target_properties(PluginProcess PROPERTIES OUTPUT_NAME ${WebKit2_PluginProcess_OUTPUT_NAME})
     endif ()
 endif ()
 
 if (ENABLE_WEB_REPLAY)
-    list(APPEND WebKit2_INCLUDE_DIRECTORIES
-        "${WEBKIT2_DIR}/WebProcess/Replay"
-    )
-
-<<<<<<< HEAD
-    list(APPEND WebKit2_SOURCES
-        WebProcess/Replay/WebReplayClient.cpp
-=======
     set(WebKit2_WEB_REPLAY_INPUTS ${WEBKIT2_DIR}/WebProcess/Replay/WebInputs.json)
     add_custom_command(
         OUTPUT ${DERIVED_SOURCES_WEBKIT2_DIR}/WKReplayInputs.h ${DERIVED_SOURCES_WEBKIT2_DIR}/WKReplayInputs.cpp
         MAIN_DEPENDENCY ${JAVASCRIPTCORE_DIR}/replay/scripts/CodeGeneratorReplayInputs.py
         DEPENDS ${WebKit2_WEB_REPLAY_INPUTS}
         COMMAND ${PYTHON_EXECUTABLE} ${JAVASCRIPTCORE_DIR}/replay/scripts/CodeGeneratorReplayInputs.py --outputDir ${DERIVED_SOURCES_WEBKIT2_DIR}/ --framework WebKit ${WebKit2_WEB_REPLAY_INPUTS}
         VERBATIM)
 
+    list(APPEND WebKit2_INCLUDE_DIRECTORIES
+        "${WEBKIT2_DIR}/WebProcess/Replay"
+    )
+
     list(APPEND WebKit2_SOURCES
         WebProcess/Replay/WKReplayInputCoders.cpp
+        WebProcess/Replay/WebReplayClient.cpp
         ${DERIVED_SOURCES_WEBKIT2_DIR}/WKReplayInputs.cpp
     )
 endif ()
 
 POPULATE_LIBRARY_VERSION(WEBKIT2)
 set_target_properties(WebKit2 PROPERTIES VERSION ${WEBKIT2_VERSION} SOVERSION ${WEBKIT2_VERSION_MAJOR})
 
 install(TARGETS WebKit2 DESTINATION "${LIB_INSTALL_DIR}")
 install(TARGETS WebProcess DESTINATION "${LIBEXEC_INSTALL_DIR}")
diff --git a/Source/WebKit2/WebKit2.xcodeproj/project.pbxproj b/Source/WebKit2/WebKit2.xcodeproj/project.pbxproj
index f602d0e..19c0f26 100644
--- a/Source/WebKit2/WebKit2.xcodeproj/project.pbxproj
+++ b/Source/WebKit2/WebKit2.xcodeproj/project.pbxproj
@@ -1540,20 +1540,22 @@
 		C0337DD8127A51B6008FF4F4 /* WebTouchEvent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C0337DD7127A51B6008FF4F4 /* WebTouchEvent.cpp */; };
 		C0337DDD127A521C008FF4F4 /* WebPlatformTouchPoint.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C0337DDC127A521C008FF4F4 /* WebPlatformTouchPoint.cpp */; };
 		C06C6095124C144B0001682F /* WebPageCreationParameters.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C06C6093124C14430001682F /* WebPageCreationParameters.cpp */; };
 		C09AE5E9125257C20025825D /* WKNativeEvent.h in Headers */ = {isa = PBXBuildFile; fileRef = C09AE5E8125257C20025825D /* WKNativeEvent.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C0CE72A01247E71D00BC0EC4 /* WebPageMessageReceiver.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C0CE729E1247E71D00BC0EC4 /* WebPageMessageReceiver.cpp */; };
 		C0CE72A11247E71D00BC0EC4 /* WebPageMessages.h in Headers */ = {isa = PBXBuildFile; fileRef = C0CE729F1247E71D00BC0EC4 /* WebPageMessages.h */; };
 		C0CE72AD1247E78D00BC0EC4 /* HandleMessage.h in Headers */ = {isa = PBXBuildFile; fileRef = C0CE72AC1247E78D00BC0EC4 /* HandleMessage.h */; };
 		C0E3AA7A1209E83000A49D01 /* ModuleCF.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C0E3AA481209E45000A49D01 /* ModuleCF.cpp */; };
 		C0E3AA7B1209E83500A49D01 /* Module.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C0E3AA451209E2BA00A49D01 /* Module.cpp */; };
 		C0E3AA7C1209E83C00A49D01 /* Module.h in Headers */ = {isa = PBXBuildFile; fileRef = C0E3AA441209E2BA00A49D01 /* Module.h */; };
+		C490806719A594AB00663BCF /* WKReplayInputDispatchMethods.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C490806619A594AB00663BCF /* WKReplayInputDispatchMethods.cpp */; };
+		C490806919A6A87800663BCF /* WebEventLoopInput.h in Headers */ = {isa = PBXBuildFile; fileRef = C490806819A6A87800663BCF /* WebEventLoopInput.h */; };
 		C49474B019A3F93F009B3DE8 /* WebReplayClient.h in Headers */ = {isa = PBXBuildFile; fileRef = C49474AE19A3F924009B3DE8 /* WebReplayClient.h */; };
 		C49474B119A3F947009B3DE8 /* WebReplayClient.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C49474AD19A3F924009B3DE8 /* WebReplayClient.cpp */; };
 		C49474B719A41B73009B3DE8 /* WKReplayInputs.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C49474B519A41B73009B3DE8 /* WKReplayInputs.cpp */; };
 		C49474B819A41B73009B3DE8 /* WKReplayInputs.h in Headers */ = {isa = PBXBuildFile; fileRef = C49474B619A41B73009B3DE8 /* WKReplayInputs.h */; };
 		C49474BB19A5413F009B3DE8 /* WKReplayInputCoders.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C49474B919A5413F009B3DE8 /* WKReplayInputCoders.cpp */; };
 		C49474BC19A5413F009B3DE8 /* WKReplayInputCoders.h in Headers */ = {isa = PBXBuildFile; fileRef = C49474BA19A5413F009B3DE8 /* WKReplayInputCoders.h */; };
 		C517388112DF8F4F00EE3F47 /* DragControllerAction.h in Headers */ = {isa = PBXBuildFile; fileRef = C517388012DF8F4F00EE3F47 /* DragControllerAction.h */; };
 		C5237F6012441CA300780472 /* WebEditorClientMac.mm in Sources */ = {isa = PBXBuildFile; fileRef = C5237F5F12441CA300780472 /* WebEditorClientMac.mm */; };
 		C54256B518BEC18C00DE4179 /* WKFormInputControl.h in Headers */ = {isa = PBXBuildFile; fileRef = C54256AF18BEC18B00DE4179 /* WKFormInputControl.h */; };
 		C54256B618BEC18C00DE4179 /* WKFormInputControl.mm in Sources */ = {isa = PBXBuildFile; fileRef = C54256B018BEC18B00DE4179 /* WKFormInputControl.mm */; };
@@ -3638,20 +3640,21 @@
 		C0CE72581247E4DA00BC0EC4 /* WebPage.messages.in */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = WebPage.messages.in; sourceTree = "<group>"; };
 		C0CE729E1247E71D00BC0EC4 /* WebPageMessageReceiver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WebPageMessageReceiver.cpp; sourceTree = "<group>"; };
 		C0CE729F1247E71D00BC0EC4 /* WebPageMessages.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WebPageMessages.h; sourceTree = "<group>"; };
 		C0CE72AC1247E78D00BC0EC4 /* HandleMessage.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = HandleMessage.h; sourceTree = "<group>"; };
 		C0CE72DB1247E8F700BC0EC4 /* DerivedSources.make */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = DerivedSources.make; sourceTree = "<group>"; };
 		C0CE73361247F70E00BC0EC4 /* generate-message-receiver.py */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.python; path = "generate-message-receiver.py"; sourceTree = "<group>"; };
 		C0CE73371247F70E00BC0EC4 /* generate-messages-header.py */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.python; path = "generate-messages-header.py"; sourceTree = "<group>"; };
 		C0E3AA441209E2BA00A49D01 /* Module.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Module.h; sourceTree = "<group>"; };
 		C0E3AA451209E2BA00A49D01 /* Module.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Module.cpp; sourceTree = "<group>"; };
 		C0E3AA481209E45000A49D01 /* ModuleCF.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ModuleCF.cpp; sourceTree = "<group>"; };
+		C490806819A6A87800663BCF /* WebEventLoopInput.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WebEventLoopInput.h; sourceTree = "<group>"; };
 		C49474AD19A3F924009B3DE8 /* WebReplayClient.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WebReplayClient.cpp; sourceTree = "<group>"; };
 		C49474AE19A3F924009B3DE8 /* WebReplayClient.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WebReplayClient.h; sourceTree = "<group>"; };
 		C49474B319A41246009B3DE8 /* WKInputs.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = WKInputs.json; sourceTree = "<group>"; };
 		C49474B519A41B73009B3DE8 /* WKReplayInputs.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WKReplayInputs.cpp; sourceTree = "<group>"; };
 		C49474B619A41B73009B3DE8 /* WKReplayInputs.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WKReplayInputs.h; sourceTree = "<group>"; };
 		C49474B919A5413F009B3DE8 /* WKReplayInputCoders.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WKReplayInputCoders.cpp; sourceTree = "<group>"; };
 		C49474BA19A5413F009B3DE8 /* WKReplayInputCoders.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WKReplayInputCoders.h; sourceTree = "<group>"; };
 		C517388012DF8F4F00EE3F47 /* DragControllerAction.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DragControllerAction.h; sourceTree = "<group>"; };
 		C5237F5F12441CA300780472 /* WebEditorClientMac.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; path = WebEditorClientMac.mm; sourceTree = "<group>"; };
 		C54256AF18BEC18B00DE4179 /* WKFormInputControl.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WKFormInputControl.h; path = ios/forms/WKFormInputControl.h; sourceTree = "<group>"; };
@@ -6918,20 +6921,21 @@
 			sourceTree = "<group>";
 			tabWidth = 8;
 			usesTabs = 0;
 		};
 		C49474B219A4121A009B3DE8 /* Replay */ = {
 			isa = PBXGroup;
 			children = (
 				C49474B319A41246009B3DE8 /* WKInputs.json */,
 				C49474B919A5413F009B3DE8 /* WKReplayInputCoders.cpp */,
 				C49474BA19A5413F009B3DE8 /* WKReplayInputCoders.h */,
+				C490806819A6A87800663BCF /* WebEventLoopInput.h */,
 			);
 			path = Replay;
 			sourceTree = "<group>";
 		};
 		C54256AE18BEC16100DE4179 /* forms */ = {
 			isa = PBXGroup;
 			children = (
 				C5FA1ED118E1062200B3F402 /* WKAirPlayRoutePicker.h */,
 				C5FA1ED218E1062200B3F402 /* WKAirPlayRoutePicker.mm */,
 				A58B6F0618FCA733008CBA53 /* WKFileUploadPanel.h */,
@@ -7153,20 +7157,21 @@
 				2984F57D164B915F004BC0C6 /* CustomProtocolManagerProxyMessages.h in Headers */,
 				518353DF1887128B00D9FE44 /* KeyedDecoder.h in Headers */,
 				BCE81D99131AE02100241910 /* DictionaryPopupInfo.h in Headers */,
 				C58CDF2E1887609F00871536 /* InteractionInformationAtPosition.h in Headers */,
 				5167EEA0170377BF007681CA /* NetworkDiskCacheMonitor.h in Headers */,
 				518E8F0816B2093700E91429 /* Download.h in Headers */,
 				518E8F0A16B2093700E91429 /* DownloadAuthenticationClient.h in Headers */,
 				518E8F0C16B2093700E91429 /* DownloadManager.h in Headers */,
 				1AB7D4CA1288AAA700CFD08C /* DownloadProxy.h in Headers */,
 				373D122D18A4B6EB0066D9CC /* WKWebProcessPlugInFramePrivate.h in Headers */,
+				C490806919A6A87800663BCF /* WebEventLoopInput.h in Headers */,
 				1AD25E96167AB08100EA9BCD /* DownloadProxyMap.h in Headers */,
 				A58B6F0818FCA733008CBA53 /* WKFileUploadPanel.h in Headers */,
 				1AB7D61A1288B9D900CFD08C /* DownloadProxyMessages.h in Headers */,
 				C517388112DF8F4F00EE3F47 /* DragControllerAction.h in Headers */,
 				BC8452A81162C80900CAB9B5 /* DrawingArea.h in Headers */,
 				378E1A4A18208CD60031007A /* WKNSString.h in Headers */,
 				A1A4FE5C18DCE9FA00B5EA8A /* _WKDownloadInternal.h in Headers */,
 				2D8949F1182044F600E898AA /* PlatformCALayerRemoteTiledBacking.h in Headers */,
 				0FB659231208B4DB0044816C /* DrawingAreaInfo.h in Headers */,
 				26F9A83B18A3468100AEB88A /* WKWebViewPrivate.h in Headers */,
diff --git a/Source/WebKit2/WebProcess/Replay/WKReplayInputDispatchMethods.cpp b/Source/WebKit2/WebProcess/Replay/WKReplayInputDispatchMethods.cpp
new file mode 100644
index 0000000..f5d6ae4
--- /dev/null
+++ b/Source/WebKit2/WebProcess/Replay/WKReplayInputDispatchMethods.cpp
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2011-2014 University of Washington.
+ * Copyright (C) 2014 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+
+#if ENABLE(WEB_REPLAY)
+
+#include "WKReplayInputs.h"
+#include "WebPage.h"
+
+namespace WebKit {
+
+void HandleMouseEvent::dispatchOnWebPage(WebPage& page)
+{
+    page.handleMouseEvent(mouseEvent(), WebPage::ActionSource::Synthetic);
+}
+
+} // namespace WebKit
+
+#endif // ENABLE(WEB_REPLAY)
diff --git a/Source/WebCore/replay/EventLoopInput.h b/Source/WebKit2/WebProcess/Replay/WebEventLoopInput.h
similarity index 60%
copy from Source/WebCore/replay/EventLoopInput.h
copy to Source/WebKit2/WebProcess/Replay/WebEventLoopInput.h
index 26a5318..9ca7e55 100644
--- a/Source/WebCore/replay/EventLoopInput.h
+++ b/Source/WebKit2/WebProcess/Replay/WebEventLoopInput.h
@@ -18,67 +18,48 @@
  * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef EventLoopInput_h
-#define EventLoopInput_h
+#ifndef WebEventLoopInput_h
+#define WebEventLoopInput_h
 
 #if ENABLE(WEB_REPLAY)
 
-#include <replay/NondeterministicInput.h>
-#include <wtf/CurrentTime.h>
-
-namespace JSC {
-class InputCursor;
-};
+#include <WTF/Assertions.h>
+#include <WebCore/EventLoopInput.h>
 
 namespace WebCore {
-
-class EventLoopInputBase;
 class Page;
-class ReplayController;
-
-// This is an RAII helper used during capturing which sets a flag on the input cursor
-// to track the dynamic extent of a captured event loop input. This extent approximates
-// the interval in which EventLoopInputDispatcher::dispatching() is true.
-class EventLoopInputExtent {
-    WTF_MAKE_NONCOPYABLE(EventLoopInputExtent);
-public:
-    EventLoopInputExtent(JSC::InputCursor&);
-    EventLoopInputExtent(JSC::InputCursor*);
-    ~EventLoopInputExtent();
-private:
-    JSC::InputCursor* m_cursor;
-};
+}
+namespace WebKit {
 
-struct EventLoopInputData {
-    EventLoopInputBase* input;
-    double timestamp;
-};
+class WebPage;
 
-class EventLoopInputBase : public NondeterministicInputBase {
+class WebEventLoopInputBase : public WebCore::EventLoopInputBase {
 public:
-    virtual ~EventLoopInputBase() { }
-    virtual InputQueue queue() const override final { return InputQueue::EventLoopInput; }
+    virtual ~WebEventLoopInputBase() { }
+
+    virtual WebCore::InputDispatchContext context() const override final { return WebCore::InputDispatchContext::WebKit; }
 
-    virtual void dispatch(Page&) = 0;
+    virtual void dispatchOnPage(WebCore::Page&) override final { ASSERT_NOT_REACHED(); }
+    virtual void dispatchOnWebPage(WebPage&) = 0;
 };
 
 template <typename InputType>
-class EventLoopInput : public EventLoopInputBase {
+class WebEventLoopInput : public WebEventLoopInputBase {
     virtual const AtomicString& type() const override final
     {
         return InputTraits<InputType>::type();
     }
 };
 
-} // namespace WebCore
+} // namespace WebPage
 
 #endif // ENABLE(WEB_REPLAY)
 
-#endif // EventLoopInput_h
+#endif // WebEventLoopInput_h
diff --git a/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.cpp b/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.cpp
index f5b7652..ff02057 100644
--- a/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.cpp
+++ b/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.cpp
@@ -22,29 +22,37 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "WebReplayClient.h"
 
 #if ENABLE(WEB_REPLAY)
 
 #include "WKReplayInputCoders.h"
+#include "WebEventLoopInput.h"
 #include "WebPage.h"
 #include <WebCore/EventLoopInput.h>
-#include <WebCore/ReplayController.h>
+
+using WebCore::InputDispatchContext;
 
 namespace WebKit {
 
 void WebReplayClient::dispatchInput(WebCore::EventLoopInputBase& input)
 {
-    input.dispatch(*m_page->corePage());
+    switch (input.context()) {
+    case InputDispatchContext::WebCore:
+        input.dispatchOnPage(*m_page->corePage());
+        break;
+    case InputDispatchContext::WebKit:
+        static_cast<WebEventLoopInputBase&>(input).dispatchOnWebPage(*m_page);
+    }
 }
 
 bool WebReplayClient::encodeInput(const NondeterministicInputBase& input, EncodedValue& encodedInput)
 {
     encodedInput = EncodingTraits<NondeterministicInputBase>::encodeValue(input);
     return true;
 }
 
 bool WebReplayClient::decodeInput(EncodedValue& encodedInput, std::unique_ptr<NondeterministicInputBase>& decodedInput)
 {
-- 
2.0.1

