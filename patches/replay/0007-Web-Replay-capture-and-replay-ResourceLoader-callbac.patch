From 3fdefc764a260873dc8551816d762d5b6440ffaa Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Thu, 12 Jun 2014 16:49:07 -0700
Subject: [PATCH] Web Replay: capture and replay ResourceLoader callbacks
 https://bugs.webkit.org/show_bug.cgi?id=129391

Reviewed by NOBODY (OOPS!).

Source/WebCore:

Our approach to ensuring deterministic page loading is to capture resource loader
callbacks during capturing, and then manually invoke loader callbacks during replay
in lieu of using the resource loader scheduler.

Callbacks are tapped inside SubresourceLoader before doing more work inside WebCore.
When replaying, we allow loaders to be initialized, but never actually schedule them.

To address resource loaders deterministically, we save the ordinal of resource loaders-
that is, the order in which the loader was created with respect to other loaders within
the same frame tree rooted by the main frame. To map between loaders' ordinals and unique
identifiers, the main frame's active document loader records a vector of identifiers as
they are vended to loaders within the frame tree.

No new tests. Basic functionality is covered by existing replay reference tests.

* WebCore.exp.in:
* loader/DocumentLoader.cpp:
(WebCore::DocumentLoader::loaderForIdentifier): Added. This method is used during
playback to find the appropriate resource loader to dispatch a callback to.
* loader/DocumentLoader.h: Add a list of usedIdentifiers for mapping loader ordinals.

* loader/ResourceLoadScheduler.cpp:
(WebCore::ResourceLoadScheduler::servePendingRequests): If replaying, don't actually
schedule the resource loader. However, we still want to dequeue it from pending
requests and allow it to count towards resource loading metrics.

* loader/ResourceLoader.cpp:
(WebCore::ResourceLoader::activeInputCursor): Added. This method figures out which
input cursor should be considered "active" for this resource loader. It will try to use
the input cursor for the document, or the page's cursor if the resource is part of a
provisional document load.

* loader/ResourceLoader.h:
* loader/SubresourceLoader.cpp: Add instrumentation hooks that create inputs for
each resource loader callback when capturing.

(WebCore::SubresourceLoader::didSendData):
(WebCore::SubresourceLoader::didReceiveResponse):
(WebCore::SubresourceLoader::didReceiveDataOrBuffer):
(WebCore::SubresourceLoader::didFinishLoading):
(WebCore::SubresourceLoader::didFail):
* platform/network/ResourceErrorBase.cpp:
(WebCore::ResourceErrorBase::ownedCopy): Added helper method. It does not need to copy
platform data unless it (indirectly) affects the web page's deterministic execution.
* platform/network/ResourceErrorBase.h:

* replay/ReplayInputDispatchMethods.cpp: Add dispatch methods for the most important
resource loader callbacks. More could be supported, but these cover most cases.
(WebCore::resourceLoaderForOrdinal): Added helper method to dig out a resource loader
from a frame's document loader given a resource loader ordinal and frame index.
(WebCore::ResourceLoaderDidFail::dispatch): Added.
(WebCore::ResourceLoaderDidFinishLoading::dispatch): Added.
(WebCore::ResourceLoaderDidReceiveData::dispatch): Added.
(WebCore::ResourceLoaderDidReceiveResponse::dispatch): Added.
(WebCore::ResourceLoaderDidSendData::dispatch): Added.
(JSC::EncodingTraits<HTTPHeaderMap>::encodeValue):
(JSC::EncodingTraits<HTTPHeaderMap>::decodeValue):
(JSC::EncodingTraits<NondeterministicInputBase>::encodeValue):
(JSC::EncodingTraits<KeypressCommand>::encodeValue):
(JSC::EncodingTraits<PlatformKeyboardEvent>::encodeValue):
(JSC::EncodingTraits<PlatformMouseEvent>::encodeValue):
(JSC::EncodingTraits<ResourceError>::encodeValue):
(JSC::EncodingTraits<ResourceError>::decodeValue):
(JSC::EncodingTraits<ResourceLoadTiming>::encodeValue):
(JSC::EncodingTraits<ResourceLoadTiming>::decodeValue):
(JSC::EncodingTraits<ResourceResponse>::encodeValue):
(JSC::EncodingTraits<ResourceResponse>::decodeValue):
(JSC::EncodingTraits<SharedBuffer>::encodeValue):
(JSC::EncodingTraits<SharedBuffer>::decodeValue):
* replay/SerializationMethods.h:
* replay/WebInputs.json:

Source/WebKit2:

During playback, don't schedule resource loaders. This prevents the NetworkProcess
from taking over and fulfilling the loads nondeterministically.

* WebProcess/Network/WebResourceLoadScheduler.cpp:
(WebKit::WebResourceLoadScheduler::scheduleLoad):
---
 Source/JavaScriptCore/replay/EncodedValue.h        |   4 +-
 Source/WebCore/ChangeLog                           |  79 ++++++++++
 Source/WebCore/WebCore.exp.in                      |   8 +
 Source/WebCore/loader/DocumentLoader.cpp           |  40 ++++-
 Source/WebCore/loader/DocumentLoader.h             |   8 +
 Source/WebCore/loader/ResourceLoadScheduler.cpp    |   9 ++
 Source/WebCore/loader/ResourceLoader.cpp           |  23 +++
 Source/WebCore/loader/ResourceLoader.h             |  10 ++
 Source/WebCore/loader/SubresourceLoader.cpp        |  72 ++++++++-
 Source/WebCore/loader/SubresourceLoader.h          |   4 +
 Source/WebCore/platform/network/FormData.cpp       |   2 +-
 .../WebCore/platform/network/ResourceErrorBase.cpp |   8 +
 .../WebCore/platform/network/ResourceErrorBase.h   |   1 +
 .../WebCore/replay/ReplayInputDispatchMethods.cpp  |  54 ++++++-
 Source/WebCore/replay/SerializationMethods.cpp     | 167 +++++++++++++++++++++
 Source/WebCore/replay/SerializationMethods.h       |  40 ++++-
 Source/WebCore/replay/WebInputs.json               |  64 ++++++++
 Source/WebKit2/ChangeLog                           |  15 +-
 .../Network/WebResourceLoadScheduler.cpp           |  13 +-
 19 files changed, 609 insertions(+), 12 deletions(-)

diff --git a/Source/JavaScriptCore/replay/EncodedValue.h b/Source/JavaScriptCore/replay/EncodedValue.h
index c0010e8..3ed089f 100644
--- a/Source/JavaScriptCore/replay/EncodedValue.h
+++ b/Source/JavaScriptCore/replay/EncodedValue.h
@@ -132,22 +132,22 @@ struct EncodingTraits<Vector<T, inlineCapacity, OverflowHandler>> {
 
 template<> struct EncodingTraits<EncodedValue> {
     typedef EncodedValue DecodedType;
     // We should never attempt to decode or encode an encoded value,
     // so encodeValue and decodeValue are intentionally omitted here.
 };
 
 // Specialize byte vectors to use base64 encoding.
 template<> struct EncodingTraits<Vector<char>> {
     typedef Vector<char> DecodedType;
-    static EncodedValue encodeValue(const DecodedType&);
-    static bool decodeValue(EncodedValue&, DecodedType&);
+    static JS_EXPORT_PRIVATE EncodedValue encodeValue(const DecodedType&);
+    static JS_EXPORT_PRIVATE bool decodeValue(EncodedValue&, DecodedType&);
 };
 
 template<typename T>
 struct ScalarEncodingTraits {
     typedef T DecodedType;
 
     static JS_EXPORT_PRIVATE EncodedValue encodeValue(const DecodedType& decodedValue);
     static bool decodeValue(EncodedValue& encodedValue, DecodedType& decodedValue)
     {
         decodedValue = encodedValue.convertTo<DecodedType>();
diff --git a/Source/WebCore/ChangeLog b/Source/WebCore/ChangeLog
index 8994c7c..8c6c127 100644
--- a/Source/WebCore/ChangeLog
+++ b/Source/WebCore/ChangeLog
@@ -1,12 +1,91 @@
 2014-06-12  Brian Burg  <burg@cs.washington.edu>
 
+        Web Replay: capture and replay ResourceLoader callbacks
+        https://bugs.webkit.org/show_bug.cgi?id=129391
+
+        Reviewed by NOBODY (OOPS!).
+
+        Our approach to ensuring deterministic page loading is to capture resource loader
+        callbacks during capturing, and then manually invoke loader callbacks during replay
+        in lieu of using the resource loader scheduler.
+
+        Callbacks are tapped inside SubresourceLoader before doing more work inside WebCore.
+        When replaying, we allow loaders to be initialized, but never actually schedule them.
+
+        To address resource loaders deterministically, we save the ordinal of resource loaders-
+        that is, the order in which the loader was created with respect to other loaders within
+        the same frame tree rooted by the main frame. To map between loaders' ordinals and unique
+        identifiers, the main frame's active document loader records a vector of identifiers as
+        they are vended to loaders within the frame tree.
+
+        No new tests. Basic functionality is covered by existing replay reference tests.
+
+        * WebCore.exp.in:
+        * loader/DocumentLoader.cpp:
+        (WebCore::DocumentLoader::loaderForIdentifier): Added. This method is used during
+        playback to find the appropriate resource loader to dispatch a callback to.
+        * loader/DocumentLoader.h: Add a list of usedIdentifiers for mapping loader ordinals.
+
+        * loader/ResourceLoadScheduler.cpp:
+        (WebCore::ResourceLoadScheduler::servePendingRequests): If replaying, don't actually
+        schedule the resource loader. However, we still want to dequeue it from pending
+        requests and allow it to count towards resource loading metrics.
+
+        * loader/ResourceLoader.cpp:
+        (WebCore::ResourceLoader::activeInputCursor): Added. This method figures out which
+        input cursor should be considered "active" for this resource loader. It will try to use
+        the input cursor for the document, or the page's cursor if the resource is part of a
+        provisional document load.
+
+        * loader/ResourceLoader.h:
+        * loader/SubresourceLoader.cpp: Add instrumentation hooks that create inputs for
+        each resource loader callback when capturing.
+
+        (WebCore::SubresourceLoader::didSendData):
+        (WebCore::SubresourceLoader::didReceiveResponse):
+        (WebCore::SubresourceLoader::didReceiveDataOrBuffer):
+        (WebCore::SubresourceLoader::didFinishLoading):
+        (WebCore::SubresourceLoader::didFail):
+        * platform/network/ResourceErrorBase.cpp:
+        (WebCore::ResourceErrorBase::ownedCopy): Added helper method. It does not need to copy
+        platform data unless it (indirectly) affects the web page's deterministic execution.
+        * platform/network/ResourceErrorBase.h:
+
+        * replay/ReplayInputDispatchMethods.cpp: Add dispatch methods for the most important
+        resource loader callbacks. More could be supported, but these cover most cases.
+        (WebCore::resourceLoaderForOrdinal): Added helper method to dig out a resource loader
+        from a frame's document loader given a resource loader ordinal and frame index.
+        (WebCore::ResourceLoaderDidFail::dispatch): Added.
+        (WebCore::ResourceLoaderDidFinishLoading::dispatch): Added.
+        (WebCore::ResourceLoaderDidReceiveData::dispatch): Added.
+        (WebCore::ResourceLoaderDidReceiveResponse::dispatch): Added.
+        (WebCore::ResourceLoaderDidSendData::dispatch): Added.
+        (JSC::EncodingTraits<HTTPHeaderMap>::encodeValue):
+        (JSC::EncodingTraits<HTTPHeaderMap>::decodeValue):
+        (JSC::EncodingTraits<NondeterministicInputBase>::encodeValue):
+        (JSC::EncodingTraits<KeypressCommand>::encodeValue):
+        (JSC::EncodingTraits<PlatformKeyboardEvent>::encodeValue):
+        (JSC::EncodingTraits<PlatformMouseEvent>::encodeValue):
+        (JSC::EncodingTraits<ResourceError>::encodeValue):
+        (JSC::EncodingTraits<ResourceError>::decodeValue):
+        (JSC::EncodingTraits<ResourceLoadTiming>::encodeValue):
+        (JSC::EncodingTraits<ResourceLoadTiming>::decodeValue):
+        (JSC::EncodingTraits<ResourceResponse>::encodeValue):
+        (JSC::EncodingTraits<ResourceResponse>::decodeValue):
+        (JSC::EncodingTraits<SharedBuffer>::encodeValue):
+        (JSC::EncodingTraits<SharedBuffer>::decodeValue):
+        * replay/SerializationMethods.h:
+        * replay/WebInputs.json:
+
+2014-06-12  Brian Burg  <burg@cs.washington.edu>
+
         Move createUniqueIdentifier() from ProgressTracker to DocumentLoader
         https://bugs.webkit.org/show_bug.cgi?id=130865
 
         Reviewed by NOBODY (OOPS!).
 
         In preparation for supporting replay of resource loader callbacks, this patch
         moves vending of resource load identifiers to the main frame's document loader.
         This will enable tracking of vended identifiers on a per-main frame basis.
 
         No new tests. No behavior was changed.
diff --git a/Source/WebCore/WebCore.exp.in b/Source/WebCore/WebCore.exp.in
index 8d1fd40..bdbd7c5 100644
--- a/Source/WebCore/WebCore.exp.in
+++ b/Source/WebCore/WebCore.exp.in
@@ -3445,10 +3445,18 @@ __ZN7WebCore32WebVideoFullscreenInterfaceAVKitC2Ev
 __ZTVN7WebCore32WebVideoFullscreenInterfaceAVKitE
 #endif
 
 #if ENABLE(VIDEO_TRACK)
 __ZN7WebCore9PageGroup18captionPreferencesEv
 #endif
 
 #if ENABLE(VIEW_MODE_CSS_MEDIA)
 __ZN7WebCore4Page11setViewModeENS0_8ViewModeE
 #endif
+
+#if ENABLE(WEB_REPLAY)
+__ZNK7WebCore14ResourceLoader17activeInputCursorEv
+#endif
+
+#if ENABLE(WEB_TIMING)
+__ZNK7WebCore20ResourceResponseBase18resourceLoadTimingEv
+#endif
diff --git a/Source/WebCore/loader/DocumentLoader.cpp b/Source/WebCore/loader/DocumentLoader.cpp
index 7336ef6..ce3a04c 100644
--- a/Source/WebCore/loader/DocumentLoader.cpp
+++ b/Source/WebCore/loader/DocumentLoader.cpp
@@ -69,20 +69,24 @@
 #include <wtf/text/WTFString.h>
 
 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 #include "ArchiveFactory.h"
 #endif
 
 #if ENABLE(CONTENT_FILTERING)
 #include "ContentFilter.h"
 #endif
 
+#if ENABLE(WEB_REPLAY)
+#include <replay/InputCursor.h>
+#endif
+
 namespace WebCore {
 
 static void cancelAll(const ResourceLoaderMap& loaders)
 {
     Vector<RefPtr<ResourceLoader>> loadersCopy;
     copyValuesToVector(loaders, loadersCopy);
     for (auto& loader : loadersCopy)
         loader->cancel();
 }
 
@@ -1324,21 +1328,28 @@ void DocumentLoader::stopLoadingPlugIns()
 }
 
 void DocumentLoader::stopLoadingSubresources()
 {
     cancelAll(m_subresourceLoaders);
 }
 
 unsigned long DocumentLoader::createUniqueIdentifier()
 {
     ASSERT(frame() && frame()->mainFrame().loader().activeDocumentLoader() == this);
-    return ++s_uniqueIdentifier;
+
+    unsigned long identifier = ++s_uniqueIdentifier;
+#if ENABLE(WEB_REPLAY)
+    m_usedIdentifiers.append(identifier);
+    LOG(WebReplay, "(DocumentLoader %p) Appending resource load identifier %4lu (ordinal: %4lu) for main frame %s", this, identifier, m_usedIdentifiers.size() - 1, url().string().utf8().data());
+#endif
+
+    return identifier;
 }
 
 void DocumentLoader::addSubresourceLoader(ResourceLoader* loader)
 {
     // The main resource's underlying ResourceLoader will ask to be added here.
     // It is much simpler to handle special casing of main resource loads if we don't
     // let it be added. In the main resource load case, mainResourceLoader()
     // will still be null at this point, but m_gotFirstByte should be false here if and only
     // if we are just starting the main resource load.
     if (!m_gotFirstByte)
@@ -1560,11 +1571,38 @@ void DocumentLoader::getIconDataForIconURL(const String& urlString)
     m_iconDataCallback = IconDataCallback::create(this, iconDataCallback);
     iconDatabase().iconDataForIconURL(urlString, m_iconDataCallback);
 }
 
 void DocumentLoader::handledOnloadEvents()
 {
     m_wasOnloadHandled = true;
     applicationCacheHost()->stopDeferringEvents();
 }
 
+#if ENABLE(WEB_REPLAY)
+const Vector<unsigned long>& DocumentLoader::usedIdentifiers()
+{
+    ASSERT(frame() && frame()->mainFrame().loader().activeDocumentLoader() == this);
+
+    return m_usedIdentifiers;
+}
+
+PassRefPtr<ResourceLoader> DocumentLoader::loaderForIdentifier(unsigned long identifier)
+{
+    auto foundSubresourceLoader = m_subresourceLoaders.find(identifier);
+    if (foundSubresourceLoader != m_subresourceLoaders.end())
+        return foundSubresourceLoader->value;
+
+    auto foundMultipartLoader = m_multipartSubresourceLoaders.find(identifier);
+    if (foundMultipartLoader != m_multipartSubresourceLoaders.end())
+        return foundMultipartLoader->value;
+
+    auto foundPluginStreamLoader = m_plugInStreamLoaders.find(identifier);
+    if (foundPluginStreamLoader != m_plugInStreamLoaders.end())
+        return foundPluginStreamLoader->value;
+
+    ASSERT(isLoadingMainResource() && mainResourceLoader()->identifier() == identifier);
+    return mainResourceLoader();
+}
+#endif // ENABLE(WEB_REPLAY)
+
 } // namespace WebCore
diff --git a/Source/WebCore/loader/DocumentLoader.h b/Source/WebCore/loader/DocumentLoader.h
index 396fffb..cf8c5f4 100644
--- a/Source/WebCore/loader/DocumentLoader.h
+++ b/Source/WebCore/loader/DocumentLoader.h
@@ -225,20 +225,24 @@ namespace WebCore {
         void stopLoadingPlugIns();
         void stopLoadingSubresources();
 
         unsigned long createUniqueIdentifier();
 
         void addSubresourceLoader(ResourceLoader*);
         void removeSubresourceLoader(ResourceLoader*);
         WEBCORE_EXPORT void addPlugInStreamLoader(ResourceLoader*);
         WEBCORE_EXPORT void removePlugInStreamLoader(ResourceLoader*);
 
+#if ENABLE(WEB_REPLAY)
+        const Vector<unsigned long>& usedIdentifiers();
+        PassRefPtr<ResourceLoader> loaderForIdentifier(unsigned long identifier);
+#endif
         void subresourceLoaderFinishedLoadingOnePart(ResourceLoader*);
 
         void setDeferMainResourceDataLoad(bool defer) { m_deferMainResourceDataLoad = defer; }
         
         void didTellClientAboutLoad(const String& url)
         { 
 #if !PLATFORM(COCOA)
             // Don't include data urls here, as if a lot of data is loaded
             // that way, we hold on to the (large) url string for too long.
             if (protocolIs(url, "data"))
@@ -422,20 +426,24 @@ namespace WebCore {
         friend class ApplicationCacheHost;  // for substitute resource delivery
         OwnPtr<ApplicationCacheHost> m_applicationCacheHost;
 
 #if ENABLE(CONTENT_FILTERING)
         std::unique_ptr<ContentFilter> m_contentFilter;
 #endif
 
 #if USE(QUICK_LOOK)
         std::unique_ptr<QuickLookHandle> m_quickLookHandle;
 #endif
+
+#if ENABLE(WEB_REPLAY)
+        Vector<unsigned long> m_usedIdentifiers;
+#endif
     };
 
     inline void DocumentLoader::recordMemoryCacheLoadForFutureClientNotification(const ResourceRequest& request)
     {
         m_resourcesLoadedFromMemoryCacheForClientNotification.append(request);
     }
 
     inline void DocumentLoader::takeMemoryCacheLoadsForClientNotification(Vector<ResourceRequest>& loadsSet)
     {
         loadsSet.swap(m_resourcesLoadedFromMemoryCacheForClientNotification);
diff --git a/Source/WebCore/loader/ResourceLoadScheduler.cpp b/Source/WebCore/loader/ResourceLoadScheduler.cpp
index 8a41b87..019fa24 100644
--- a/Source/WebCore/loader/ResourceLoadScheduler.cpp
+++ b/Source/WebCore/loader/ResourceLoadScheduler.cpp
@@ -35,20 +35,24 @@
 #include "Logging.h"
 #include "NetscapePlugInStreamLoader.h"
 #include "PlatformStrategies.h"
 #include "ResourceLoader.h"
 #include "ResourceRequest.h"
 #include "SubresourceLoader.h"
 #include <wtf/MainThread.h>
 #include <wtf/TemporaryChange.h>
 #include <wtf/text/CString.h>
 
+#if ENABLE(WEB_REPLAY)
+#include <replay/InputCursor.h>
+#endif
+
 #if PLATFORM(IOS)
 #include <RuntimeApplicationChecksIOS.h>
 #endif
 
 #if USE(QUICK_LOOK)
 #include "QuickLook.h"
 #endif
 
 namespace WebCore {
 
@@ -292,20 +296,25 @@ void ResourceLoadScheduler::servePendingRequests(HostInformation* host, Resource
             // For named hosts - which are only http(s) hosts - we should always enforce the connection limit.
             // For non-named hosts - everything but http(s) - we should only enforce the limit if the document isn't done parsing 
             // and we don't know all stylesheets yet.
             Document* document = resourceLoader->frameLoader() ? resourceLoader->frameLoader()->frame().document() : 0;
             bool shouldLimitRequests = !host->name().isNull() || (document && (document->parsing() || !document->haveStylesheetsLoaded()));
             if (shouldLimitRequests && host->limitRequests(ResourceLoadPriority(priority)))
                 return;
 
             requestsPending.removeFirst();
             host->addLoadInProgress(resourceLoader.get());
+#if ENABLE(WEB_REPLAY)
+            JSC::InputCursor* cursor = resourceLoader->activeInputCursor();
+            if (cursor && cursor->isReplaying())
+                continue;
+#endif
 #if PLATFORM(IOS)
             if (!applicationIsWebProcess()) {
                 resourceLoader->startLoading();
                 return;
             }
 #endif
             resourceLoader->start();
         }
     }
 }
diff --git a/Source/WebCore/loader/ResourceLoader.cpp b/Source/WebCore/loader/ResourceLoader.cpp
index 1b08c5d..de19cb8 100644
--- a/Source/WebCore/loader/ResourceLoader.cpp
+++ b/Source/WebCore/loader/ResourceLoader.cpp
@@ -44,20 +44,25 @@
 #include "PlatformStrategies.h"
 #include "ResourceBuffer.h"
 #include "ResourceError.h"
 #include "ResourceHandle.h"
 #include "ResourceLoadScheduler.h"
 #include "SecurityOrigin.h"
 #include "Settings.h"
 #include "SharedBuffer.h"
 #include <wtf/Ref.h>
 
+#if ENABLE(WEB_REPLAY)
+#include "ReplayController.h"
+#include <replay/InputCursor.h>
+#endif
+
 namespace WebCore {
 
 ResourceLoader::ResourceLoader(Frame* frame, ResourceLoaderOptions options)
     : m_frame(frame)
     , m_documentLoader(frame->loader().activeDocumentLoader())
     , m_identifier(0)
     , m_reachedTerminalState(false)
     , m_notifiedLoadComplete(false)
     , m_cancellationStatus(NotCancelled)
     , m_defersLoading(frame->page()->defersLoading())
@@ -616,11 +621,29 @@ void ResourceLoader::unschedule(SchedulePair& pair)
 #endif
 
 #if USE(QUICK_LOOK)
 void ResourceLoader::didCreateQuickLookHandle(QuickLookHandle& handle)
 {
     m_isQuickLookResource = true;
     frameLoader()->client().didCreateQuickLookHandle(handle);
 }
 #endif
 
+#if ENABLE(WEB_REPLAY)
+InputCursor* ResourceLoader::activeInputCursor() const
+{
+    if (!m_frame)
+        return nullptr;
+
+    InputCursor* documentCursor = m_frame->document() ? &m_frame->document()->inputCursor() : nullptr;
+    InputCursor* pageCursor = m_frame->page() ? &m_frame->page()->replayController().activeInputCursor() : nullptr;
+
+    bool isMainFrameNavigating = m_frame->isMainFrame() && m_frame->loader().state() == FrameStateProvisional;
+    // This is tricky. During the initial call to DocumentLoader::startLoadingMainResource(), the CachedResource
+    // for the main resource is scheduled before mainResourceLoader() is set, but after isLoadingMainResource() is set.
+    ResourceLoader* registeredMainResourceLoader = m_frame->loader().activeDocumentLoader()->mainResourceLoader();
+    bool isLoaderForMainResource = registeredMainResourceLoader == this || (!registeredMainResourceLoader && m_frame->loader().activeDocumentLoader()->isLoadingMainResource());
+    return (isMainFrameNavigating && isLoaderForMainResource) ? pageCursor : documentCursor;
+}
+#endif
+
 }
diff --git a/Source/WebCore/loader/ResourceLoader.h b/Source/WebCore/loader/ResourceLoader.h
index e37f0c2..69d6734 100644
--- a/Source/WebCore/loader/ResourceLoader.h
+++ b/Source/WebCore/loader/ResourceLoader.h
@@ -33,20 +33,26 @@
 #include "ResourceLoaderOptions.h"
 #include "ResourceLoaderTypes.h"
 #include "ResourceRequest.h"
 #include "ResourceResponse.h"
 #include <wtf/Forward.h>
 
 namespace WTF {
 class SchedulePair;
 }
 
+#if ENABLE(WEB_REPLAY)
+namespace JSC {
+class InputCursor;
+}
+#endif
+
 namespace WebCore {
 
 class AuthenticationChallenge;
 class DocumentLoader;
 class Frame;
 class FrameLoader;
 class URL;
 class ResourceBuffer;
 
 #if USE(QUICK_LOOK)
@@ -131,20 +137,24 @@ public:
 
     void setDataBufferingPolicy(DataBufferingPolicy);
 
     void willSwitchToSubstituteResource();
 
 #if PLATFORM(MAC)
     void schedule(WTF::SchedulePair&);
     void unschedule(WTF::SchedulePair&);
 #endif
 
+#if ENABLE(WEB_REPLAY)
+    JSC::InputCursor* activeInputCursor() const;
+#endif
+
 protected:
     ResourceLoader(Frame*, ResourceLoaderOptions);
 
     friend class ResourceLoadScheduler; // for access to start()
     // start() actually sends the load to the network (unless the load is being
     // deferred) and should only be called by ResourceLoadScheduler or setDefersLoading().
     void start();
 
     void didFinishLoadingOnePart(double finishTime);
     void cleanupForError(const ResourceError&);
diff --git a/Source/WebCore/loader/SubresourceLoader.cpp b/Source/WebCore/loader/SubresourceLoader.cpp
index cbb0561..24704fc 100644
--- a/Source/WebCore/loader/SubresourceLoader.cpp
+++ b/Source/WebCore/loader/SubresourceLoader.cpp
@@ -41,20 +41,28 @@
 #include "ResourceBuffer.h"
 #include <wtf/Ref.h>
 #include <wtf/RefCountedLeakCounter.h>
 #include <wtf/StdLibExtras.h>
 #include <wtf/text/CString.h>
 
 #if PLATFORM(IOS)
 #include <RuntimeApplicationChecksIOS.h>
 #endif
 
+#if ENABLE(WEB_REPLAY)
+#include "CapturingInputCursor.h"
+#include "MainFrame.h"
+#include "ReplayController.h"
+#include "SerializationMethods.h"
+#include "WebReplayInputs.h"
+#endif
+
 namespace WebCore {
 
 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, subresourceLoaderCounter, ("SubresourceLoader"));
 
 SubresourceLoader::RequestCountTracker::RequestCountTracker(CachedResourceLoader* cachedResourceLoader, CachedResource* resource)
     : m_cachedResourceLoader(cachedResourceLoader)
     , m_resource(resource)
 {
     m_cachedResourceLoader->incrementRequestCount(m_resource);
 }
@@ -176,32 +184,51 @@ void SubresourceLoader::willSendRequest(ResourceRequest& newRequest, const Resou
 
     ResourceLoader::willSendRequest(newRequest, redirectResponse);
     if (newRequest.isNull())
         cancel();
 }
 
 void SubresourceLoader::didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent)
 {
     ASSERT(m_state == Initialized);
     Ref<SubresourceLoader> protect(*this);
+
+#if ENABLE(WEB_REPLAY)
+    InputCursor* cursor = activeInputCursor();
+    if (cursor && cursor->isCapturing())
+        cursor->appendInput<ResourceLoaderDidSendData>(ordinalForIdentifier(), frameIndexFromFrame(m_frame.get()), bytesSent, totalBytesToBeSent);
+
+    EventLoopInputExtent extent(cursor);
+#endif
+
     m_resource->didSendData(bytesSent, totalBytesToBeSent);
 }
 
 void SubresourceLoader::didReceiveResponse(const ResourceResponse& response)
 {
     ASSERT(!response.isNull());
     ASSERT(m_state == Initialized);
 
     // Reference the object in this method since the additional processing can do
     // anything including removing the last reference to this object; one example of this is 3266216.
     Ref<SubresourceLoader> protect(*this);
 
+#if ENABLE(WEB_REPLAY)
+    InputCursor* cursor = activeInputCursor();
+    if (cursor && cursor->isCapturing()) {
+        OwnPtr<ResourceResponse> ownedResponse = ResourceResponse::adopt(response.copyData());
+        cursor->appendInput<ResourceLoaderDidReceiveResponse>(ordinalForIdentifier(), frameIndexFromFrame(m_frame.get()), std::unique_ptr<ResourceResponse>(ownedResponse.leakPtr()));
+    }
+
+    EventLoopInputExtent extent(cursor);
+#endif
+
     if (m_resource->resourceToRevalidate()) {
         if (response.httpStatusCode() == 304) {
             // 304 Not modified / Use local copy
             // Existing resource is ok, just use it updating the expiration time.
             m_resource->setResponse(response);
             memoryCache()->revalidationSucceeded(m_resource, response);
             if (!reachedTerminalState())
                 ResourceLoader::didReceiveResponse(response);
             return;
         }
@@ -259,21 +286,35 @@ void SubresourceLoader::didReceiveDataOrBuffer(const char* data, int length, Pas
 {
     if (m_resource->response().httpStatusCode() >= 400 && !m_resource->shouldIgnoreHTTPStatusCodeErrors())
         return;
     ASSERT(!m_resource->resourceToRevalidate());
     ASSERT(!m_resource->errorOccurred());
     ASSERT(m_state == Initialized);
     // Reference the object in this method since the additional processing can do
     // anything including removing the last reference to this object; one example of this is 3266216.
     Ref<SubresourceLoader> protect(*this);
     RefPtr<SharedBuffer> buffer = prpBuffer;
-    
+
+#if ENABLE(WEB_REPLAY)
+    InputCursor* cursor = activeInputCursor();
+    if (cursor && cursor->isCapturing()) {
+        RefPtr<SharedBuffer> serializedBuffer = buffer;
+        if (!serializedBuffer)
+            serializedBuffer = SharedBuffer::create(data, length);
+        cursor->appendInput<ResourceLoaderDidReceiveData>(ordinalForIdentifier(), frameIndexFromFrame(m_frame.get()), serializedBuffer, encodedDataLength);
+    }
+    // If the main resource changes, then a new input cursor will be created for a new replay session segment.
+    // FIXME: Is there a good place to add RAII to check extent of the first input for the new input cursor?
+    RefPtr<InputCursor> protectCursor(cursor);
+    EventLoopInputExtent extent(cursor);
+#endif
+
     ResourceLoader::didReceiveDataOrBuffer(data, length, buffer, encodedDataLength, dataPayloadType);
 
     if (!m_loadingMultipartContent) {
         if (ResourceBuffer* resourceData = this->resourceData())
             m_resource->addDataBuffer(resourceData);
         else
             m_resource->addData(buffer ? buffer->data() : data, buffer ? buffer->size() : length);
     }
 }
 
@@ -292,20 +333,29 @@ void SubresourceLoader::didFinishLoading(double finishTime)
 {
     if (m_state != Initialized)
         return;
     ASSERT(!reachedTerminalState());
     ASSERT(!m_resource->resourceToRevalidate());
     // FIXME (129394): We should cancel the load when a decode error occurs instead of continuing the load to completion.
     ASSERT(!m_resource->errorOccurred() || m_resource->status() == CachedResource::DecodeError);
     LOG(ResourceLoading, "Received '%s'.", m_resource->url().string().latin1().data());
 
     Ref<SubresourceLoader> protect(*this);
+
+#if ENABLE(WEB_REPLAY)
+    InputCursor* cursor = activeInputCursor();
+    if (cursor && cursor->isCapturing())
+        cursor->appendInput<ResourceLoaderDidFinishLoading>(ordinalForIdentifier(), frameIndexFromFrame(m_frame.get()), finishTime);
+
+    EventLoopInputExtent extent(cursor);
+#endif
+
     CachedResourceHandle<CachedResource> protectResource(m_resource);
 
     m_state = Finishing;
     m_resource->setLoadFinishTime(finishTime);
     m_resource->finishLoading(resourceData());
 
     if (wasCancelled())
         return;
     m_resource->finish();
     ASSERT(!reachedTerminalState());
@@ -317,20 +367,29 @@ void SubresourceLoader::didFinishLoading(double finishTime)
 }
 
 void SubresourceLoader::didFail(const ResourceError& error)
 {
     if (m_state != Initialized)
         return;
     ASSERT(!reachedTerminalState());
     LOG(ResourceLoading, "Failed to load '%s'.\n", m_resource->url().string().latin1().data());
 
     Ref<SubresourceLoader> protect(*this);
+
+#if ENABLE(WEB_REPLAY)
+    InputCursor* cursor = activeInputCursor();
+    if (cursor && cursor->isCapturing())
+        cursor->appendInput<ResourceLoaderDidFail>(ordinalForIdentifier(), frameIndexFromFrame(m_frame.get()), std::move(error.ownedCopy()));
+
+    EventLoopInputExtent extent(cursor);
+#endif
+
     CachedResourceHandle<CachedResource> protectResource(m_resource);
     m_state = Finishing;
     if (m_resource->resourceToRevalidate())
         memoryCache()->revalidationFailed(m_resource);
     m_resource->setResourceError(error);
     if (!m_resource->isPreloaded())
         memoryCache()->remove(m_resource);
     m_resource->error(CachedResource::LoadError);
     cleanupForError(error);
     notifyDone();
@@ -396,11 +455,22 @@ void SubresourceLoader::releaseResources()
 #if PLATFORM(IOS)
     if (m_state != Uninitialized && m_state != CancelledWhileInitializing)
 #else
     if (m_state != Uninitialized)
 #endif
         m_resource->clearLoader();
     m_resource = 0;
     ResourceLoader::releaseResources();
 }
 
+#if ENABLE(WEB_REPLAY)
+unsigned long SubresourceLoader::ordinalForIdentifier()
+{
+    ASSERT(frameLoader());
+    auto& usedIdentifiers = frameLoader()->frame().mainFrame().loader().activeDocumentLoader()->usedIdentifiers();
+    unsigned long ordinal = usedIdentifiers.reverseFind(identifier());
+    ASSERT(ordinal != WTF::notFound);
+    return ordinal;
+}
+#endif
+
 }
diff --git a/Source/WebCore/loader/SubresourceLoader.h b/Source/WebCore/loader/SubresourceLoader.h
index 303ffd9..ab9ed71 100644
--- a/Source/WebCore/loader/SubresourceLoader.h
+++ b/Source/WebCore/loader/SubresourceLoader.h
@@ -90,20 +90,24 @@ private:
 #if USE(SOUP)
     virtual char* getOrCreateReadBuffer(size_t requestedSize, size_t& actualSize) override;
 #endif
 
     bool checkForHTTPStatusCodeError();
 
     void didReceiveDataOrBuffer(const char*, int, PassRefPtr<SharedBuffer>, long long encodedDataLength, DataPayloadType);
 
     void notifyDone();
 
+#if ENABLE(WEB_REPLAY)
+    unsigned long ordinalForIdentifier();
+#endif
+
     enum SubresourceLoaderState {
         Uninitialized,
         Initialized,
         Finishing,
 #if PLATFORM(IOS)
         CancelledWhileInitializing
 #endif
     };
 
     class RequestCountTracker {
diff --git a/Source/WebCore/platform/network/FormData.cpp b/Source/WebCore/platform/network/FormData.cpp
index 263ab2a..48c46cd 100644
--- a/Source/WebCore/platform/network/FormData.cpp
+++ b/Source/WebCore/platform/network/FormData.cpp
@@ -31,21 +31,21 @@
 #include "File.h"
 #include "FileSystem.h"
 #include "FormDataBuilder.h"
 #include "FormDataList.h"
 #include "MIMETypeRegistry.h"
 #include "Page.h"
 #include "TextEncoding.h"
 
 namespace WebCore {
 
-inline FormData::FormData()
+FormData::FormData()
     : m_identifier(0)
     , m_alwaysStream(false)
     , m_containsPasswordData(false)
 {
 }
 
 inline FormData::FormData(const FormData& data)
     : RefCounted<FormData>()
     , m_elements(data.m_elements)
     , m_identifier(data.m_identifier)
diff --git a/Source/WebCore/platform/network/ResourceErrorBase.cpp b/Source/WebCore/platform/network/ResourceErrorBase.cpp
index ce58f8e..27c9cc4 100644
--- a/Source/WebCore/platform/network/ResourceErrorBase.cpp
+++ b/Source/WebCore/platform/network/ResourceErrorBase.cpp
@@ -40,20 +40,28 @@ ResourceError ResourceErrorBase::copy() const
     errorCopy.m_errorCode = m_errorCode;
     errorCopy.m_failingURL = m_failingURL.isolatedCopy();
     errorCopy.m_localizedDescription = m_localizedDescription.isolatedCopy();
     errorCopy.m_isNull = m_isNull;
     errorCopy.m_isCancellation = m_isCancellation;
     errorCopy.m_isTimeout = m_isTimeout;
     platformCopy(errorCopy);
     return errorCopy;
 }
 
+std::unique_ptr<ResourceError> ResourceErrorBase::ownedCopy() const
+{
+    auto error = std::make_unique<ResourceError>(domain(), errorCode(), failingURL(), localizedDescription());
+    error->setIsCancellation(isCancellation());
+    error->setIsTimeout(isTimeout());
+    return std::move(error);
+}
+
 void ResourceErrorBase::lazyInit() const
 {
     const_cast<ResourceError*>(static_cast<const ResourceError*>(this))->platformLazyInit();
 }
 
 bool ResourceErrorBase::compare(const ResourceError& a, const ResourceError& b)
 {
     if (a.isNull() && b.isNull())
         return true;
 
diff --git a/Source/WebCore/platform/network/ResourceErrorBase.h b/Source/WebCore/platform/network/ResourceErrorBase.h
index 5ae837c..e28d1a9 100644
--- a/Source/WebCore/platform/network/ResourceErrorBase.h
+++ b/Source/WebCore/platform/network/ResourceErrorBase.h
@@ -31,20 +31,21 @@
 namespace WebCore {
 
 class ResourceError;
 
 extern const char* const errorDomainWebKitInternal; // Used for errors that won't be exposed to clients.
 
 class ResourceErrorBase {
 public:
     // Makes a deep copy. Useful for when you need to use a ResourceError on another thread.
     ResourceError copy() const;
+    std::unique_ptr<ResourceError> ownedCopy() const;
 
     bool isNull() const { return m_isNull; }
 
     const String& domain() const { lazyInit(); return m_domain; }
     int errorCode() const { lazyInit(); return m_errorCode; }
     const String& failingURL() const { lazyInit(); return m_failingURL; }
     const String& localizedDescription() const { lazyInit(); return m_localizedDescription; }
 
     void setIsCancellation(bool isCancellation) { m_isCancellation = isCancellation; }
     bool isCancellation() const { return m_isCancellation; }
diff --git a/Source/WebCore/replay/ReplayInputDispatchMethods.cpp b/Source/WebCore/replay/ReplayInputDispatchMethods.cpp
index 5bd4446..97daede 100644
--- a/Source/WebCore/replay/ReplayInputDispatchMethods.cpp
+++ b/Source/WebCore/replay/ReplayInputDispatchMethods.cpp
@@ -1,12 +1,12 @@
 /*
- * Copyright (C) 2011-2013 University of Washington.
+ * Copyright (C) 2011-2014 University of Washington.
  * Copyright (C) 2014 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
  *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
@@ -23,31 +23,47 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 
 #if ENABLE(WEB_REPLAY)
 
 #include "AllReplayInputs.h"
 #include "Document.h"
+#include "DocumentLoader.h"
 #include "MainFrame.h"
 #include "NavigationScheduler.h"
 #include "Page.h"
 #include "ReplayController.h"
 #include "ReplayableTimers.h"
+#include "ResourceError.h"
+#include "ResourceLoader.h"
+#include "SerializationMethods.h"
 #include "URL.h"
 #include "UserInputBridge.h"
 #include <cinttypes>
 
 namespace WebCore {
 
+static ResourceLoader* resourceLoaderForOrdinal(Page& page, unsigned long ordinal, int frameIndex)
+{
+    Frame* frame = frameFromFrameIndex(&page, frameIndex);
+    ASSERT(frame);
+
+    const Vector<unsigned long>& usedIdentifiers = frame->mainFrame().loader().activeDocumentLoader()->usedIdentifiers();
+    ASSERT(ordinal < usedIdentifiers.size());
+
+    RefPtr<ResourceLoader> loader = frame->loader().activeDocumentLoader()->loaderForIdentifier(usedIdentifiers.at(ordinal));
+    return loader ? loader.get() : nullptr;
+}
+
 // Sentinel inputs.
 void BeginSegmentSentinel::dispatch(ReplayController&)
 {
 }
 
 void EndSegmentSentinel::dispatch(ReplayController&)
 {
 }
 
 // Navigation inputs.
@@ -88,20 +104,56 @@ void HandleWheelEvent::dispatch(ReplayController& controller)
 void LogicalScrollPage::dispatch(ReplayController& controller)
 {
     controller.page().userInputBridge().logicalScrollRecursively(direction(), granularity(), InputSource::Synthetic);
 }
 
 void ScrollPage::dispatch(ReplayController& controller)
 {
     controller.page().userInputBridge().scrollRecursively(direction(), granularity(), InputSource::Synthetic);
 }
 
+// Network inputs.
+void ResourceLoaderDidFail::dispatch(ReplayController& controller)
+{
+    if (ResourceLoader* loader = resourceLoaderForOrdinal(controller.page(), ordinal(), frameIndex()))
+        loader->didFail(m_error->copy());
+    // FIXME: signal error if the callback couldn't be fired.
+}
+
+void ResourceLoaderDidFinishLoading::dispatch(ReplayController& controller)
+{
+    if (ResourceLoader* loader = resourceLoaderForOrdinal(controller.page(), ordinal(), frameIndex()))
+        loader->didFinishLoading(m_finishTime);
+    // FIXME: signal error if the callback couldn't be fired.
+}
+
+void ResourceLoaderDidReceiveData::dispatch(ReplayController& controller)
+{
+    if (ResourceLoader* loader = resourceLoaderForOrdinal(controller.page(), ordinal(), frameIndex()))
+        loader->didReceiveData(buffer()->data(), buffer()->size(), encodedLength(), DataPayloadBytes);
+    // FIXME: signal error if the callback couldn't be fired.
+}
+
+void ResourceLoaderDidReceiveResponse::dispatch(ReplayController& controller)
+{
+    if (ResourceLoader* loader = resourceLoaderForOrdinal(controller.page(), ordinal(), frameIndex()))
+        loader->didReceiveResponse(*m_response);
+    // FIXME: signal error if the callback couldn't be fired.
+}
+
+void ResourceLoaderDidSendData::dispatch(ReplayController& controller)
+{
+    if (ResourceLoader* loader = resourceLoaderForOrdinal(controller.page(), ordinal(), frameIndex()))
+        loader->didSendData(m_bytesSent, m_totalBytesToBeSent);
+    // FIXME: signal error if the callback couldn't be fired.
+}
+
 // Other event loop inputs.
 void AsyncTimerFired::dispatch(ReplayController& controller)
 {
     Document* document = documentFromFrameIndex(&controller.page(), m_frameIndex);
     if (!document || !document->replayableTimers().fireTimer(m_ordinal))
         LOG_ERROR("%-30s REPLAY DIVERGENCE! Couldn't find async timer %d/%" PRIu64 ".\n", "[ReplayController]", m_frameIndex, m_ordinal);
 }
 
 } // namespace WebCore
 
diff --git a/Source/WebCore/replay/SerializationMethods.cpp b/Source/WebCore/replay/SerializationMethods.cpp
index 6a9d2c0..47d5643 100644
--- a/Source/WebCore/replay/SerializationMethods.cpp
+++ b/Source/WebCore/replay/SerializationMethods.cpp
@@ -27,42 +27,52 @@
 
 #include "config.h"
 #include "SerializationMethods.h"
 
 #if ENABLE(WEB_REPLAY)
 
 #include "AllReplayInputs.h"
 #include "Document.h"
 #include "Frame.h"
 #include "FrameTree.h"
+#include "HTTPHeaderMap.h"
 #include "MainFrame.h"
 #include "Page.h"
 #include "PlatformKeyboardEvent.h"
 #include "PlatformMouseEvent.h"
 #include "PlatformWheelEvent.h"
 #include "PluginData.h"
 #include "ReplayInputTypes.h"
+#include "ResourceError.h"
+#include "ResourceLoadTiming.h"
+#include "ResourceResponse.h"
 #include "SecurityOrigin.h"
+#include "SharedBuffer.h"
 #include "URL.h"
 #include <wtf/text/Base64.h>
 
+using WebCore::HTTPHeaderMap;
 using WebCore::IntPoint;
 using WebCore::MimeClassInfo;
 using WebCore::MouseButton;
 using WebCore::PlatformEvent;
 using WebCore::PlatformKeyboardEvent;
 using WebCore::PlatformMouseEvent;
 using WebCore::PlatformWheelEvent;
 using WebCore::PlatformWheelEventGranularity;
 using WebCore::PluginData;
 using WebCore::PluginInfo;
+using WebCore::ResourceError;
+using WebCore::ResourceLoadTiming;
+using WebCore::ResourceResponse;
 using WebCore::SecurityOrigin;
+using WebCore::SharedBuffer;
 using WebCore::URL;
 using WebCore::inputTypes;
 
 #if PLATFORM(COCOA)
 using WebCore::KeypressCommand;
 using WebCore::PlatformWheelEventPhase;
 #endif
 
 #define IMPORT_FROM_WEBCORE_NAMESPACE(name) \
 using WebCore::name; \
@@ -132,20 +142,54 @@ Frame* frameFromFrameIndex(Page* page, uint32_t frameIndex)
 
 #define DECODE_OPTIONAL_TYPE_WITH_KEY_TO_LVALUE(_encodedValue, _type, _key, _lvalue) \
     bool _key ## WasDecoded = _encodedValue.get<_type>(ASCIILiteral(#_key), _lvalue)
 
 #define DECODE_OPTIONAL_TYPE_WITH_KEY(_encodedValue, _type, _key) \
     EncodingTraits<_type>::DecodedType _key; \
     DECODE_OPTIONAL_TYPE_WITH_KEY_TO_LVALUE(_encodedValue, _type, _key, _key)
 
 namespace JSC {
 
+EncodedValue EncodingTraits<HTTPHeaderMap>::encodeValue(const HTTPHeaderMap& headerMap)
+{
+    EncodedValue encodedData = EncodedValue::createObject();
+    EncodedValue encodedKeys = EncodedValue::createArray();
+    EncodedValue encodedValues = EncodedValue::createArray();
+
+    for (auto it = headerMap.begin(); it != headerMap.end(); ++it) {
+        encodedKeys.append<String>(it->key);
+        encodedValues.append<String>(it->value);
+    }
+
+    ENCODE_TYPE_WITH_KEY(encodedData, EncodedValue, keys, encodedKeys);
+    ENCODE_TYPE_WITH_KEY(encodedData, EncodedValue, values, encodedValues);
+
+    return encodedData;
+}
+
+bool EncodingTraits<HTTPHeaderMap>::decodeValue(EncodedValue& encodedData, std::unique_ptr<HTTPHeaderMap>& decodedValue)
+{
+    std::unique_ptr<HTTPHeaderMap> decodedHeaderMap = std::make_unique<HTTPHeaderMap>();
+
+    DECODE_TYPE_WITH_KEY(encodedData, Vector<String>, keys);
+    DECODE_TYPE_WITH_KEY(encodedData, Vector<String>, values);
+
+    if (keys.size() != values.size())
+        return false;
+
+    for (size_t i = 0; i < keys.size(); ++i)
+        decodedHeaderMap->add(keys[i], values[i]);
+
+    decodedValue = std::move(decodedHeaderMap);
+    return true;
+}
+
 template<>
 EncodedValue EncodingTraits<MimeClassInfo>::encodeValue(const MimeClassInfo& input)
 {
     EncodedValue encodedData = EncodedValue::createObject();
 
     ENCODE_TYPE_WITH_KEY(encodedData, String, type, input.type);
     ENCODE_TYPE_WITH_KEY(encodedData, String, desc, input.desc);
     ENCODE_TYPE_WITH_KEY(encodedData, Vector<String>, extensions, input.extensions);
 
     return encodedData;
@@ -501,31 +545,154 @@ bool EncodingTraits<PluginInfo>::decodeValue(EncodedValue& encodedData, PluginIn
     DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, String, name, info.name);
     DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, String, file, info.file);
     DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, String, desc, info.desc);
     DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, Vector<MimeClassInfo>, mimes, info.mimes);
     DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, bool, isApplicationPlugin, info.isApplicationPlugin);
 
     input = info;
     return true;
 }
 
+EncodedValue EncodingTraits<ResourceError>::encodeValue(const ResourceError& error)
+{
+    EncodedValue encodedData = EncodedValue::createObject();
+
+    ENCODE_TYPE_WITH_KEY(encodedData, String, domain, error.domain());
+    ENCODE_TYPE_WITH_KEY(encodedData, int, errorCode, error.errorCode());
+    ENCODE_TYPE_WITH_KEY(encodedData, String, failingURL, error.failingURL());
+    ENCODE_TYPE_WITH_KEY(encodedData, String, localizedDescription, error.localizedDescription());
+
+    return encodedData;
+}
+
+bool EncodingTraits<ResourceError>::decodeValue(EncodedValue& encodedData, std::unique_ptr<ResourceError>& decodedError)
+{
+    DECODE_TYPE_WITH_KEY(encodedData, String, domain);
+    DECODE_TYPE_WITH_KEY(encodedData, int, errorCode);
+    DECODE_TYPE_WITH_KEY(encodedData, String, failingURL);
+    DECODE_TYPE_WITH_KEY(encodedData, String, localizedDescription);
+
+    decodedError = std::make_unique<ResourceError>(domain, errorCode, failingURL, localizedDescription);
+    return true;
+}
+
+template<>
+EncodedValue EncodingTraits<ResourceLoadTiming>::encodeValue(const ResourceLoadTiming& timingData)
+{
+    EncodedValue encodedData = EncodedValue::createObject();
+
+    ENCODE_TYPE_WITH_KEY(encodedData, int, domainLookupStart, timingData.domainLookupStart);
+    ENCODE_TYPE_WITH_KEY(encodedData, int, domainLookupEnd, timingData.domainLookupEnd);
+    ENCODE_TYPE_WITH_KEY(encodedData, int, connectStart, timingData.connectStart);
+    ENCODE_TYPE_WITH_KEY(encodedData, int, connectEnd, timingData.connectEnd);
+    ENCODE_TYPE_WITH_KEY(encodedData, int, requestStart, timingData.requestStart);
+    ENCODE_TYPE_WITH_KEY(encodedData, int, responseStart, timingData.responseStart);
+    ENCODE_TYPE_WITH_KEY(encodedData, int, secureConnectionStart, timingData.secureConnectionStart);
+
+    return encodedData;
+}
+
+template<>
+bool EncodingTraits<ResourceLoadTiming>::decodeValue(EncodedValue& encodedData, ResourceLoadTiming& decodedTimings)
+{
+    ResourceLoadTiming timingData;
+
+    DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, int, domainLookupStart, timingData.domainLookupStart);
+    DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, int, domainLookupEnd, timingData.domainLookupEnd);
+    DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, int, connectStart, timingData.connectStart);
+    DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, int, connectEnd, timingData.connectEnd);
+    DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, int, requestStart, timingData.requestStart);
+    DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, int, responseStart, timingData.responseStart);
+    DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, int, secureConnectionStart, timingData.secureConnectionStart);
+
+    decodedTimings = timingData;
+    return true;
+}
+
+EncodedValue EncodingTraits<ResourceResponse>::encodeValue(const ResourceResponse& response)
+{
+    EncodedValue encodedData = EncodedValue::createObject();
+
+    ENCODE_TYPE_WITH_KEY(encodedData, URL, url, response.url());
+    ENCODE_TYPE_WITH_KEY(encodedData, String, mimeType, response.mimeType());
+    ENCODE_TYPE_WITH_KEY(encodedData, long long, expectedContentLength, response.expectedContentLength());
+    ENCODE_TYPE_WITH_KEY(encodedData, String, textEncodingName, response.textEncodingName());
+    ENCODE_TYPE_WITH_KEY(encodedData, int, httpStatusCode, response.httpStatusCode());
+    ENCODE_TYPE_WITH_KEY(encodedData, String, httpStatusText, response.httpStatusText());
+    ENCODE_TYPE_WITH_KEY(encodedData, HTTPHeaderMap, httpHeaders, response.httpHeaderFields());
+    ENCODE_TYPE_WITH_KEY(encodedData, ResourceLoadTiming, loadTiming, response.resourceLoadTiming());
+
+    return encodedData;
+}
+
+bool EncodingTraits<ResourceResponse>::decodeValue(EncodedValue& encodedData, std::unique_ptr<ResourceResponse>& decodedResponse)
+{
+    DECODE_TYPE_WITH_KEY(encodedData, URL, url);
+    DECODE_TYPE_WITH_KEY(encodedData, String, mimeType);
+    DECODE_TYPE_WITH_KEY(encodedData, long long, expectedContentLength);
+    DECODE_TYPE_WITH_KEY(encodedData, String, textEncodingName);
+
+    std::unique_ptr<ResourceResponse> response = std::make_unique<ResourceResponse>(url, mimeType, expectedContentLength, textEncodingName);
+
+    DECODE_TYPE_WITH_KEY(encodedData, int, httpStatusCode);
+    response->setHTTPStatusCode(httpStatusCode);
+
+    DECODE_TYPE_WITH_KEY(encodedData, String, httpStatusText);
+    response->setHTTPStatusText(httpStatusText);
+
+    // Manually decode so we can pass ownership of the decoded headers.
+    std::unique_ptr<HTTPHeaderMap> httpHeaders;
+    if (!EncodingTraits<HTTPHeaderMap>::decodeValue(encodedData, httpHeaders))
+        return false;
+
+    for (const auto& keyValuePair : *httpHeaders)
+        response->setHTTPHeaderField(keyValuePair.key, keyValuePair.value);
+
+    DECODE_TYPE_WITH_KEY(encodedData, ResourceLoadTiming, loadTiming);
+    response->resourceLoadTiming().domainLookupStart = loadTiming.domainLookupStart;
+    response->resourceLoadTiming().domainLookupEnd = loadTiming.domainLookupEnd;
+    response->resourceLoadTiming().connectStart = loadTiming.connectStart;
+    response->resourceLoadTiming().secureConnectionStart = loadTiming.secureConnectionStart;
+    response->resourceLoadTiming().connectEnd = loadTiming.connectEnd;
+    response->resourceLoadTiming().requestStart = loadTiming.requestStart;
+    response->resourceLoadTiming().responseStart = loadTiming.responseStart;
+
+    decodedResponse = std::move(response);
+    return true;
+}
+
 EncodedValue EncodingTraits<SecurityOrigin>::encodeValue(RefPtr<SecurityOrigin> input)
 {
     return EncodedValue::createString(input->toString());
 }
 
 bool EncodingTraits<SecurityOrigin>::decodeValue(EncodedValue& encodedValue, RefPtr<SecurityOrigin>& input)
 {
     input = SecurityOrigin::createFromString(encodedValue.convertTo<String>());
     return true;
 }
 
+EncodedValue EncodingTraits<SharedBuffer>::encodeValue(RefPtr<SharedBuffer> buffer)
+{
+    return EncodedValue::createString(base64Encode(buffer->data(), buffer->size()));
+}
+
+bool EncodingTraits<SharedBuffer>::decodeValue(EncodedValue& encodedBuffer, RefPtr<SharedBuffer>& decodedBuffer)
+{
+    Vector<char, 0> data;
+    if (!base64Decode(encodedBuffer.convertTo<String>(), data))
+        return false;
+
+    decodedBuffer = SharedBuffer::adoptVector(data);
+    return true;
+}
+
 EncodedValue EncodingTraits<URL>::encodeValue(const URL& input)
 {
     return EncodedValue::createString(input.string());
 }
 
 bool EncodingTraits<URL>::decodeValue(EncodedValue& encodedValue, URL& input)
 {
     input = URL(WebCore::ParsedURLString, encodedValue.convertTo<String>());
     return true;
 }
diff --git a/Source/WebCore/replay/SerializationMethods.h b/Source/WebCore/replay/SerializationMethods.h
index e7ec315..38a1d50 100644
--- a/Source/WebCore/replay/SerializationMethods.h
+++ b/Source/WebCore/replay/SerializationMethods.h
@@ -31,42 +31,53 @@
 #if ENABLE(WEB_REPLAY)
 
 #include <replay/EncodedValue.h>
 #include <replay/NondeterministicInput.h>
 #include <wtf/Vector.h>
 
 namespace WebCore {
 
 class Document;
 class Frame;
+class HTTPHeaderMap;
 class Page;
 class PlatformKeyboardEvent;
 class PlatformMouseEvent;
 class PlatformWheelEvent;
 class PluginData;
+class ResourceError;
+class ResourceResponse;
 class SecurityOrigin;
+class SharedBuffer;
 class URL;
 
 #if USE(APPKIT)
 struct KeypressCommand;
 #endif
 
 uint32_t frameIndexFromDocument(const Document*);
 uint32_t frameIndexFromFrame(const Frame*);
 Document* documentFromFrameIndex(Page*, uint32_t frameIndex);
 Frame* frameFromFrameIndex(Page*, uint32_t frameIndex);
 
 } // namespace WebCore
 
 // Template specializations must be defined in the same namespace as the template declaration.
 namespace JSC {
 
+template<> struct EncodingTraits<WebCore::HTTPHeaderMap> {
+    typedef WebCore::HTTPHeaderMap DecodedType;
+
+    static EncodedValue encodeValue(const WebCore::HTTPHeaderMap& value);
+    static bool decodeValue(EncodedValue&, std::unique_ptr<WebCore::HTTPHeaderMap>& value);
+};
+
 #if USE(APPKIT)
 template<> struct EncodingTraits<WebCore::KeypressCommand> {
     typedef WebCore::KeypressCommand DecodedType;
 
     static EncodedValue encodeValue(const WebCore::KeypressCommand& value);
     static bool decodeValue(EncodedValue&, WebCore::KeypressCommand& value);
 };
 #endif // USE(APPKIT)
 
 template<> struct EncodingTraits<NondeterministicInputBase> {
@@ -97,29 +108,50 @@ template<> struct EncodingTraits<WebCore::PlatformWheelEvent> {
     static bool decodeValue(EncodedValue&, std::unique_ptr<WebCore::PlatformWheelEvent>& value);
 };
 
 template<> struct EncodingTraits<WebCore::PluginData> {
     typedef RefPtr<WebCore::PluginData> DecodedType;
 
     static EncodedValue encodeValue(RefPtr<WebCore::PluginData> value);
     static bool decodeValue(EncodedValue&, RefPtr<WebCore::PluginData>& value);
 };
 
-template<> struct EncodingTraits<WebCore::URL> {
-    typedef WebCore::URL DecodedType;
+template<> struct EncodingTraits<WebCore::ResourceError> {
+    typedef WebCore::ResourceError DecodedType;
 
-    static EncodedValue encodeValue(const WebCore::URL& value);
-    static bool decodeValue(EncodedValue&, WebCore::URL& value);
+    static EncodedValue encodeValue(const WebCore::ResourceError& value);
+    static bool decodeValue(EncodedValue&, std::unique_ptr<WebCore::ResourceError>& value);
+};
+
+template<> struct EncodingTraits<WebCore::ResourceResponse> {
+    typedef WebCore::ResourceResponse DecodedType;
+
+    static EncodedValue encodeValue(const WebCore::ResourceResponse& value);
+    static bool decodeValue(EncodedValue&, std::unique_ptr<WebCore::ResourceResponse>& value);
 };
 
 template<> struct EncodingTraits<WebCore::SecurityOrigin> {
     typedef RefPtr<WebCore::SecurityOrigin> DecodedType;
 
     static EncodedValue encodeValue(RefPtr<WebCore::SecurityOrigin> value);
     static bool decodeValue(EncodedValue&, RefPtr<WebCore::SecurityOrigin>& value);
 };
 
+template<> struct EncodingTraits<WebCore::SharedBuffer> {
+    typedef RefPtr<WebCore::SharedBuffer> DecodedType;
+
+    static EncodedValue encodeValue(RefPtr<WebCore::SharedBuffer> value);
+    static bool decodeValue(EncodedValue&, RefPtr<WebCore::SharedBuffer>& value);
+};
+
+template<> struct EncodingTraits<WebCore::URL> {
+    typedef WebCore::URL DecodedType;
+
+    static EncodedValue encodeValue(const WebCore::URL& value);
+    static bool decodeValue(EncodedValue&, WebCore::URL& value);
+};
+
 } // namespace JSC
 
 #endif // ENABLE(WEB_REPLAY)
 
 #endif // SerializationMethods_h
diff --git a/Source/WebCore/replay/WebInputs.json b/Source/WebCore/replay/WebInputs.json
index 599e328..1dfa9be 100644
--- a/Source/WebCore/replay/WebInputs.json
+++ b/Source/WebCore/replay/WebInputs.json
@@ -114,24 +114,36 @@
                 "flags": ["ENUM"],
                 "values": [
                     "ScrollBlockDirectionBackward",
                     "ScrollBlockDirectionForward",
                     "ScrollInlineDirectionBackward",
                     "ScrollInlineDirectionForward"
                 ],
                 "header": "platform/ScrollTypes.h"
             },
             {
+                "name": "ResourceError", "mode": "OWNED",
+                "header": "platform/network/ResourceError.h"
+            },
+            {
+                "name": "ResourceResponse", "mode": "OWNED",
+                "header": "platform/network/ResourceResponse.h"
+            },
+            {
                 "name": "SecurityOrigin", "mode": "SHARED",
                 "header": "page/SecurityOrigin.h"
             },
             {
+                "name": "SharedBuffer", "mode": "SHARED",
+                "header": "platform/SharedBuffer.h"
+            },
+            {
                 "name": "Type", "mode": "SCALAR", "storage": "uint8_t",
                 "enclosing_class": "PlatformEvent",
                 "flags": ["ENUM"],
                 "values": [
                     "NoType",
                     "KeyDown",
                     "KeyUp",
                     "RawKeyDown",
                     "Char",
                     "MouseMoved",
@@ -257,13 +269,65 @@
             ]
         },
         {
             "name": "ScrollPage",
             "description": "The embedder signalled a scroll event.",
             "queue": "EVENT_LOOP",
             "members": [
                 { "name": "direction", "type": "ScrollDirection" },
                 { "name": "granularity", "type": "ScrollGranularity" }
             ]
+        },
+        {
+            "name": "ResourceLoaderDidFail",
+            "description": "A resource loader failed to load its resource.",
+            "queue": "EVENT_LOOP",
+            "members": [
+                { "name": "ordinal", "type": "uint64_t" },
+                { "name": "frameIndex", "type": "uint32_t" },
+                { "name": "error", "type": "ResourceError" }
+            ]
+        },
+        {
+            "name": "ResourceLoaderDidFinishLoading",
+            "description": "A resource loader finished receiving a resource.",
+            "queue": "EVENT_LOOP",
+            "members": [
+                { "name": "ordinal", "type": "uint64_t" },
+                { "name": "frameIndex", "type": "uint32_t" },
+                { "name": "finishTime", "type": "double" }
+            ]
+        },
+        {
+            "name": "ResourceLoaderDidReceiveResponse",
+            "description": "A resource loader received an initial response.",
+            "queue": "EVENT_LOOP",
+            "members": [
+                { "name": "ordinal", "type": "uint64_t" },
+                { "name": "frameIndex", "type": "uint32_t" },
+                { "name": "response", "type": "ResourceResponse" }
+            ]
+        },
+        {
+            "name": "ResourceLoaderDidSendData",
+            "description": "A resource loader sent some data.",
+            "queue": "EVENT_LOOP",
+            "members": [
+                { "name": "ordinal", "type": "uint64_t" },
+                { "name": "frameIndex", "type": "uint32_t" },
+                { "name": "bytesSent", "type": "uint64_t" },
+                { "name": "totalBytesToBeSent", "type": "uint64_t" }
+            ]
+        },
+        {
+            "name": "ResourceLoaderDidReceiveData",
+            "description": "A resource loader received some data.",
+            "queue": "EVENT_LOOP",
+            "members": [
+                { "name": "ordinal", "type": "uint64_t" },
+                { "name": "frameIndex", "type": "uint32_t" },
+                { "name": "buffer", "type": "SharedBuffer" },
+                { "name": "encodedLength", "type": "int32_t" }
+            ]
         }
     ]
 }
diff --git a/Source/WebKit2/ChangeLog b/Source/WebKit2/ChangeLog
index db5060b..a6d1a5c 100644
--- a/Source/WebKit2/ChangeLog
+++ b/Source/WebKit2/ChangeLog
@@ -1,11 +1,24 @@
-2014-04-12  Brian J. Burg <burg@cs.washington.edu>
+2014-06-12  Brian Burg  <burg@cs.washington.edu>
+
+        Web Replay: capture and replay ResourceLoader callbacks
+        https://bugs.webkit.org/show_bug.cgi?id=129391
+
+        Reviewed by NOBODY (OOPS!).
+
+        During playback, don't schedule resource loaders. This prevents the NetworkProcess
+        from taking over and fulfilling the loads nondeterministically.
+
+        * WebProcess/Network/WebResourceLoadScheduler.cpp:
+        (WebKit::WebResourceLoadScheduler::scheduleLoad):
+
+2014-06-11  Brian J. Burg <burg@cs.washington.edu>
 
         Web Replay: add page-level setting to bypass the MemoryCache
         https://bugs.webkit.org/show_bug.cgi?id=130728
 
         Reviewed by NOBODY (OOPS!).
 
         Use the default session if the session id is not ephemeral. The default session id
         and bypass cache session id are both considered to be non-ephemeral.
 
         * Shared/SessionTracker.cpp:
diff --git a/Source/WebKit2/WebProcess/Network/WebResourceLoadScheduler.cpp b/Source/WebKit2/WebProcess/Network/WebResourceLoadScheduler.cpp
index 71c8889..a792e56 100644
--- a/Source/WebKit2/WebProcess/Network/WebResourceLoadScheduler.cpp
+++ b/Source/WebKit2/WebProcess/Network/WebResourceLoadScheduler.cpp
@@ -46,20 +46,24 @@
 #include <WebCore/FrameLoader.h>
 #include <WebCore/NetscapePlugInStreamLoader.h>
 #include <WebCore/ReferrerPolicy.h>
 #include <WebCore/ResourceBuffer.h>
 #include <WebCore/ResourceLoader.h>
 #include <WebCore/SessionID.h>
 #include <WebCore/Settings.h>
 #include <WebCore/SubresourceLoader.h>
 #include <wtf/text/CString.h>
 
+#if ENABLE(WEB_REPLAY)
+#include <replay/InputCursor.h>
+#endif
+
 #if ENABLE(NETWORK_PROCESS)
 
 using namespace WebCore;
 
 namespace WebKit {
 
 WebResourceLoadScheduler::WebResourceLoadScheduler()
     : m_internallyFailedLoadTimer(RunLoop::main(), this, &WebResourceLoadScheduler::internallyFailedLoadTimerFired)
     , m_suspendPendingRequestsCount(0)
 {
@@ -141,21 +145,28 @@ void WebResourceLoadScheduler::scheduleLoad(ResourceLoader* resourceLoader, Cach
     }
 
 #if USE(QUICK_LOOK)
     if (maybeLoadQuickLookResource(*resourceLoader)) {
         LOG(NetworkScheduling, "(WebProcess) WebResourceLoadScheduler::scheduleLoad, url '%s' will be handled as a QuickLook resource.", resourceLoader->url().string().utf8().data());
         m_webResourceLoaders.set(identifier, WebResourceLoader::create(resourceLoader));
         return;
     }
 #endif
 
-    LOG(NetworkScheduling, "(WebProcess) WebResourceLoadScheduler::scheduleLoad, url '%s' will be scheduled with the NetworkProcess with priority %i", resourceLoader->url().string().utf8().data(), resourceLoader->request().priority());
+#if ENABLE(WEB_REPLAY)
+    if (InputCursor* cursor = resourceLoader->activeInputCursor()) {
+        if (cursor->isReplaying())
+            return;
+    }
+#endif
+
+    LOG(NetworkScheduling, "(WebProcess) WebResourceLoadScheduler::scheduleLoad, url '%s' will be scheduled with the NetworkProcess with priority %lli", resourceLoader->url().string().utf8().data(), resourceLoader->request().priority());
 
     ContentSniffingPolicy contentSniffingPolicy = resourceLoader->shouldSniffContent() ? SniffContent : DoNotSniffContent;
     StoredCredentials allowStoredCredentials = resourceLoader->shouldUseCredentialStorage() ? AllowStoredCredentials : DoNotAllowStoredCredentials;
 
     // FIXME: Some entities in WebCore use WebCore's "EmptyFrameLoaderClient" instead of having a proper WebFrameLoaderClient.
     // EmptyFrameLoaderClient shouldn't exist and everything should be using a WebFrameLoaderClient,
     // but in the meantime we have to make sure not to mis-cast.
     WebFrameLoaderClient* webFrameLoaderClient = toWebFrameLoaderClient(resourceLoader->frameLoader()->client());
     WebFrame* webFrame = webFrameLoaderClient ? webFrameLoaderClient->webFrame() : 0;
     WebPage* webPage = webFrame ? webFrame->page() : 0;
-- 
2.0.1

