From 0cdb3d796024563c9301b84be8037e235b07d5c8 Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Mon, 15 Sep 2014 10:10:22 -0700
Subject: [PATCH] WIP for 136351 - non-resource records seem wrong on apple.com

---
 Source/JavaScriptCore/API/JSProfilerPrivate.cpp    |  2 +-
 Source/JavaScriptCore/ChangeLog                    | 24 ++++++
 Source/JavaScriptCore/profiler/LegacyProfiler.cpp  | 14 ++--
 Source/JavaScriptCore/profiler/LegacyProfiler.h    |  5 +-
 .../JavaScriptCore/profiler/ProfileGenerator.cpp   | 15 ++--
 Source/JavaScriptCore/profiler/ProfileGenerator.h  |  7 +-
 Source/WTF/ChangeLog                               |  9 ++
 Source/WTF/WTF.xcodeproj/project.pbxproj           |  4 +
 Source/WTF/wtf/Stopwatch.h                         | 96 ++++++++++++++++++++++
 Source/WebCore/ChangeLog                           | 30 +++++++
 .../WebCore/inspector/InspectorTimelineAgent.cpp   | 46 ++++++-----
 Source/WebCore/inspector/InspectorTimelineAgent.h  | 26 ++----
 Source/WebInspectorUI/ChangeLog                    | 11 +++
 .../UserInterface/Controllers/TimelineManager.js   |  6 +-
 14 files changed, 232 insertions(+), 63 deletions(-)
 create mode 100644 Source/WTF/wtf/Stopwatch.h

diff --git a/Source/JavaScriptCore/API/JSProfilerPrivate.cpp b/Source/JavaScriptCore/API/JSProfilerPrivate.cpp
index 2a5ec2c..35ba83b 100644
--- a/Source/JavaScriptCore/API/JSProfilerPrivate.cpp
+++ b/Source/JavaScriptCore/API/JSProfilerPrivate.cpp
@@ -27,20 +27,20 @@
 #include "JSProfilerPrivate.h"
 
 #include "APICast.h"
 #include "LegacyProfiler.h"
 #include "OpaqueJSString.h"
 
 using namespace JSC;
 
 void JSStartProfiling(JSContextRef ctx, JSStringRef title)
 {
-    LegacyProfiler::profiler()->startProfiling(toJS(ctx), title->string());
+    LegacyProfiler::profiler()->startProfiling(toJS(ctx), title->string(), Stopwatch::create());
 }
 
 void JSEndProfiling(JSContextRef ctx, JSStringRef title)
 {
     ExecState* exec = toJS(ctx);
     LegacyProfiler* profiler = LegacyProfiler::profiler();
     profiler->stopProfiling(exec, title->string());
 }
 
diff --git a/Source/JavaScriptCore/ChangeLog b/Source/JavaScriptCore/ChangeLog
index dce478f..70718ba 100644
--- a/Source/JavaScriptCore/ChangeLog
+++ b/Source/JavaScriptCore/ChangeLog
@@ -1,10 +1,34 @@
+2014-09-15  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Inspector: timelines should not count time elapsed while paused in the debugger
+        https://bugs.webkit.org/show_bug.cgi?id=136351
+
+        Reviewed by NOBODY (OOPS!).
+
+        * API/JSProfilerPrivate.cpp:
+        (JSStartProfiling):
+        * profiler/LegacyProfiler.cpp:
+        (JSC::LegacyProfiler::profiler):
+        (JSC::LegacyProfiler::startProfiling):
+        (JSC::LegacyProfiler::stopProfiling):
+        * profiler/LegacyProfiler.h:
+        * profiler/ProfileGenerator.cpp:
+        (JSC::ProfileGenerator::create):
+        (JSC::ProfileGenerator::ProfileGenerator):
+        (JSC::ProfileGenerator::beginCallEntry):
+        (JSC::ProfileGenerator::endCallEntry):
+        (JSC::ProfileGenerator::didPause):
+        (JSC::ProfileGenerator::willExecute): Deleted.
+        (JSC::ProfileGenerator::removeProfileEnd): Deleted.
+        * profiler/ProfileGenerator.h:
+
 2014-09-14  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Inspector: InjectedScripts should not be profiled or displayed in Timeline
         https://bugs.webkit.org/show_bug.cgi?id=136806
 
         Reviewed by NOBODY (OOPS!).
 
         It doesn't make sense to show profile nodes for injected scripts when profiling user content.
         For now, omit nodes by suspending profiling before and after executing injected scripts.
 
diff --git a/Source/JavaScriptCore/profiler/LegacyProfiler.cpp b/Source/JavaScriptCore/profiler/LegacyProfiler.cpp
index be2a935..1cd6335 100644
--- a/Source/JavaScriptCore/profiler/LegacyProfiler.cpp
+++ b/Source/JavaScriptCore/profiler/LegacyProfiler.cpp
@@ -43,70 +43,70 @@
 #include "ProfileNode.h"
 
 namespace JSC {
 
 static const char* GlobalCodeExecution = "(program)";
 static const char* AnonymousFunction = "(anonymous function)";
 static unsigned ProfilesUID = 0;
 
 static CallIdentifier createCallIdentifierFromFunctionImp(ExecState*, JSObject*, const String& defaultSourceURL, unsigned defaultLineNumber, unsigned defaultColumnNumber);
 
-LegacyProfiler* LegacyProfiler::s_sharedLegacyProfiler = 0;
+LegacyProfiler* LegacyProfiler::s_sharedLegacyProfiler = nullptr;
 
 LegacyProfiler* LegacyProfiler::profiler()
 {
     if (!s_sharedLegacyProfiler)
         s_sharedLegacyProfiler = new LegacyProfiler();
     return s_sharedLegacyProfiler;
-}   
+}
 
-void LegacyProfiler::startProfiling(ExecState* exec, const String& title)
+void LegacyProfiler::startProfiling(ExecState* exec, const String& title, PassRefPtr<Stopwatch> stopwatch)
 {
     if (!exec)
         return;
 
     // Check if we currently have a Profile for this global ExecState and title.
     // If so return early and don't create a new Profile.
     JSGlobalObject* origin = exec->lexicalGlobalObject();
 
     for (size_t i = 0; i < m_currentProfiles.size(); ++i) {
         ProfileGenerator* profileGenerator = m_currentProfiles[i].get();
         if (profileGenerator->origin() == origin && profileGenerator->title() == title)
             return;
     }
 
     exec->vm().setEnabledProfiler(this);
-    RefPtr<ProfileGenerator> profileGenerator = ProfileGenerator::create(exec, title, ++ProfilesUID);
+    RefPtr<ProfileGenerator> profileGenerator = ProfileGenerator::create(exec, title, ++ProfilesUID, stopwatch);
     m_currentProfiles.append(profileGenerator);
 }
 
 PassRefPtr<Profile> LegacyProfiler::stopProfiling(ExecState* exec, const String& title)
 {
     if (!exec)
-        return 0;
+        return nullptr;
 
     JSGlobalObject* origin = exec->lexicalGlobalObject();
     for (ptrdiff_t i = m_currentProfiles.size() - 1; i >= 0; --i) {
         ProfileGenerator* profileGenerator = m_currentProfiles[i].get();
         if (profileGenerator->origin() == origin && (title.isNull() || profileGenerator->title() == title)) {
             profileGenerator->stopProfiling();
             RefPtr<Profile> returnProfile = profileGenerator->profile();
 
             m_currentProfiles.remove(i);
             if (!m_currentProfiles.size())
                 exec->vm().setEnabledProfiler(nullptr);
-            
+
             return returnProfile;
         }
     }
 
-    return 0;
+    return nullptr;
 }
 
 void LegacyProfiler::stopProfiling(JSGlobalObject* origin)
 {
     for (ptrdiff_t i = m_currentProfiles.size() - 1; i >= 0; --i) {
         ProfileGenerator* profileGenerator = m_currentProfiles[i].get();
         if (profileGenerator->origin() == origin) {
             profileGenerator->stopProfiling();
             m_currentProfiles.remove(i);
             if (!m_currentProfiles.size())
diff --git a/Source/JavaScriptCore/profiler/LegacyProfiler.h b/Source/JavaScriptCore/profiler/LegacyProfiler.h
index 1d6cb26..32e88d7 100644
--- a/Source/JavaScriptCore/profiler/LegacyProfiler.h
+++ b/Source/JavaScriptCore/profiler/LegacyProfiler.h
@@ -25,40 +25,41 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef LegacyProfiler_h
 #define LegacyProfiler_h
 
 #include "Profile.h"
 #include <wtf/PassRefPtr.h>
 #include <wtf/RefPtr.h>
+#include <wtf/Stopwatch.h>
 #include <wtf/Vector.h>
 
 namespace JSC {
 
 class DebuggerCallFrame;
 class ExecState;
 class VM;
 class JSGlobalObject;
 class JSObject;
 class JSValue;
 class ProfileGenerator;
 struct CallIdentifier;
 
 class LegacyProfiler {
     WTF_MAKE_FAST_ALLOCATED;
 public:
-    JS_EXPORT_PRIVATE static LegacyProfiler* profiler(); 
+    JS_EXPORT_PRIVATE static LegacyProfiler* profiler();
     static CallIdentifier createCallIdentifier(ExecState*, JSValue, const WTF::String& sourceURL, unsigned defaultLineNumber, unsigned defaultColumnNumber);
 
-    JS_EXPORT_PRIVATE void startProfiling(ExecState*, const WTF::String& title);
+    JS_EXPORT_PRIVATE void startProfiling(ExecState*, const WTF::String& title, PassRefPtr<Stopwatch>);
     JS_EXPORT_PRIVATE PassRefPtr<Profile> stopProfiling(ExecState*, const WTF::String& title);
     void stopProfiling(JSGlobalObject*);
 
     // Used to ignore profile node subtrees rooted at InjectedScript calls.
     JS_EXPORT_PRIVATE void suspendProfiling(ExecState*);
     JS_EXPORT_PRIVATE void unsuspendProfiling(ExecState*);
 
     void willExecute(ExecState* callerCallFrame, JSValue function);
     void willExecute(ExecState* callerCallFrame, const WTF::String& sourceURL, unsigned startingLineNumber, unsigned startingColumnNumber);
     void didExecute(ExecState* callerCallFrame, JSValue function);
diff --git a/Source/JavaScriptCore/profiler/ProfileGenerator.cpp b/Source/JavaScriptCore/profiler/ProfileGenerator.cpp
index 32e8926..c05c707 100644
--- a/Source/JavaScriptCore/profiler/ProfileGenerator.cpp
+++ b/Source/JavaScriptCore/profiler/ProfileGenerator.cpp
@@ -33,34 +33,35 @@
 #include "JSStringRef.h"
 #include "JSFunction.h"
 #include "LegacyProfiler.h"
 #include "JSCInlines.h"
 #include "Profile.h"
 #include "StackVisitor.h"
 #include "Tracing.h"
 
 namespace JSC {
 
-PassRefPtr<ProfileGenerator> ProfileGenerator::create(ExecState* exec, const String& title, unsigned uid)
+PassRefPtr<ProfileGenerator> ProfileGenerator::create(ExecState* exec, const String& title, unsigned uid, PassRefPtr<Stopwatch> stopwatch)
 {
-    return adoptRef(new ProfileGenerator(exec, title, uid));
+    return adoptRef(new ProfileGenerator(exec, title, uid, stopwatch));
 }
 
-ProfileGenerator::ProfileGenerator(ExecState* exec, const String& title, unsigned uid)
+ProfileGenerator::ProfileGenerator(ExecState* exec, const String& title, unsigned uid, PassRefPtr<Stopwatch> stopwatch)
     : m_origin(exec ? exec->lexicalGlobalObject() : nullptr)
     , m_profileGroup(exec ? exec->lexicalGlobalObject()->profileGroup() : 0)
+    , m_stopwatch(stopwatch)
     , m_debuggerPausedTimestamp(NAN)
     , m_foundConsoleStartParent(false)
     , m_suspended(false)
 {
     if (Debugger* debugger = exec->lexicalGlobalObject()->debugger())
-        m_debuggerPausedTimestamp = debugger->isPaused() ? currentTime() : NAN;
+        m_debuggerPausedTimestamp = debugger->isPaused() ? m_stopwatch->elapsedTime() : NAN;
 
     m_profile = Profile::create(title, uid);
     m_currentNode = m_rootNode = m_profile->rootNode();
     if (exec)
         addParentForConsoleStart(exec);
 }
 
 class AddParentForConsoleStartFunctor {
 public:
     AddParentForConsoleStartFunctor(ExecState* exec, RefPtr<ProfileNode>& rootNode, RefPtr<ProfileNode>& currentNode)
@@ -111,21 +112,21 @@ void ProfileGenerator::addParentForConsoleStart(ExecState* exec)
 const String& ProfileGenerator::title() const
 {
     return m_profile->title();
 }
 
 void ProfileGenerator::beginCallEntry(ProfileNode* node, double startTime)
 {
     ASSERT_ARG(node, node);
 
     if (isnan(startTime))
-        startTime = currentTime();
+        startTime = m_stopwatch->elapsedTime();
 
     // If the debugger is paused when beginning, then don't set the start time. It
     // will be fixed up when the debugger unpauses or the call entry ends.
     if (!isnan(m_debuggerPausedTimestamp))
         startTime = NAN;
 
     node->appendCall(ProfileNode::Call(startTime));
 }
 
 void ProfileGenerator::endCallEntry(ProfileNode* node)
@@ -141,21 +142,21 @@ void ProfileGenerator::endCallEntry(ProfileNode* node)
     // If paused and no time was accrued then the debugger was never unpaused. The call will
     // have no time accrued and appear to have started when the debugger was paused.
     if (!isnan(m_debuggerPausedTimestamp)) {
         last.setStartTime(m_debuggerPausedTimestamp);
         last.setElapsedTime(0.0);
         return;
     }
 
     // Otherwise, add the interval ending now to elapsed time.
     double previousElapsedTime = isnan(last.elapsedTime()) ? 0.0 : last.elapsedTime();
-    double newlyElapsedTime = currentTime() - last.startTime();
+    double newlyElapsedTime = m_stopwatch->elapsedTime() - last.startTime();
     last.setElapsedTime(previousElapsedTime + newlyElapsedTime);
 }
 
 void ProfileGenerator::willExecute(ExecState* callerCallFrame, const CallIdentifier& callIdentifier)
 {
     if (JAVASCRIPTCORE_PROFILE_WILL_EXECUTE_ENABLED()) {
         CString name = callIdentifier.functionName().utf8();
         CString url = callIdentifier.url().utf8();
         JAVASCRIPTCORE_PROFILE_WILL_EXECUTE(m_profileGroup, const_cast<char*>(name.data()), const_cast<char*>(url.data()), callIdentifier.lineNumber(), callIdentifier.columnNumber());
     }
@@ -220,21 +221,21 @@ void ProfileGenerator::exceptionUnwind(ExecState* handlerCallFrame, const CallId
     while (m_currentNode->callerCallFrame() >= handlerCallFrame) {
         didExecute(m_currentNode->callerCallFrame(), m_currentNode->callIdentifier());
         ASSERT(m_currentNode);
     }
 }
 
 void ProfileGenerator::didPause(PassRefPtr<DebuggerCallFrame>, const CallIdentifier&)
 {
     ASSERT(isnan(m_debuggerPausedTimestamp));
 
-    m_debuggerPausedTimestamp = currentTime();
+    m_debuggerPausedTimestamp = m_stopwatch->elapsedTime();
 
     for (ProfileNode* node = m_currentNode.get(); node != m_profile->rootNode(); node = node->parent()) {
         ProfileNode::Call& last = node->lastCall();
         ASSERT(!isnan(last.startTime()));
 
         double previousElapsedTime = isnan(last.elapsedTime()) ? 0.0 : last.elapsedTime();
         double additionalElapsedTime = m_debuggerPausedTimestamp - last.startTime();
         last.setStartTime(NAN);
         last.setElapsedTime(previousElapsedTime + additionalElapsedTime);
     }
diff --git a/Source/JavaScriptCore/profiler/ProfileGenerator.h b/Source/JavaScriptCore/profiler/ProfileGenerator.h
index 9f51a3d..56ce24a 100644
--- a/Source/JavaScriptCore/profiler/ProfileGenerator.h
+++ b/Source/JavaScriptCore/profiler/ProfileGenerator.h
@@ -22,66 +22,67 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef ProfileGenerator_h
 #define ProfileGenerator_h
 
 #include <wtf/PassRefPtr.h>
 #include <wtf/RefCounted.h>
 #include <wtf/RefPtr.h>
+#include <wtf/Stopwatch.h>
 #include <wtf/text/WTFString.h>
 
 namespace JSC {
 
     class DebuggerCallFrame;
     class ExecState;
     class JSGlobalObject;
     class Profile;
     class ProfileNode;
     struct CallIdentifier;
 
     class ProfileGenerator : public RefCounted<ProfileGenerator>  {
     public:
-        static PassRefPtr<ProfileGenerator> create(ExecState*, const WTF::String& title, unsigned uid);
+        static PassRefPtr<ProfileGenerator> create(ExecState*, const WTF::String& title, unsigned uid, PassRefPtr<Stopwatch>);
 
         // Members
         const WTF::String& title() const;
         PassRefPtr<Profile> profile() const { return m_profile; }
         JSGlobalObject* origin() const { return m_origin; }
         unsigned profileGroup() const { return m_profileGroup; }
 
         void willExecute(ExecState* callerCallFrame, const CallIdentifier&);
         void didExecute(ExecState* callerCallFrame, const CallIdentifier&);
         void exceptionUnwind(ExecState* handlerCallFrame, const CallIdentifier&);
 
         void didPause(PassRefPtr<DebuggerCallFrame>, const CallIdentifier&);
         void didContinue(PassRefPtr<DebuggerCallFrame>, const CallIdentifier&);
 
         void setIsSuspended(bool suspended) { ASSERT(m_suspended != suspended); m_suspended = suspended; }
 
         void stopProfiling();
 
     private:
-        ProfileGenerator(ExecState*, const WTF::String& title, unsigned uid);
+        ProfileGenerator(ExecState*, const WTF::String& title, unsigned uid, PassRefPtr<Stopwatch>);
         void addParentForConsoleStart(ExecState*);
 
         void removeProfileStart();
         void removeProfileEnd();
 
         void beginCallEntry(ProfileNode*, double startTime = NAN);
         void endCallEntry(ProfileNode*);
 
         RefPtr<Profile> m_profile;
         JSGlobalObject* m_origin;
         unsigned m_profileGroup;
-        // Timestamp is set to NAN when the debugger is not currently paused.
+        RefPtr<Stopwatch> m_stopwatch;
         double m_debuggerPausedTimestamp;
         RefPtr<ProfileNode> m_rootNode;
         RefPtr<ProfileNode> m_currentNode;
         bool m_foundConsoleStartParent;
         bool m_suspended;
     };
 
 } // namespace JSC
 
 #endif // ProfileGenerator_h
diff --git a/Source/WTF/ChangeLog b/Source/WTF/ChangeLog
index c0cce50..fac8c65 100644
--- a/Source/WTF/ChangeLog
+++ b/Source/WTF/ChangeLog
@@ -1,10 +1,19 @@
+2014-09-15  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Inspector: timelines should not count time elapsed while paused in the debugger
+        https://bugs.webkit.org/show_bug.cgi?id=136351
+
+        Reviewed by NOBODY (OOPS!).
+
+        * WTF.xcodeproj/project.pbxproj:
+
 2014-09-11  Geoffrey Garen  <ggaren@apple.com>
 
         Do the bmalloc.
         https://bugs.webkit.org/show_bug.cgi?id=132629
 
         Reviewed by Michael Saboff.
 
         64-bit only for now, just to try it out.
 
         * wtf/FastMalloc.cpp:
diff --git a/Source/WTF/WTF.xcodeproj/project.pbxproj b/Source/WTF/WTF.xcodeproj/project.pbxproj
index 35b7dcc..784ef2a 100644
--- a/Source/WTF/WTF.xcodeproj/project.pbxproj
+++ b/Source/WTF/WTF.xcodeproj/project.pbxproj
@@ -265,20 +265,21 @@
 		A8A4746A151A825B004123FF /* UTF8.h in Headers */ = {isa = PBXBuildFile; fileRef = A8A47358151A825B004123FF /* UTF8.h */; };
 		A8A4746D151A825B004123FF /* UnionFind.h in Headers */ = {isa = PBXBuildFile; fileRef = A8A4735C151A825B004123FF /* UnionFind.h */; };
 		A8A4747D151A825B004123FF /* ValueCheck.h in Headers */ = {isa = PBXBuildFile; fileRef = A8A4736F151A825B004123FF /* ValueCheck.h */; };
 		A8A4747E151A825B004123FF /* Vector.h in Headers */ = {isa = PBXBuildFile; fileRef = A8A47370151A825B004123FF /* Vector.h */; };
 		A8A4747F151A825B004123FF /* VectorTraits.h in Headers */ = {isa = PBXBuildFile; fileRef = A8A47371151A825B004123FF /* VectorTraits.h */; };
 		A8A47480151A825B004123FF /* VMTags.h in Headers */ = {isa = PBXBuildFile; fileRef = A8A47372151A825B004123FF /* VMTags.h */; };
 		A8A47486151A825B004123FF /* WTFThreadData.cpp in Sources */ = {isa = PBXBuildFile; fileRef = A8A4737A151A825B004123FF /* WTFThreadData.cpp */; };
 		A8A47487151A825B004123FF /* WTFThreadData.h in Headers */ = {isa = PBXBuildFile; fileRef = A8A4737B151A825B004123FF /* WTFThreadData.h */; };
 		A8A4748C151A8264004123FF /* config.h in Headers */ = {isa = PBXBuildFile; fileRef = A8A4748B151A8264004123FF /* config.h */; };
 		B38FD7BD168953E80065C969 /* FeatureDefines.h in Headers */ = {isa = PBXBuildFile; fileRef = B38FD7BC168953E80065C969 /* FeatureDefines.h */; };
+		C4F8A93719C65EB400B2B15D /* Stopwatch.h in Headers */ = {isa = PBXBuildFile; fileRef = C4F8A93619C65EB400B2B15D /* Stopwatch.h */; };
 		CD5497AC15857D0300B5BC30 /* MediaTime.cpp in Sources */ = {isa = PBXBuildFile; fileRef = CD5497AA15857D0300B5BC30 /* MediaTime.cpp */; };
 		CD5497AD15857D0300B5BC30 /* MediaTime.h in Headers */ = {isa = PBXBuildFile; fileRef = CD5497AB15857D0300B5BC30 /* MediaTime.h */; };
 		E15556F518A0CC18006F48FB /* CryptographicUtilities.cpp in Sources */ = {isa = PBXBuildFile; fileRef = E15556F318A0CC18006F48FB /* CryptographicUtilities.cpp */; };
 		E15556F618A0CC18006F48FB /* CryptographicUtilities.h in Headers */ = {isa = PBXBuildFile; fileRef = E15556F418A0CC18006F48FB /* CryptographicUtilities.h */; };
 		EB95E1F0161A72410089A2F5 /* ByteOrder.h in Headers */ = {isa = PBXBuildFile; fileRef = EB95E1EF161A72410089A2F5 /* ByteOrder.h */; };
 		FEDACD3D1630F83F00C69634 /* StackStats.cpp in Sources */ = {isa = PBXBuildFile; fileRef = FEDACD3B1630F83F00C69634 /* StackStats.cpp */; };
 		FEDACD3E1630F83F00C69634 /* StackStats.h in Headers */ = {isa = PBXBuildFile; fileRef = FEDACD3C1630F83F00C69634 /* StackStats.h */; };
 /* End PBXBuildFile section */
 
 /* Begin PBXContainerItemProxy section */
@@ -555,20 +556,21 @@
 		A8A47358151A825B004123FF /* UTF8.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = UTF8.h; sourceTree = "<group>"; };
 		A8A4735C151A825B004123FF /* UnionFind.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = UnionFind.h; sourceTree = "<group>"; };
 		A8A4736F151A825B004123FF /* ValueCheck.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ValueCheck.h; sourceTree = "<group>"; };
 		A8A47370151A825B004123FF /* Vector.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Vector.h; sourceTree = "<group>"; };
 		A8A47371151A825B004123FF /* VectorTraits.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = VectorTraits.h; sourceTree = "<group>"; };
 		A8A47372151A825B004123FF /* VMTags.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = VMTags.h; sourceTree = "<group>"; };
 		A8A4737A151A825B004123FF /* WTFThreadData.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WTFThreadData.cpp; sourceTree = "<group>"; };
 		A8A4737B151A825B004123FF /* WTFThreadData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WTFThreadData.h; sourceTree = "<group>"; };
 		A8A4748B151A8264004123FF /* config.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = config.h; sourceTree = "<group>"; };
 		B38FD7BC168953E80065C969 /* FeatureDefines.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FeatureDefines.h; sourceTree = "<group>"; };
+		C4F8A93619C65EB400B2B15D /* Stopwatch.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Stopwatch.h; sourceTree = "<group>"; };
 		CD5497AA15857D0300B5BC30 /* MediaTime.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MediaTime.cpp; sourceTree = "<group>"; };
 		CD5497AB15857D0300B5BC30 /* MediaTime.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MediaTime.h; sourceTree = "<group>"; };
 		E15556F318A0CC18006F48FB /* CryptographicUtilities.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CryptographicUtilities.cpp; sourceTree = "<group>"; };
 		E15556F418A0CC18006F48FB /* CryptographicUtilities.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CryptographicUtilities.h; sourceTree = "<group>"; };
 		EB95E1EF161A72410089A2F5 /* ByteOrder.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ByteOrder.h; sourceTree = "<group>"; };
 		FEDACD3B1630F83F00C69634 /* StackStats.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = StackStats.cpp; sourceTree = "<group>"; };
 		FEDACD3C1630F83F00C69634 /* StackStats.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StackStats.h; sourceTree = "<group>"; };
 /* End PBXFileReference section */
 
 /* Begin PBXFrameworksBuildPhase section */
@@ -845,20 +847,21 @@
 				A748744F17A0BDAE00FA04CB /* SixCharacterHash.cpp */,
 				A748745017A0BDAE00FA04CB /* SixCharacterHash.h */,
 				A8A4730C151A825B004123FF /* SizeLimits.cpp */,
 				A8A4730D151A825B004123FF /* Spectrum.h */,
 				A8A4730E151A825B004123FF /* StackBounds.cpp */,
 				A8A4730F151A825B004123FF /* StackBounds.h */,
 				FEDACD3B1630F83F00C69634 /* StackStats.cpp */,
 				FEDACD3C1630F83F00C69634 /* StackStats.h */,
 				A8A47310151A825B004123FF /* StaticConstructors.h */,
 				A8A47311151A825B004123FF /* StdLibExtras.h */,
+				C4F8A93619C65EB400B2B15D /* Stopwatch.h */,
 				1A6BB768162F300500DD16DB /* StreamBuffer.h */,
 				A8A47313151A825B004123FF /* StringExtras.h */,
 				A748745117A0BDAE00FA04CB /* StringHashDumpContext.h */,
 				A8A47314151A825B004123FF /* StringHasher.h */,
 				0FDDBFA51666DFA300C55FEF /* StringPrintStream.cpp */,
 				0FDDBFA61666DFA300C55FEF /* StringPrintStream.h */,
 				A8A47315151A825B004123FF /* TCPackedCache.h */,
 				A8A47316151A825B004123FF /* TCPageMap.h */,
 				A8A47317151A825B004123FF /* TCSpinLock.h */,
 				A8A47318151A825B004123FF /* TCSystemAlloc.cpp */,
@@ -1038,20 +1041,21 @@
 				A8A4748C151A8264004123FF /* config.h in Headers */,
 				0F8F2B9C172F2596007DBDA5 /* ConversionMode.h in Headers */,
 				A8A4739B151A825B004123FF /* CryptographicallyRandomNumber.h in Headers */,
 				A8A4743A151A825B004123FF /* CString.h in Headers */,
 				A8A4739D151A825B004123FF /* CurrentTime.h in Headers */,
 				A8A4739F151A825B004123FF /* DataLog.h in Headers */,
 				A8A473A1151A825B004123FF /* DateMath.h in Headers */,
 				A8A473A3151A825B004123FF /* DecimalNumber.h in Headers */,
 				0F2B66A617B6B4FB00A7AE3F /* DeferrableRefCounted.h in Headers */,
 				A8A473A5151A825B004123FF /* Deque.h in Headers */,
+				C4F8A93719C65EB400B2B15D /* Stopwatch.h in Headers */,
 				A8A473A6151A825B004123FF /* DisallowCType.h in Headers */,
 				A8A473AF151A825B004123FF /* diy-fp.h in Headers */,
 				A8A473B1151A825B004123FF /* double-conversion.h in Headers */,
 				A8A473B2151A825B004123FF /* double.h in Headers */,
 				A8A473A7151A825B004123FF /* DoublyLinkedList.h in Headers */,
 				A8A473BB151A825B004123FF /* dtoa.h in Headers */,
 				A8A473C1151A825B004123FF /* ExportMacros.h in Headers */,
 				A8A473B4151A825B004123FF /* fast-dtoa.h in Headers */,
 				0FD81AC5154FB22E00983E72 /* FastBitVector.h in Headers */,
 				A8A473C4151A825B004123FF /* FastMalloc.h in Headers */,
diff --git a/Source/WTF/wtf/Stopwatch.h b/Source/WTF/wtf/Stopwatch.h
new file mode 100644
index 0000000..8f280bc
--- /dev/null
+++ b/Source/WTF/wtf/Stopwatch.h
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2014 University of Washington. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef Stopwatch_h
+#define Stopwatch_h
+
+#include <wtf/CurrentTime.h>
+#include <wtf/RefCounted.h>
+
+#include <cmath>
+
+namespace WTF {
+
+class WTF_EXPORT_PRIVATE Stopwatch : public RefCounted<Stopwatch> {
+    WTF_MAKE_FAST_ALLOCATED;
+public:
+    static PassRefPtr<Stopwatch> create()
+    {
+        return adoptRef(new Stopwatch());
+    }
+
+    void reset();
+    void start();
+    void stop();
+
+    double elapsedTime() {
+        bool shouldSuspend = !isnan(m_lastStartTime);
+        if (shouldSuspend)
+            stop();
+
+        ASSERT(!isnan(m_elapsedTime) && isnan(m_lastStartTime));
+        double elapsedTime = m_elapsedTime;
+
+        if (shouldSuspend)
+            start();
+        return elapsedTime;
+    }
+
+private:
+    Stopwatch()
+        : m_elapsedTime(NAN)
+        , m_lastStartTime(NAN)
+    {
+    }
+
+    double m_elapsedTime;
+    double m_lastStartTime;
+};
+
+inline void Stopwatch::reset()
+{
+    m_elapsedTime = 0.0;
+    m_lastStartTime = NAN;
+}
+
+inline void Stopwatch::start()
+{
+    ASSERT(!isnan(m_elapsedTime) && isnan(m_lastStartTime));
+
+    m_lastStartTime = monotonicallyIncreasingTime();
+}
+
+inline void Stopwatch::stop()
+{
+    ASSERT(!isnan(m_elapsedTime) && !isnan(m_lastStartTime));
+
+    m_elapsedTime += monotonicallyIncreasingTime() - m_lastStartTime;
+    m_lastStartTime = NAN;
+}
+
+} // namespace WTF
+
+using WTF::Stopwatch;
+
+#endif // Stopwatch_h
diff --git a/Source/WebCore/ChangeLog b/Source/WebCore/ChangeLog
index d7bbf7e..733c17f 100644
--- a/Source/WebCore/ChangeLog
+++ b/Source/WebCore/ChangeLog
@@ -1,10 +1,40 @@
+2014-09-15  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Inspector: timelines should not count time elapsed while paused in the debugger
+        https://bugs.webkit.org/show_bug.cgi?id=136351
+
+        Reviewed by NOBODY (OOPS!).
+
+        No new tests (OOPS!).
+
+        * inspector/InspectorTimelineAgent.cpp:
+        (WebCore::InspectorTimelineAgent::didCreateFrontendAndBackend):
+        (WebCore::InspectorTimelineAgent::internalStart):
+        (WebCore::InspectorTimelineAgent::internalStop):
+        (WebCore::startProfiling):
+        (WebCore::InspectorTimelineAgent::startFromConsole):
+        (WebCore::InspectorTimelineAgent::willCallFunction):
+        (WebCore::InspectorTimelineAgent::willEvaluateScript):
+        (WebCore::InspectorTimelineAgent::didPause):
+        (WebCore::InspectorTimelineAgent::didContinue):
+        (WebCore::InspectorTimelineAgent::didCompleteRecordEntry):
+        (WebCore::InspectorTimelineAgent::InspectorTimelineAgent):
+        (WebCore::InspectorTimelineAgent::appendRecord):
+        (WebCore::InspectorTimelineAgent::createRecordEntry):
+        (WebCore::TimelineTimeConverter::reset): Deleted.
+        (WebCore::InspectorTimelineAgent::timestamp): Deleted.
+        * inspector/InspectorTimelineAgent.h:
+        (WebCore::TimelineTimeConverter::TimelineTimeConverter): Deleted.
+        (WebCore::TimelineTimeConverter::fromMonotonicallyIncreasingTime): Deleted.
+        (WebCore::InspectorTimelineAgent::timeConverter): Deleted.
+
 2014-09-14  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Inspector: InjectedScripts should not be profiled or displayed in Timeline
         https://bugs.webkit.org/show_bug.cgi?id=136806
 
         Reviewed by NOBODY (OOPS!).
 
         Instead of creating timeline records for injected scripts, suspend profiling
         of the current page before and after calling injected script functions.
 
diff --git a/Source/WebCore/inspector/InspectorTimelineAgent.cpp b/Source/WebCore/inspector/InspectorTimelineAgent.cpp
index edc1e12..9535510 100644
--- a/Source/WebCore/inspector/InspectorTimelineAgent.cpp
+++ b/Source/WebCore/inspector/InspectorTimelineAgent.cpp
@@ -54,35 +54,31 @@
 #include "TimelineRecordFactory.h"
 #include <inspector/IdentifiersFactory.h>
 #include <inspector/ScriptBreakpoint.h>
 #include <profiler/LegacyProfiler.h>
 #include <wtf/CurrentTime.h>
 
 using namespace Inspector;
 
 namespace WebCore {
 
-void TimelineTimeConverter::reset()
-{
-    m_startOffset = monotonicallyIncreasingTime() - currentTime();
-}
-
 InspectorTimelineAgent::~InspectorTimelineAgent()
 {
 }
 
 void InspectorTimelineAgent::didCreateFrontendAndBackend(Inspector::InspectorFrontendChannel* frontendChannel, InspectorBackendDispatcher* backendDispatcher)
 {
     m_frontendDispatcher = std::make_unique<InspectorTimelineFrontendDispatcher>(frontendChannel);
     m_backendDispatcher = InspectorTimelineBackendDispatcher::create(backendDispatcher, this);
 
     m_instrumentingAgents->setPersistentInspectorTimelineAgent(this);
+    m_stopwatch->reset();
 
     if (m_scriptDebugServer)
         m_scriptDebugServer->recompileAllJSFunctions();
 }
 
 void InspectorTimelineAgent::willDestroyFrontendAndBackend(InspectorDisconnectReason reason)
 {
     m_frontendDispatcher = nullptr;
     m_backendDispatcher.clear();
 
@@ -111,38 +107,40 @@ void InspectorTimelineAgent::stop(ErrorString*)
     m_enabledFromFrontend = false;
 }
 
 void InspectorTimelineAgent::internalStart(const int* maxCallStackDepth)
 {
     if (maxCallStackDepth && *maxCallStackDepth > 0)
         m_maxCallStackDepth = *maxCallStackDepth;
     else
         m_maxCallStackDepth = 5;
 
-    m_timeConverter.reset();
+    m_stopwatch->start();
 
     m_instrumentingAgents->setInspectorTimelineAgent(this);
 
     if (m_scriptDebugServer)
         m_scriptDebugServer->addListener(this);
 
     m_enabled = true;
 
     if (m_frontendDispatcher)
         m_frontendDispatcher->recordingStarted();
 }
 
 void InspectorTimelineAgent::internalStop()
 {
     if (!m_enabled)
         return;
 
+    m_stopwatch->stop();
+
     m_instrumentingAgents->setInspectorTimelineAgent(nullptr);
 
     if (m_scriptDebugServer)
         m_scriptDebugServer->removeListener(this, true);
 
     clearRecordStack();
 
     m_enabled = false;
 
     if (m_frontendDispatcher)
@@ -150,33 +148,33 @@ void InspectorTimelineAgent::internalStop()
 }
 
 void InspectorTimelineAgent::setPageScriptDebugServer(PageScriptDebugServer* scriptDebugServer)
 {
     ASSERT(!m_enabled);
     ASSERT(!m_scriptDebugServer);
 
     m_scriptDebugServer = scriptDebugServer;
 }
 
-static inline void startProfiling(JSC::ExecState* exec, const String& title)
+static inline void startProfiling(JSC::ExecState* exec, const String& title, PassRefPtr<Stopwatch> stopwatch)
 {
-    JSC::LegacyProfiler::profiler()->startProfiling(exec, title);
+    JSC::LegacyProfiler::profiler()->startProfiling(exec, title, stopwatch);
 }
 
 static inline PassRefPtr<JSC::Profile> stopProfiling(JSC::ExecState* exec, const String& title)
 {
     return JSC::LegacyProfiler::profiler()->stopProfiling(exec, title);
 }
 
-static inline void startProfiling(Frame* frame, const String& title)
+static inline void startProfiling(Frame* frame, const String& title, PassRefPtr<Stopwatch> stopwatch)
 {
-    startProfiling(toJSDOMWindow(frame, debuggerWorld())->globalExec(), title);
+    startProfiling(toJSDOMWindow(frame, debuggerWorld())->globalExec(), title, stopwatch);
 }
 
 static inline PassRefPtr<JSC::Profile> stopProfiling(Frame* frame, const String& title)
 {
     return stopProfiling(toJSDOMWindow(frame, debuggerWorld())->globalExec(), title);
 }
 
 void InspectorTimelineAgent::startFromConsole(JSC::ExecState* exec, const String &title)
 {
     // Only allow recording of a profile if it is anonymous (empty title) or does not match
@@ -186,21 +184,21 @@ void InspectorTimelineAgent::startFromConsole(JSC::ExecState* exec, const String
             String recordTitle;
             record.data->getString(ASCIILiteral("title"), &recordTitle);
             if (recordTitle == title)
                 return;
         }
     }
 
     if (!m_enabled && m_pendingConsoleProfileRecords.isEmpty())
         internalStart();
 
-    startProfiling(exec, title);
+    startProfiling(exec, title, m_stopwatch);
 
     m_pendingConsoleProfileRecords.append(createRecordEntry(TimelineRecordFactory::createConsoleProfileData(title), TimelineRecordType::ConsoleProfile, true, frameFromExecState(exec)));
 }
 
 PassRefPtr<JSC::Profile> InspectorTimelineAgent::stopFromConsole(JSC::ExecState* exec, const String& title)
 {
     // Stop profiles in reverse order. If the title is empty, then stop the last profile.
     // Otherwise, match the title of the profile to stop.
     for (ptrdiff_t i = m_pendingConsoleProfileRecords.size() - 1; i >= 0; --i) {
         const TimelineRecordEntry& record = m_pendingConsoleProfileRecords[i];
@@ -225,21 +223,21 @@ PassRefPtr<JSC::Profile> InspectorTimelineAgent::stopFromConsole(JSC::ExecState*
     }
 
     return nullptr;
 }
 
 void InspectorTimelineAgent::willCallFunction(const String& scriptName, int scriptLine, Frame* frame)
 {
     pushCurrentRecord(TimelineRecordFactory::createFunctionCallData(scriptName, scriptLine), TimelineRecordType::FunctionCall, true, frame);
 
     if (frame && !m_callStackDepth)
-        startProfiling(frame, ASCIILiteral("Timeline FunctionCall"));
+        startProfiling(frame, ASCIILiteral("Timeline FunctionCall"), m_stopwatch);
 
     ++m_callStackDepth;
 }
 
 void InspectorTimelineAgent::didCallFunction(Frame* frame)
 {
     if (frame && m_callStackDepth) {
         --m_callStackDepth;
         ASSERT(m_callStackDepth >= 0);
 
@@ -399,21 +397,21 @@ void InspectorTimelineAgent::willDispatchXHRLoadEvent(const String& url, Frame*
 void InspectorTimelineAgent::didDispatchXHRLoadEvent()
 {
     didCompleteCurrentRecord(TimelineRecordType::XHRLoad);
 }
 
 void InspectorTimelineAgent::willEvaluateScript(const String& url, int lineNumber, Frame* frame)
 {
     pushCurrentRecord(TimelineRecordFactory::createEvaluateScriptData(url, lineNumber), TimelineRecordType::EvaluateScript, true, frame);
 
     if (frame && !m_callStackDepth)
-        startProfiling(frame, ASCIILiteral("Timeline EvaluateScript"));
+        startProfiling(frame, ASCIILiteral("Timeline EvaluateScript"), m_stopwatch);
 
     ++m_callStackDepth;
 }
 
 void InspectorTimelineAgent::didEvaluateScript(Frame* frame)
 {
     if (frame && m_callStackDepth) {
         --m_callStackDepth;
         ASSERT(m_callStackDepth >= 0);
         
@@ -547,20 +545,30 @@ void InspectorTimelineAgent::didDestroyWebSocket(unsigned long identifier, Frame
 
 // ScriptDebugListener
 
 void InspectorTimelineAgent::breakpointActionProbe(JSC::ExecState* exec, const Inspector::ScriptBreakpointAction& action, int hitCount, const Deprecated::ScriptValue&)
 {
     ASSERT(exec);
 
     appendRecord(TimelineRecordFactory::createProbeSampleData(action, hitCount), TimelineRecordType::ProbeSample, false, frameFromExecState(exec));
 }
 
+void InspectorTimelineAgent::didPause(JSC::ExecState*, const Deprecated::ScriptValue&, const Deprecated::ScriptValue&)
+{
+    m_stopwatch->stop();
+}
+
+void InspectorTimelineAgent::didContinue()
+{
+    m_stopwatch->start();
+}
+
 static Inspector::Protocol::Timeline::EventType toProtocol(TimelineRecordType type)
 {
     switch (type) {
     case TimelineRecordType::EventDispatch:
         return Inspector::Protocol::Timeline::EventType::EventDispatch;
     case TimelineRecordType::ScheduleStyleRecalculation:
         return Inspector::Protocol::Timeline::EventType::ScheduleStyleRecalculation;
     case TimelineRecordType::RecalculateStyles:
         return Inspector::Protocol::Timeline::EventType::RecalculateStyles;
     case TimelineRecordType::InvalidateLayout:
@@ -663,71 +671,72 @@ void InspectorTimelineAgent::setFrameIdentifier(InspectorObject* record, Frame*
     String frameId;
     if (frame && m_pageAgent)
         frameId = m_pageAgent->frameId(frame);
     record->setString("frameId", frameId);
 }
 
 void InspectorTimelineAgent::didCompleteRecordEntry(const TimelineRecordEntry& entry)
 {
     entry.record->setObject(ASCIILiteral("data"), entry.data);
     entry.record->setArray(ASCIILiteral("children"), entry.children);
-    entry.record->setNumber(ASCIILiteral("endTime"), timestamp());
+    entry.record->setNumber(ASCIILiteral("endTime"), m_stopwatch->elapsedTime());
     addRecordToTimeline(entry.record, entry.type);
 }
 
 void InspectorTimelineAgent::didCompleteCurrentRecord(TimelineRecordType type)
 {
     // An empty stack could merely mean that the timeline agent was turned on in the middle of
     // an event.  Don't treat as an error.
     if (!m_recordStack.isEmpty()) {
         TimelineRecordEntry entry = m_recordStack.last();
         m_recordStack.removeLast();
         ASSERT_UNUSED(type, entry.type == type);
         didCompleteRecordEntry(entry);
     }
 }
 
 InspectorTimelineAgent::InspectorTimelineAgent(InstrumentingAgents* instrumentingAgents, InspectorPageAgent* pageAgent, InspectorType type, InspectorClient* client)
     : InspectorAgentBase(ASCIILiteral("Timeline"), instrumentingAgents)
     , m_pageAgent(pageAgent)
     , m_scriptDebugServer(nullptr)
+    , m_stopwatch(Stopwatch::create())
     , m_id(1)
     , m_callStackDepth(0)
     , m_maxCallStackDepth(5)
     , m_inspectorType(type)
     , m_client(client)
     , m_enabled(false)
     , m_enabledFromFrontend(false)
 {
 }
 
 void InspectorTimelineAgent::appendRecord(PassRefPtr<InspectorObject> data, TimelineRecordType type, bool captureCallStack, Frame* frame)
 {
-    RefPtr<InspectorObject> record = TimelineRecordFactory::createGenericRecord(timestamp(), captureCallStack ? m_maxCallStackDepth : 0);
+    RefPtr<InspectorObject> record = TimelineRecordFactory::createGenericRecord(m_stopwatch->elapsedTime(), captureCallStack ? m_maxCallStackDepth : 0);
     record->setObject("data", data);
     setFrameIdentifier(record.get(), frame);
     addRecordToTimeline(record.release(), type);
 }
 
 void InspectorTimelineAgent::sendEvent(PassRefPtr<InspectorObject> event)
 {
     if (!m_frontendDispatcher)
         return;
 
     // FIXME: runtimeCast is a hack. We do it because we can't build TimelineEvent directly now.
     RefPtr<Inspector::Protocol::Timeline::TimelineEvent> recordChecked = BindingTraits<Inspector::Protocol::Timeline::TimelineEvent>::runtimeCast(event);
     m_frontendDispatcher->eventRecorded(recordChecked.release());
 }
 
 InspectorTimelineAgent::TimelineRecordEntry InspectorTimelineAgent::createRecordEntry(PassRefPtr<InspectorObject> data, TimelineRecordType type, bool captureCallStack, Frame* frame)
 {
-    RefPtr<InspectorObject> record = TimelineRecordFactory::createGenericRecord(timestamp(), captureCallStack ? m_maxCallStackDepth : 0);
+    RefPtr<InspectorObject> record = TimelineRecordFactory::createGenericRecord(m_stopwatch->elapsedTime(), captureCallStack ? m_maxCallStackDepth : 0);
     setFrameIdentifier(record.get(), frame);
     return TimelineRecordEntry(record.release(), data, InspectorArray::create(), type);
 }
 
 void InspectorTimelineAgent::pushCurrentRecord(PassRefPtr<InspectorObject> data, TimelineRecordType type, bool captureCallStack, Frame* frame)
 {
     pushCurrentRecord(createRecordEntry(data, type, captureCallStack, frame));
 }
 
 void InspectorTimelineAgent::clearRecordStack()
@@ -739,23 +748,18 @@ void InspectorTimelineAgent::clearRecordStack()
 void InspectorTimelineAgent::localToPageQuad(const RenderObject& renderer, const LayoutRect& rect, FloatQuad* quad)
 {
     const FrameView& frameView = renderer.view().frameView();
     FloatQuad absolute = renderer.localToAbsoluteQuad(FloatQuad(rect));
     quad->setP1(frameView.contentsToRootView(roundedIntPoint(absolute.p1())));
     quad->setP2(frameView.contentsToRootView(roundedIntPoint(absolute.p2())));
     quad->setP3(frameView.contentsToRootView(roundedIntPoint(absolute.p3())));
     quad->setP4(frameView.contentsToRootView(roundedIntPoint(absolute.p4())));
 }
 
-double InspectorTimelineAgent::timestamp()
-{
-    return m_timeConverter.fromMonotonicallyIncreasingTime(monotonicallyIncreasingTime());
-}
-
 Page* InspectorTimelineAgent::page()
 {
     return m_pageAgent ? m_pageAgent->page() : nullptr;
 }
 
 } // namespace WebCore
 
 #endif // ENABLE(INSPECTOR)
diff --git a/Source/WebCore/inspector/InspectorTimelineAgent.h b/Source/WebCore/inspector/InspectorTimelineAgent.h
index 524f972..11e97ef 100644
--- a/Source/WebCore/inspector/InspectorTimelineAgent.h
+++ b/Source/WebCore/inspector/InspectorTimelineAgent.h
@@ -33,20 +33,21 @@
 #define InspectorTimelineAgent_h
 
 #if ENABLE(INSPECTOR)
 
 #include "InspectorWebAgentBase.h"
 #include "InspectorWebBackendDispatchers.h"
 #include "InspectorWebFrontendDispatchers.h"
 #include "LayoutRect.h"
 #include <inspector/InspectorValues.h>
 #include <inspector/ScriptDebugListener.h>
+#include <wtf/Stopwatch.h>
 #include <wtf/Vector.h>
 #include <wtf/WeakPtr.h>
 
 namespace JSC {
 class Profile;
 }
 
 namespace WebCore {
 
 class Event;
@@ -106,33 +107,20 @@ enum class TimelineRecordType {
     RequestAnimationFrame,
     CancelAnimationFrame,
     FireAnimationFrame,
 
     WebSocketCreate,
     WebSocketSendHandshakeRequest,
     WebSocketReceiveHandshakeResponse,
     WebSocketDestroy
 };
 
-class TimelineTimeConverter {
-public:
-    TimelineTimeConverter()
-        : m_startOffset(0)
-    {
-    }
-    double fromMonotonicallyIncreasingTime(double time) const  { return (time - m_startOffset) * 1000.0; }
-    void reset();
-
-private:
-    double m_startOffset;
-};
-
 class InspectorTimelineAgent
     : public InspectorAgentBase
     , public Inspector::InspectorTimelineBackendDispatcherHandler
     , public Inspector::ScriptDebugListener {
     WTF_MAKE_NONCOPYABLE(InspectorTimelineAgent);
     WTF_MAKE_FAST_ALLOCATED;
 public:
     enum InspectorType { PageInspector, WorkerInspector };
 
     InspectorTimelineAgent(InstrumentingAgents*, InspectorPageAgent*, InspectorType, InspectorClient*);
@@ -211,25 +199,25 @@ public:
     void didFireAnimationFrame();
 
 #if ENABLE(WEB_SOCKETS)
     void didCreateWebSocket(unsigned long identifier, const URL&, const String& protocol, Frame*);
     void willSendWebSocketHandshakeRequest(unsigned long identifier, Frame*);
     void didReceiveWebSocketHandshakeResponse(unsigned long identifier, Frame*);
     void didDestroyWebSocket(unsigned long identifier, Frame*);
 #endif
 
 protected:
-    // ScriptDebugListener. This is only used to create records for probe samples.
+    // ScriptDebugListener
     virtual void didParseSource(JSC::SourceID, const Script&) override { }
     virtual void failedToParseSource(const String&, const String&, int, int, const String&) override { }
-    virtual void didPause(JSC::ExecState*, const Deprecated::ScriptValue&, const Deprecated::ScriptValue&) override { }
-    virtual void didContinue() override { }
+    virtual void didPause(JSC::ExecState*, const Deprecated::ScriptValue&, const Deprecated::ScriptValue&) override;
+    virtual void didContinue() override;
 
     virtual void breakpointActionLog(JSC::ExecState*, const String&) override { }
     virtual void breakpointActionSound(int) override { }
     virtual void breakpointActionProbe(JSC::ExecState*, const Inspector::ScriptBreakpointAction&, int hitCount, const Deprecated::ScriptValue& result) override;
 
 private:
     friend class TimelineRecordStack;
 
     struct TimelineRecordEntry {
         TimelineRecordEntry()
@@ -257,31 +245,29 @@ private:
 
     void setFrameIdentifier(Inspector::InspectorObject* record, Frame*);
 
     void didCompleteRecordEntry(const TimelineRecordEntry&);
     void didCompleteCurrentRecord(TimelineRecordType);
 
     void addRecordToTimeline(PassRefPtr<Inspector::InspectorObject>, TimelineRecordType);
     void clearRecordStack();
 
     void localToPageQuad(const RenderObject&, const LayoutRect&, FloatQuad*);
-    const TimelineTimeConverter& timeConverter() const { return m_timeConverter; }
-    double timestamp();
     Page* page();
 
     InspectorPageAgent* m_pageAgent;
     PageScriptDebugServer* m_scriptDebugServer;
-    TimelineTimeConverter m_timeConverter;
+
+    RefPtr<Stopwatch> m_stopwatch;
 
     std::unique_ptr<Inspector::InspectorTimelineFrontendDispatcher> m_frontendDispatcher;
     RefPtr<Inspector::InspectorTimelineBackendDispatcher> m_backendDispatcher;
-    double m_timestampOffset;
 
     Vector<TimelineRecordEntry> m_recordStack;
 
     int m_id;
     int m_callStackDepth;
     int m_maxCallStackDepth;
     InspectorType m_inspectorType;
     InspectorClient* m_client;
 
     Vector<TimelineRecordEntry> m_pendingConsoleProfileRecords;
diff --git a/Source/WebInspectorUI/ChangeLog b/Source/WebInspectorUI/ChangeLog
index 170c3c8..ddb996d 100644
--- a/Source/WebInspectorUI/ChangeLog
+++ b/Source/WebInspectorUI/ChangeLog
@@ -1,10 +1,21 @@
+2014-09-15  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Inspector: timelines should not count time elapsed while paused in the debugger
+        https://bugs.webkit.org/show_bug.cgi?id=136351
+
+        Reviewed by NOBODY (OOPS!).
+
+        * UserInterface/Controllers/TimelineManager.js:
+        (WebInspector.TimelineManager.prototype.eventRecorded.processRecord):
+        (WebInspector.TimelineManager.prototype.eventRecorded):
+
 2014-08-11  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Inspector: add eject current recording button to the replay dashboard
         https://bugs.webkit.org/show_bug.cgi?id=135225
 
         Reviewed by NOBODY (OOPS!).
 
         Add a new eject button item to the replay dashboard's embedded navigation bar.
         The eject button's visibility is mutually exclusive with that of the record button.
 
diff --git a/Source/WebInspectorUI/UserInterface/Controllers/TimelineManager.js b/Source/WebInspectorUI/UserInterface/Controllers/TimelineManager.js
index 90212e1..c6f452c0 100644
--- a/Source/WebInspectorUI/UserInterface/Controllers/TimelineManager.js
+++ b/Source/WebInspectorUI/UserInterface/Controllers/TimelineManager.js
@@ -157,22 +157,24 @@ WebInspector.TimelineManager.prototype = {
     eventRecorded: function(originalRecordPayload)
     {
         // Called from WebInspector.TimelineObserver.
 
         if (!this._isCapturing)
             return;
 
         function processRecord(recordPayload, parentRecordPayload)
         {
             // Convert the timestamps to seconds to match the resource timestamps.
-            var startTime = recordPayload.startTime / 1000;
-            var endTime = recordPayload.endTime / 1000;
+            // FIXME: compatibility: old versions pass milliseconds since epoch,
+            // while trunk uses seconds elapsed since start of recording.
+            var startTime = recordPayload.startTime;
+            var endTime = recordPayload.endTime;
 
             var callFrames = this._callFramesFromPayload(recordPayload.stackTrace);
 
             var significantCallFrame = null;
             if (callFrames) {
                 for (var i = 0; i < callFrames.length; ++i) {
                     if (callFrames[i].nativeCode)
                         continue;
                     significantCallFrame = callFrames[i];
                     break;
-- 
2.0.1

