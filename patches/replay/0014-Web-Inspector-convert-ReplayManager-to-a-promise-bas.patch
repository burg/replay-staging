From 0f90577f4aa764a64b1a51e75fb687d370290e94 Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Thu, 24 Jul 2014 09:23:12 -0700
Subject: [PATCH] Web Inspector: convert ReplayManager to a promise-based API
 https://bugs.webkit.org/show_bug.cgi?id=135249

Reviewed by NOBODY (OOPS!).

Source/WebCore:
Fix some assertions to match ReplayController's preconditions.

* inspector/InspectorReplayAgent.cpp:
(WebCore::InspectorReplayAgent::replayToPosition):
(WebCore::InspectorReplayAgent::replayToCompletion):

Source/WebInspectorUI:
Convert replay commands to an asynchronous, promise-based API. This addresses
two problems with a synchronous replay API: clients can only use the synchronous
API if session and segment state are exactly correct, and trying to change state
to match this requirement requires chaining multiple commands and events.

The asynchronous API allows clients to issue replay commands with impunity,
as long as they can be unambiguously handled. For example, issuing
pausePlayback*() while capturing is not allowed, but issuing startCapturing()
while replaying is allowed. The API also hides implementation details that
are not important, such as steps to unpause or temporarily disable the debugger.

This patch also cleans up uses of promises, such as adding error re-throwing.
It adds return type annotations to public ReplayManager asynchronous methods.

* UserInterface/Controllers/ReplayManager.js:
(WebInspector.ReplayManager.catch):
(WebInspector.ReplayManager):
(WebInspector.ReplayManager.prototype.createSession):
(WebInspector.ReplayManager.prototype.switchSession):
(WebInspector.ReplayManager.prototype.startCapturing):
(WebInspector.ReplayManager.prototype.stopCapturing):
(WebInspector.ReplayManager.prototype.replayToPosition):
(WebInspector.ReplayManager.prototype.replayToCompletion):
(WebInspector.ReplayManager.prototype.sessionCreated.catch): re-throw.
(WebInspector.ReplayManager.prototype.segmentCompleted.catch): re-throw.
(WebInspector.ReplayManager.prototype.segmentCompleted.catch): re-throw.
(WebInspector.ReplayManager.prototype.segmentUnloaded.catch): re-throw.
(WebInspector.ReplayManager.prototype.sessionCreated.catech): re-throw.

* UserInterface/Views/ReplayDashboardView.js: Switch to use the promise-based API.
Debounce buttons when they are clicked and reactivate when an action is taken.

(WebInspector.ReplayDashboardView.prototype._captureButtonItemClicked.then):
(WebInspector.ReplayDashboardView.prototype._captureButtonItemClicked):
(WebInspector.ReplayDashboardView.prototype._replayButtonItemClicked.then):
(WebInspector.ReplayDashboardView.prototype._replayButtonItemClicked):
(WebInspector.ReplayDashboardView.prototype._ejectButtonItemClicked.catch):
(WebInspector.ReplayDashboardView.prototype._ejectButtonItemClicked.then):
(WebInspector.ReplayDashboardView.prototype._ejectButtonItemClicked):
(WebInspector.ReplayDashboardView.prototype._captureStopped):
(WebInspector.ReplayDashboardView.prototype._playbackStarted):
(WebInspector.ReplayDashboardView.prototype._playbackPaused):
(WebInspector.ReplayDashboardView.prototype._playbackFinished):
(WebInspector.ReplayDashboardView.prototype._activeSessionChanged):
---
 Source/WebCore/ChangeLog                           |  13 +
 Source/WebCore/inspector/InspectorReplayAgent.cpp  |   8 +-
 Source/WebInspectorUI/ChangeLog                    |  52 ++++
 .../UserInterface/Controllers/ReplayManager.js     | 315 +++++++++++++++------
 .../UserInterface/Views/ReplayDashboardView.js     |  66 +++--
 5 files changed, 345 insertions(+), 109 deletions(-)

diff --git a/Source/WebCore/ChangeLog b/Source/WebCore/ChangeLog
index c595d27..2415082 100644
--- a/Source/WebCore/ChangeLog
+++ b/Source/WebCore/ChangeLog
@@ -1,10 +1,23 @@
+2014-07-24  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Inspector: convert ReplayManager to a promise-based API
+        https://bugs.webkit.org/show_bug.cgi?id=135249
+
+        Reviewed by NOBODY (OOPS!).
+
+        Fix some assertions to match ReplayController's preconditions.
+
+        * inspector/InspectorReplayAgent.cpp:
+        (WebCore::InspectorReplayAgent::replayToPosition):
+        (WebCore::InspectorReplayAgent::replayToCompletion):
+
 2014-07-23  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Inspector: add eject current recording button to the replay dashboard
         https://bugs.webkit.org/show_bug.cgi?id=135225
 
         Reviewed by NOBODY (OOPS!).
 
         Add a protocol method that creates an empty replay session. To eject, the
         frontend creates an empty session and then switches to it.
 
diff --git a/Source/WebCore/inspector/InspectorReplayAgent.cpp b/Source/WebCore/inspector/InspectorReplayAgent.cpp
index e610140..6c78ea4e 100644
--- a/Source/WebCore/inspector/InspectorReplayAgent.cpp
+++ b/Source/WebCore/inspector/InspectorReplayAgent.cpp
@@ -346,32 +346,32 @@ void InspectorReplayAgent::replayToPosition(ErrorString* errorString, const RefP
     if (!positionObject->getNumber(ASCIILiteral("segmentOffset"), &position.segmentOffset)) {
         *errorString = ASCIILiteral("Couldn't decode ReplayPosition segment offset provided to ReplayAgent.replayToPosition.");
         return;
     }
 
     if (!positionObject->getNumber(ASCIILiteral("inputOffset"), &position.inputOffset)) {
         *errorString = ASCIILiteral("Couldn't decode ReplayPosition input offset provided to ReplayAgent.replayToPosition.");
         return;
     }
 
-    if (sessionState() != SessionState::Inactive) {
-        *errorString = ASCIILiteral("Can't start replay while capture or playback is in progress.");
+    if (sessionState() == SessionState::Capturing) {
+        *errorString = ASCIILiteral("Can't start replay while capture is in progress.");
         return;
     }
 
     m_page.replayController().replayToPosition(position, (fastReplay) ? DispatchSpeed::FastForward : DispatchSpeed::RealTime);
 }
 
 void InspectorReplayAgent::replayToCompletion(ErrorString* errorString, bool fastReplay)
 {
-    if (sessionState() != SessionState::Inactive) {
-        *errorString = ASCIILiteral("Can't start replay while capture or playback is in progress.");
+    if (sessionState() == SessionState::Capturing) {
+        *errorString = ASCIILiteral("Can't start replay while capture is in progress.");
         return;
     }
 
     m_page.replayController().replayToCompletion((fastReplay) ? DispatchSpeed::FastForward : DispatchSpeed::RealTime);
 }
 
 void InspectorReplayAgent::pausePlayback(ErrorString* errorString)
 {
     if (sessionState() != SessionState::Replaying) {
         *errorString = ASCIILiteral("Can't pause playback if playback is not in progress.");
diff --git a/Source/WebInspectorUI/ChangeLog b/Source/WebInspectorUI/ChangeLog
index b74cdc1..984884d 100644
--- a/Source/WebInspectorUI/ChangeLog
+++ b/Source/WebInspectorUI/ChangeLog
@@ -1,12 +1,64 @@
 2014-07-24  Brian J. Burg  <burg@cs.washington.edu>
 
+        Web Inspector: convert ReplayManager to a promise-based API
+        https://bugs.webkit.org/show_bug.cgi?id=135249
+
+        Reviewed by NOBODY (OOPS!).
+
+        Convert replay commands to an asynchronous, promise-based API. This addresses
+        two problems with a synchronous replay API: clients can only use the synchronous
+        API if session and segment state are exactly correct, and trying to change state
+        to match this requirement requires chaining multiple commands and events.
+
+        The asynchronous API allows clients to issue replay commands with impunity,
+        as long as they can be unambiguously handled. For example, issuing
+        pausePlayback*() while capturing is not allowed, but issuing startCapturing()
+        while replaying is allowed. The API also hides implementation details that
+        are not important, such as steps to unpause or temporarily disable the debugger.
+
+        This patch also cleans up uses of promises, such as adding error re-throwing.
+        It adds return type annotations to public ReplayManager asynchronous methods.
+
+        * UserInterface/Controllers/ReplayManager.js:
+        (WebInspector.ReplayManager.catch):
+        (WebInspector.ReplayManager):
+        (WebInspector.ReplayManager.prototype.createSession):
+        (WebInspector.ReplayManager.prototype.switchSession):
+        (WebInspector.ReplayManager.prototype.startCapturing):
+        (WebInspector.ReplayManager.prototype.stopCapturing):
+        (WebInspector.ReplayManager.prototype.replayToPosition):
+        (WebInspector.ReplayManager.prototype.replayToCompletion):
+        (WebInspector.ReplayManager.prototype.sessionCreated.catch): re-throw.
+        (WebInspector.ReplayManager.prototype.segmentCompleted.catch): re-throw.
+        (WebInspector.ReplayManager.prototype.segmentCompleted.catch): re-throw.
+        (WebInspector.ReplayManager.prototype.segmentUnloaded.catch): re-throw.
+        (WebInspector.ReplayManager.prototype.sessionCreated.catech): re-throw.
+
+        * UserInterface/Views/ReplayDashboardView.js: Switch to use the promise-based API.
+        Debounce buttons when they are clicked and reactivate when an action is taken.
+
+        (WebInspector.ReplayDashboardView.prototype._captureButtonItemClicked.then):
+        (WebInspector.ReplayDashboardView.prototype._captureButtonItemClicked):
+        (WebInspector.ReplayDashboardView.prototype._replayButtonItemClicked.then):
+        (WebInspector.ReplayDashboardView.prototype._replayButtonItemClicked):
+        (WebInspector.ReplayDashboardView.prototype._ejectButtonItemClicked.catch):
+        (WebInspector.ReplayDashboardView.prototype._ejectButtonItemClicked.then):
+        (WebInspector.ReplayDashboardView.prototype._ejectButtonItemClicked):
+        (WebInspector.ReplayDashboardView.prototype._captureStopped):
+        (WebInspector.ReplayDashboardView.prototype._playbackStarted):
+        (WebInspector.ReplayDashboardView.prototype._playbackPaused):
+        (WebInspector.ReplayDashboardView.prototype._playbackFinished):
+        (WebInspector.ReplayDashboardView.prototype._activeSessionChanged):
+
+2014-07-24  Brian J. Burg  <burg@cs.washington.edu>
+
         Web Inspector: protocol command invocations should return a promise if no callback is supplied
         https://bugs.webkit.org/show_bug.cgi?id=130702
 
         Reviewed by NOBODY (OOPS!).
 
         This allows the trailing Agent.command.promise(args) to be dropped in favor of just
         Agent.command(args). It should make it a bit easier to convert code to use promises.
 
         Test: LayoutTests/inspector/protocol-promise-result.html
 
diff --git a/Source/WebInspectorUI/UserInterface/Controllers/ReplayManager.js b/Source/WebInspectorUI/UserInterface/Controllers/ReplayManager.js
index e59c1d9..18f52b2 100644
--- a/Source/WebInspectorUI/UserInterface/Controllers/ReplayManager.js
+++ b/Source/WebInspectorUI/UserInterface/Controllers/ReplayManager.js
@@ -45,42 +45,43 @@ WebInspector.ReplayManager = function()
 
     // Playback speed is specified in replayToPosition commands, and persists
     // for the duration of the playback command until another playback begins.
     this._playbackSpeed = WebInspector.ReplayManager.PlaybackSpeed.RealTime;
 
     if (!window.ReplayAgent)
         return;
 
     var instance = this;
 
-    this._initializationPromise = ReplayAgent.currentReplayState.promise()
+    this._initializationPromise = ReplayAgent.currentReplayState()
         .then(function(payload) {
             console.assert(payload.sessionState in WebInspector.ReplayManager.SessionState, "Unknown session state: " + payload.sessionState);
             console.assert(payload.segmentState in WebInspector.ReplayManager.SegmentState, "Unknown segment state: " + payload.segmentState);
 
             instance._activeSessionIdentifier = payload.sessionIdentifier;
             instance._activeSegmentIdentifier = payload.segmentIdentifier;
             instance._sessionState = WebInspector.ReplayManager.SessionState[payload.sessionState];
             instance._segmentState = WebInspector.ReplayManager.SegmentState[payload.segmentState];
             instance._currentPosition = payload.replayPosition;
 
             instance._initialized = true;
         })
         .then(function() {
-            return ReplayAgent.getAvailableSessions.promise();
+            return ReplayAgent.getAvailableSessions();
         })
         .then(function(payload) {
             for (var sessionId of payload.ids)
                 instance.sessionCreated(sessionId);
         })
-        .catch(function(err) {
-            console.error("ReplayManager initialization failed: ", err);
+        .catch(function(error) {
+            console.error("ReplayManager initialization failed: ", error);
+            throw error;
         });
 };
 
 WebInspector.ReplayManager.Event = {
     CaptureStarted: "replay-manager-capture-started",
     CaptureStopped: "replay-manager-capture-stopped",
 
     PlaybackStarted: "replay-manager-playback-started",
     PlaybackPaused: "replay-manager-playback-paused",
     PlaybackFinished: "replay-manager-playback-finished",
@@ -157,54 +158,274 @@ WebInspector.ReplayManager.prototype = {
         console.assert(this._initialized);
         this._playbackSpeed = value;
     },
 
     get currentPosition()
     {
         console.assert(this._initialized);
         return this._currentPosition;
     },
 
-    // These return promises even if the relevant instance is already created.
-    waitUntilInitialized: function()
+
+    // Public - Asynchronous API
+    //
+    // Methods in this section return promises and require the manager to be initialized.
+
+    // Return a promise that resolves when the manager is fully initialized.
+    waitUntilInitialized: function() // --> ()
     {
         return this._initializationPromise;
     },
 
-    getSession: function(sessionId)
+    // Return a promise that resolves to a session, if it exists.
+    getSession: function(sessionId) // --> (WebInspector.ReplaySession)
     {
+        console.assert(this._initialized);
+
         if (this._sessionPromises.has(sessionId))
             return this._sessionPromises.get(sessionId);
 
-        var newPromise = ReplayAgent.getSessionData.promise(sessionId)
+        var newPromise = ReplayAgent.getSessionData(sessionId)
             .then(function(payload) {
                 return Promise.resolve(WebInspector.ReplaySession.fromPayload(sessionId, payload));
             });
 
         this._sessionPromises.set(sessionId, newPromise);
         return newPromise;
     },
 
-    getSegment: function(segmentId)
+    // Return a promise that resolves to a session segment, if it exists.
+    getSegment: function(segmentId) // --> (WebInspector.ReplaySessionSegment)
     {
+        console.assert(this._initialized);
+
         if (this._segmentPromises.has(segmentId))
             return this._segmentPromises.get(segmentId);
 
-        var newPromise = ReplayAgent.getSegmentData.promise(segmentId)
+        var newPromise = ReplayAgent.getSegmentData(segmentId)
             .then(function(payload) {
                 return Promise.resolve(new WebInspector.ReplaySessionSegment(segmentId, payload));
             });
 
         this._segmentPromises.set(segmentId, newPromise);
         return newPromise;
     },
 
+    // Create a new, empty session.
+    // Returns a promise that can resolve to the created session identifier.
+    createSession: function() // --> (sessionId)
+    {
+        console.assert(this._initialized);
+
+        return ReplayAgent.createSession()
+            .then(function unwrapPayload(payload) {
+                return payload.sessionIdentifier;
+            })
+            .catch(function(error) {
+                console.error("Failed to create new session: ", error);
+                throw error;
+            });
+    },
+
+    // Switch to the specified session.
+    // Returns a promise that resolves when the switch completes.
+    switchSession: function(sessionId) { // --> ()
+        var manager = this;
+        var result = this.waitUntilInitialized();
+
+        if (this.sessionState === WebInspector.ReplayManager.SessionState.Capturing) {
+            result = result.then(function() {
+                return WebInspector.replayManager.stopCapturing();
+            });
+        }
+
+        if (this.sessionState === WebInspector.ReplayManager.SessionState.Replaying) {
+            result = result.then(function() {
+                return WebInspector.replayManager.stopPlayback();
+            });
+        }
+
+        result = result.then(function() {
+                console.assert(manager.sessionState === WebInspector.ReplayManager.SessionState.Inactive);
+                console.assert(manager.segmentState === WebInspector.ReplayManager.SegmentState.Unloaded);
+
+                return manager.getSession(sessionId);
+            })
+            .then(function ensureSessionDataIsLoaded(session) {
+                return ReplayAgent.switchSession(session.identifier);
+            })
+            .catch(function(error) {
+                console.error("Failed to switch to session: ", error);
+                throw error;
+            });
+
+        return result;
+    },
+
+    // Start capturing into the current session as soon as possible.
+    // Returns a promise that resolves when capturing begins.
+    startCapturing: function() // --> ()
+    {
+        var manager = this;
+        var result = this.waitUntilInitialized();
+
+        if (this.sessionState === WebInspector.ReplayManager.SessionState.Capturing)
+            return result; // Already capturing.
+
+        if (this.sessionState === WebInspector.ReplayManager.SessionState.Replaying) {
+            result = result.then(function() {
+                return WebInspector.replayManager.stopPlayback();
+            });
+        }
+
+        result = result.then(function() {
+                console.assert(manager.sessionState === WebInspector.ReplayManager.SessionState.Inactive);
+                console.assert(manager.segmentState === WebInspector.ReplayManager.SegmentState.Unloaded);
+
+                return ReplayAgent.startCapturing();
+            })
+            .catch(function(error) {
+                console.error("Failed to start capturing: ", error);
+                throw error;
+            });
+
+        return result;
+    },
+
+    // Stop capturing into the current session as soon as possible.
+    // Returns a promise that resolves when capturing ends.
+    stopCapturing: function() // --> ()
+    {
+        console.assert(this.sessionState === WebInspector.ReplayManager.SessionState.Capturing, "Cannot stop capturing unless capture is active.");
+        console.assert(this.segmentState === WebInspector.ReplayManager.SegmentState.Appending);
+
+        return ReplayAgent.stopCapturing()
+            .catch(function(error) {
+                console.error("Failed to stop capturing: ", error);
+                throw error;
+            });
+    },
+
+    // Pause playback as soon as possible.
+    // Returns a promise that resolves when playback is paused.
+    pausePlayback: function() // --> ()
+    {
+        console.assert(this.sessionState !== WebInspector.ReplayManager.SessionState.Capturing, "Cannot pause playback while capturing.");
+
+        var manager = this;
+        var result = this.waitUntilInitialized();
+
+        if (this.sessionState === WebInspector.ReplayManager.SessionState.Inactive)
+            return result; // Already stopped.
+
+        if (this.sessionState !== WebInspector.ReplayManager.SegmentState.Dispatching)
+            return result; // Already stopped.
+
+        result = result.then(function() {
+                console.assert(manager.sessionState === WebInspector.ReplayManager.SessionState.Replaying);
+                console.assert(manager.segmentState === WebInspector.ReplayManager.SegmentState.Dispatching);
+
+                return ReplayAgent.pausePlayback();
+            })
+            .catch(function(error) {
+                console.error("Failed to pause playback: ", error);
+                throw error;
+            });
+
+        return result;
+    },
+
+    // Pause playback and unload the current session segment as soon as possible.
+    // Returns a promise that resolves when the current segment is unloaded.
+    stopPlayback: function() // --> ()
+    {
+        console.assert(this.sessionState !== WebInspector.ReplayManager.SessionState.Capturing, "Cannot stop playback while capturing.");
+
+        var manager = this;
+        var result = this.waitUntilInitialized();
+
+        if (this.sessionState === WebInspector.ReplayManager.SessionState.Inactive)
+            return result; // Already stopped.
+
+        result = result.then(function() {
+                console.assert(manager.sessionState === WebInspector.ReplayManager.SessionState.Replaying);
+                console.assert(manager.segmentState !== WebInspector.ReplayManager.SegmentState.Appending);
+
+                return ReplayAgent.stopPlayback();
+            })
+            .catch(function(error) {
+                console.error("Failed to stop playback: ", error);
+                throw error;
+            });
+
+        return result;
+    },
+
+    // Replay to the specified position as soon as possible using the current replay speed.
+    // Returns a promise that resolves when replay has begun (NOT when the position is reached).
+    replayToPosition: function(replayPosition) // --> ()
+    {
+        console.assert(replayPosition instanceof WebInspector.ReplayPosition, "Cannot replay to a position while capturing.");
+
+        var manager = this;
+        var result = this.waitUntilInitialized();
+
+        if (this.sessionState === WebInspector.ReplayManager.SessionState.Capturing) {
+            result = result.then(function() {
+                return WebInspector.replayManager.stopCapturing();
+            });
+        }
+
+        result = result.then(function() {
+                console.assert(manager.sessionState !== WebInspector.ReplayManager.SessionState.Capturing);
+                console.assert(manager.segmentState !== WebInspector.ReplayManager.SegmentState.Appending);
+
+                return ReplayAgent.replayToPosition(replayPosition, manager.playbackSpeed === WebInspector.ReplayManager.PlaybackSpeed.FastForward);
+            })
+            .catch(function(error) {
+                console.error("Failed to start playback to position: ", replayPosition, error);
+                throw error;
+            });
+
+        return result;
+    },
+
+    // Replay to the end of the session as soon as possible using the current replay speed.
+    // Returns a promise that resolves when replay has begun (NOT when the end is reached).
+    replayToCompletion: function() // --> ()
+    {
+        var manager = this;
+        var result = this.waitUntilInitialized();
+
+        if (this.segmentState === WebInspector.ReplayManager.SegmentState.Dispatching)
+            return result; // Already running.
+
+        if (this.sessionState === WebInspector.ReplayManager.SessionState.Capturing) {
+            result = result.then(function() {
+                return WebInspector.replayManager.stopCapturing();
+            });
+        }
+
+        result = result.then(function() {
+                console.assert(manager.sessionState !== WebInspector.ReplayManager.SessionState.Capturing);
+                console.assert(manager.segmentState === WebInspector.ReplayManager.SegmentState.Loaded || manager.segmentState === WebInspector.ReplayManager.SegmentState.Unloaded);
+
+                return ReplayAgent.replayToCompletion(manager.playbackSpeed === WebInspector.ReplayManager.PlaybackSpeed.FastForward)
+            })
+            .catch(function(error) {
+                console.error("Failed to start playback to completion: ", error);
+                throw error;
+            });
+
+        return result;
+    },
+
     // Protected (called by ReplayObserver)
 
     // Since these methods update session and segment state, they depend on the manager
     // being properly initialized. So, each function body is prepended with a retry guard.
     // This makes call sites simpler and avoids an extra event loop turn in the common case.
 
     captureStarted: function()
     {
         if (!this._initialized)
             return this.waitUntilInitialized().then(this.captureStarted.bind(this));
@@ -279,20 +500,21 @@ WebInspector.ReplayManager.prototype = {
             return this.waitUntilInitialized().then(this.sessionCreated.bind(this, sessionId));
 
         console.assert(!this._sessions.has(sessionId), "Tried to add duplicate session identifier:", sessionId);
         var sessionMap = this._sessions;
         this.getSession(sessionId)
             .then(function(session) {
                 sessionMap.set(sessionId, session);
             })
             .catch(function(error) {
                 console.error("Error obtaining session data: ", error);
+                throw error;
             });
 
         this.dispatchEventToListeners(WebInspector.ReplayManager.Event.SessionAdded, {sessionId: sessionId});
     },
 
     sessionModified: function(sessionId)
     {
         if (!this._initialized)
             return this.waitUntilInitialized().then(this.sessionModified.bind(this, sessionId));
 
@@ -362,39 +584,39 @@ WebInspector.ReplayManager.prototype = {
         console.assert(placeholderSegment instanceof WebInspector.IncompleteSessionSegment);
         this._segmentPromises.delete(segmentId);
 
         var segmentMap = this._segments;
         this.getSegment(segmentId)
             .then(function(segment) {
                 segmentMap.set(segmentId, segment);
             })
             .catch(function(error) {
                 console.error("Error obtaining segment data: ", error);
+                throw error;
             });
     },
 
     segmentRemoved: function(segmentId)
     {
         if (!this._initialized)
             return this.waitUntilInitialized().then(this.segmentRemoved.bind(this, segmentId));
 
         console.assert(this._segments.has(segmentId), "Unknown segment identifier:", segmentId);
 
         if (!this._segmentPromises.has(segmentId))
             return;
 
         var manager = this;
 
-        // Wait for any outstanding promise to settle so it doesn't get re-added.
         this.getSegment(segmentId)
             .catch(function(error) {
-                return Promise.resolve();
+                // Wait for any outstanding promise to settle so it doesn't get re-added.
             })
             .then(function() {
                 manager._segmentPromises.delete(segmentId);
                 var removedSegment = manager._segments.take(segmentId);
                 console.assert(removedSegment);
                 manager.dispatchEventToListeners(WebInspector.ReplayManager.Event.SessionSegmentRemoved, {removedSegment: removedSegment});
             });
     },
 
     segmentLoaded: function(segmentId)
@@ -420,89 +642,20 @@ WebInspector.ReplayManager.prototype = {
         console.assert(this.sessionState === WebInspector.ReplayManager.SessionState.Replaying);
         this._changeSegmentState(WebInspector.ReplayManager.SegmentState.Unloaded);
 
         var previousIdentifier = this._activeSegmentIdentifier;
         this._activeSegmentIdentifier = null;
         this.dispatchEventToListeners(WebInspector.ReplayManager.Event.ActiveSegmentChanged, {previousSegmentIdentifier: previousIdentifier});
     },
 
     // Private
 
-    // FIXME: these methods should be private and only accessed by implementations of the public API,
-    // which should properly chain async calls leading up to these low-level backend calls. Otherwise,
-    // their preconditions on session and segment state are too strong for scenarios triggered by the UI.
-
-    startCapturing: function()
-    {
-        console.assert(this.sessionState === WebInspector.ReplayManager.SessionState.Inactive);
-        console.assert(this.segmentState === WebInspector.ReplayManager.SegmentState.Unloaded);
-
-        ReplayAgent.startCapturing();
-    },
-
-    stopCapturing: function()
-    {
-        console.assert(this.sessionState === WebInspector.ReplayManager.SessionState.Capturing);
-        console.assert(this.segmentState === WebInspector.ReplayManager.SegmentState.Appending);
-
-        ReplayAgent.stopCapturing();
-    },
-
-    replayToMarkIndex: function(replayPosition)
-    {
-        console.assert(replayPosition instanceof WebInspector.ReplayPosition);
-
-        console.assert(this.sessionState !== WebInspector.ReplayManager.SessionState.Capturing);
-        // FIXME: Once the public API is asynchronous, we should assert that segmentState is Loaded.
-
-        ReplayAgent.replayToPosition(replayPosition, this.playbackSpeed === WebInspector.ReplayManager.PlaybackSpeed.FastForward);
-    },
-
-    replayToCompletion: function()
-    {
-        console.assert(this.sessionState !== WebInspector.ReplayManager.SessionState.Capturing);
-        // FIXME: Once the public API is asynchronous, we should assert that segmentState is Loaded.
-
-        ReplayAgent.replayToCompletion(this.playbackSpeed === WebInspector.ReplayManager.PlaybackSpeed.FastForward);
-    },
-
-    pausePlayback: function()
-    {
-        console.assert(this.sessionState === WebInspector.ReplayManager.SessionState.Replaying);
-        console.assert(this.segmentState === WebInspector.ReplayManager.SegmentState.Dispatching);
-
-        ReplayAgent.pausePlayback();
-    },
-
-    stopPlayback: function()
-    {
-        console.assert(this.sessionState === WebInspector.ReplayManager.SessionState.Replaying);
-        console.assert(this.segmentState === WebInspector.ReplayManager.SegmentState.Loaded);
-
-        ReplayAgent.stopPlayback();
-    },
-
-    createSession: function()
-    {
-        ReplayAgent.createSession();
-    },
-
-    switchSession: function(sessionId) {
-        console.assert(this.sessionState === WebInspector.ReplayManager.SessionState.Inactive);
-        console.assert(this.segmentState === WebInspector.ReplayManager.SegmentState.Unloaded);
-        console.assert(this._sessions.has(sessionId), "Unknown session identifier:", sessionId);
-
-        ReplayAgent.switchSession(sessionId);
-    },
-
-    // Private
-
     _changeSessionState: function(newState)
     {
         // Warn about no-op state changes. We shouldn't be seeing them.
         var isAllowed = this._sessionState !== newState;
 
         switch (this._sessionState) {
         case WebInspector.ReplayManager.SessionState.Capturing:
             isAllowed &= newState === WebInspector.ReplayManager.SessionState.Inactive;
             break;
 
diff --git a/Source/WebInspectorUI/UserInterface/Views/ReplayDashboardView.js b/Source/WebInspectorUI/UserInterface/Views/ReplayDashboardView.js
index dcffc0e..84a91a2 100644
--- a/Source/WebInspectorUI/UserInterface/Views/ReplayDashboardView.js
+++ b/Source/WebInspectorUI/UserInterface/Views/ReplayDashboardView.js
@@ -79,85 +79,103 @@ WebInspector.ReplayDashboardView.RecordButtonStyleClassName = "record-button";
 WebInspector.ReplayDashboardView.ReplayButtonStyleClassName = "replay-button";
 
 WebInspector.ReplayDashboardView.prototype = {
     constructor: WebInspector.ReplayDashboardView,
     __proto__: WebInspector.DashboardView.prototype,
 
     // Private
 
     _captureButtonItemClicked: function()
     {
+        // Debounce.
+        var button = this._captureButtonItem;
+        button.enabled = false;
+
+        var result = null;
+
         if (WebInspector.replayManager.sessionState !== WebInspector.ReplayManager.SessionState.Capturing)
-            WebInspector.replayManager.startCapturing();
+            result = WebInspector.replayManager.startCapturing();
         else
-            WebInspector.replayManager.stopCapturing();
+            result = WebInspector.replayManager.stopCapturing();
+
+        result.catch(function(error) {
+            console.error("Failed to start or stop capturing: ", error);
+        }).then(function() {
+            button.enabled = true;
+        });
     },
 
     _replayButtonItemClicked: function(event)
     {
         console.assert(WebInspector.replayManager.sessionState !== WebInspector.ReplayManager.SessionState.Capturing, "Tried to start replaying while SessionState is Capturing!");
 
-        if (WebInspector.replayManager.sessionState === WebInspector.ReplayManager.SessionState.Inactive)
-            WebInspector.replayManager.replayToCompletion();
-        else if (WebInspector.replayManager.segmentState === WebInspector.ReplayManager.SegmentState.Dispatching)
-            WebInspector.replayManager.pausePlayback();
+        // Debounce.
+        var button = this._replayButtonItem;
+        button.enabled = false;
+
+        var result = null;
+
+        if (WebInspector.replayManager.segmentState === WebInspector.ReplayManager.SegmentState.Dispatching)
+            result = WebInspector.replayManager.pausePlayback();
         else
-            WebInspector.replayManager.replayToCompletion();
+            result = WebInspector.replayManager.replayToCompletion();
+
+        result.catch(function(error) {
+            console.error("Failed to play or pause: ", error);
+        }).then(function() {
+            button.enabled = true;
+        });
     },
 
     _ejectButtonItemClicked: function(event)
     {
         console.assert(WebInspector.replayManager.sessionState !== WebInspector.ReplayManager.SessionState.Capturing, "Tried to eject session while SessionState is Capturing!");
 
         // Debounce.
-        this._ejectButtonItem.enabled = false;
-
         var button = this._ejectButtonItem;
-
-        new Promise(function createEmptySession(resolve, reject) {
-            // FIXME: this listener should not be necessary when ReplayManager API becomes fully async.
-            WebInspector.replayManager.addSingleFireEventListener(WebInspector.ReplayManager.Event.SessionAdded, resolve);
-            WebInspector.replayManager.createSession();
-        }).then(function forceSessionToBeLoaded(event) {
-            var sessionId = event.data.sessionId;
-            return WebInspector.replayManager.getSession(sessionId);
-        }).then(function switchToEmptySession(session) {
-            WebInspector.replayManager.switchSession(session.identifier);
-            button.enabled = true;
-        }).catch(function(error) {
-            console.error("Failed to eject currect recording: ", error);
-        });
+        button.enabled = false;
+
+        WebInspector.replayManager.createSession()
+            .then(function switchToEmptySession(sessionId) {
+                return WebInspector.replayManager.switchSession(sessionId);
+            }).catch(function(error) {
+                console.error("Failed to eject current recording: ", error);
+            }).then(function() {
+                button.enabled = true;
+            });
     },
 
     _captureStarted: function()
     {
-        this._captureButtonItem.hidden = false;
         this._captureButtonItem.activated = true;
+        this._captureButtonItem.hidden = false;
         this._replayButtonItem.hidden = true;
         this._ejectButtonItem.hidden = true;
     },
 
     _captureStopped: function()
     {
         this._captureButtonItem.activated = false;
         this._captureButtonItem.hidden = true;
         this._replayButtonItem.hidden = false;
         this._ejectButtonItem.hidden = false;
     },
 
     _playbackStarted: function()
     {
+        // Show the pause button.
         this._replayButtonItem.toggled = true;
     },
 
     _playbackPaused: function()
     {
+        // Show the play button.
         this._replayButtonItem.toggled = false;
     },
 
     _playbackFinished: function()
     {
         this._replayButtonItem.toggled = false;
     },
 
     _activeSessionChanged: function()
     {
-- 
2.0.1

