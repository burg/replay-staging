From 7452b02a2ccd99ce490311b345f8126d75fd2660 Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Mon, 28 Jul 2014 09:03:09 -0700
Subject: [PATCH] WIP - WK2 dispatching

---
 Source/WebCore/replay/EventLoopInputDispatcher.cpp |  4 +-
 Source/WebCore/replay/ReplayClient.h               | 48 ++++++++++++++++++++++
 Source/WebCore/replay/ReplayController.cpp         |  4 +-
 Source/WebCore/replay/ReplayController.h           |  4 +-
 .../WebCore/replay/ReplayInputDispatchMethods.cpp  |  2 +-
 5 files changed, 55 insertions(+), 7 deletions(-)
 create mode 100644 Source/WebCore/replay/ReplayClient.h

diff --git a/Source/WebCore/replay/EventLoopInputDispatcher.cpp b/Source/WebCore/replay/EventLoopInputDispatcher.cpp
index 7f23a15..0a919c5 100644
--- a/Source/WebCore/replay/EventLoopInputDispatcher.cpp
+++ b/Source/WebCore/replay/EventLoopInputDispatcher.cpp
@@ -136,35 +136,35 @@ void EventLoopInputDispatcher::dispatchInput()
     }
 
 #if !LOG_DISABLED
     EncodedValue encodedInput = EncodingTraits<NondeterministicInputBase>::encodeValue(*m_currentWork.input);
     String jsonString = encodedInput.asObject()->toJSONString();
 
     LOG(WebReplay, "%-20s ----------------------------------------------", "ReplayEvents");
     LOG(WebReplay, "%-20s >DISPATCH: %s %s\n", "ReplayEvents", m_currentWork.input->type().string().utf8().data(), jsonString.utf8().data());
 #endif
 
-    m_client->willDispatchInput(*m_currentWork.input);
+    m_client->willDispatchInput();
     // Client could stop replay in the previous callback, so check again.
     if (!m_running)
         return;
 
     {
         TemporaryChange<bool> change(m_dispatching, true);
         m_currentWork.input->dispatch(m_page.replayController());
     }
 
     EventLoopInputBase* dispatchedInput = m_currentWork.input;
     m_currentWork.input = nullptr;
 
     // Notify clients that the event was dispatched.
-    m_client->didDispatchInput(*dispatchedInput);
+    m_client->didDispatchInput();
     if (dispatchedInput->type() == inputTypes().EndSegmentSentinel) {
         m_running = false;
         m_dispatching = false;
         m_client->didDispatchFinalInput();
         return;
     }
 
     // Clients could stop replay during event dispatch, or from any callback above.
     if (!m_running)
         return;
diff --git a/Source/WebCore/replay/ReplayClient.h b/Source/WebCore/replay/ReplayClient.h
new file mode 100644
index 0000000..f5d5704
--- /dev/null
+++ b/Source/WebCore/replay/ReplayClient.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2014 University of Washington. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef ReplayClient_h
+#define ReplayClient_h
+
+#if ENABLE(WEB_REPLAY)
+
+#include "ContextMenu.h"
+#include "PlatformMenuDescription.h"
+#include <wtf/Forward.h>
+#include <wtf/PassOwnPtr.h>
+
+namespace WebCore {
+
+    class ReplayClient {
+    public:
+        virtual ~ReplayClient() { }
+
+        virtual void dispatch(EventLoopInput&) = 0;
+    };
+}
+
+#endif // ENABLE(WEB_REPLAY)
+
+#endif // ReplayClient_h
diff --git a/Source/WebCore/replay/ReplayController.cpp b/Source/WebCore/replay/ReplayController.cpp
index 3c3670e..8c2771a 100644
--- a/Source/WebCore/replay/ReplayController.cpp
+++ b/Source/WebCore/replay/ReplayController.cpp
@@ -506,31 +506,31 @@ InputCursor& ReplayController::activeInputCursor() const
 EventLoopInputDispatcher& ReplayController::dispatcher() const
 {
     ASSERT(m_sessionState == SessionState::Replaying);
     ASSERT(m_segmentState == SegmentState::Dispatching);
     ASSERT(m_activeCursor);
     ASSERT(m_activeCursor->isReplaying());
 
     return static_cast<ReplayingInputCursor&>(*m_activeCursor).dispatcher();
 }
 
-void ReplayController::willDispatchInput(const EventLoopInputBase&)
+void ReplayController::willDispatchInput()
 {
     ASSERT(m_sessionState == SessionState::Replaying);
     ASSERT(m_segmentState == SegmentState::Dispatching);
 
     m_currentPosition.inputOffset++;
     if (m_currentPosition == m_targetPosition)
         pausePlayback();
 }
 
-void ReplayController::didDispatchInput(const EventLoopInputBase&)
+void ReplayController::didDispatchInput()
 {
     ASSERT(m_sessionState == SessionState::Replaying);
     ASSERT(m_segmentState == SegmentState::Dispatching);
 
     InspectorInstrumentation::playbackHitPosition(&m_page, m_currentPosition);
 }
 
 void ReplayController::didDispatchFinalInput()
 {
     ASSERT(m_segmentState == SegmentState::Dispatching);
diff --git a/Source/WebCore/replay/ReplayController.h b/Source/WebCore/replay/ReplayController.h
index 70a60d8..b0659c7 100644
--- a/Source/WebCore/replay/ReplayController.h
+++ b/Source/WebCore/replay/ReplayController.h
@@ -141,22 +141,22 @@ public:
     SegmentState segmentState() const { return m_segmentState; }
 
     PassRefPtr<ReplaySession> loadedSession() const;
     PassRefPtr<ReplaySessionSegment> loadedSegment() const;
 
     JSC::InputCursor& activeInputCursor() const;
     ReplayPosition currentPosition() const { return m_currentPosition; }
 
 private:
     // EventLoopInputDispatcherClient API
-    virtual void willDispatchInput(const EventLoopInputBase&) override;
-    virtual void didDispatchInput(const EventLoopInputBase&) override;
+    virtual void willDispatchInput() override;
+    virtual void didDispatchInput() override;
     virtual void didDispatchFinalInput() override;
 
     void createSegment();
     void completeSegment();
 
     void loadSegmentAtIndex(size_t);
     void unloadSegment(bool suppressNotifications = false);
 
     EventLoopInputDispatcher& dispatcher() const;
 
diff --git a/Source/WebCore/replay/ReplayInputDispatchMethods.cpp b/Source/WebCore/replay/ReplayInputDispatchMethods.cpp
index 9ae501d..4c8d8ae 100644
--- a/Source/WebCore/replay/ReplayInputDispatchMethods.cpp
+++ b/Source/WebCore/replay/ReplayInputDispatchMethods.cpp
@@ -99,21 +99,21 @@ void StopLoadingFrame::dispatch(ReplayController& controller)
     controller.page().userInputBridge().stopLoadingFrame(frame, InputSource::Synthetic);
 }
 
 void TryClosePage::dispatch(ReplayController& controller)
 {
     controller.page().userInputBridge().tryClosePage(InputSource::Synthetic);
 }
 
 void InitializeHistory::dispatch(ReplayController& controller)
 {
-    // return; // HACK
+    return; // HACK
 
     // FIXME: Load the empty document, so that when we prune the back-forward list it
     // is the single remaining entry. <https://webkit.org/b/131989>
     controller.page().backForward().clear();
 
     for (RefPtr<HistoryItem> historyEntry : m_entries)
         controller.page().backForward().addItem(historyEntry->copy());
 
     controller.page().mainFrame().loader().history().setCurrentItem(controller.page().backForward().currentItem());
 }
-- 
2.0.1

