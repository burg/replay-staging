From 1db1a2138877ba87424ff7e51c140a4c1b11c775 Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Wed, 23 Jul 2014 15:03:49 -0700
Subject: [PATCH] Web Inspector: ReplayManager shouldn't assume replay status
 when the inspector is opened https://bugs.webkit.org/show_bug.cgi?id=135212

Reviewed by NOBODY (OOPS!).

Source/WebCore:
The frontend should be able to introspect the session and segment state machines,
currently loaded segment and session identifiers, and replay position.

* inspector/InspectorReplayAgent.cpp:
(WebCore::buildInspectorObjectForSessionState): Added.
(WebCore::buildInspectorObjectForSegmentState): Added.
(WebCore::InspectorReplayAgent::currentReplayState): Added.
* inspector/InspectorReplayAgent.h:
* inspector/protocol/Replay.json: Add currentReplayState query command.
* replay/ReplayController.h: Add some accessors.

Source/WebInspectorUI:
The inspector could be closed and reopened at any point during capturing or replaying.
ReplayManager should query the current state on initialization rather than assuming
that the replay controller is still in its initial state.

ReplayManager's initialization code requires querying the backend for the current replay
state. This could race with replay protocol events that mutate the manager's state before
it is fully initialized, leading to undefined behavior.

To mitigate this, all protocol event handlers (called by ReplayObserver) are wrapped
with a guard that enqueues the callback if initialization is not yet complete. This
queue is implemented via multiple then-chaining of a shared 'initialization' promise
which resolves when initialization completes.

* UserInterface/Controllers/ReplayManager.js:
(WebInspector.ReplayManager.then):
(WebInspector.ReplayManager.catch):
(WebInspector.ReplayManager): Rewrite the initialization code to first query the replay
state, set the initialization flag to true, and then request and update session records.
The sessions must be loaded after querying initial state because ReplayManager.sessionCreated
requires replay state to be initialized.

(WebInspector.ReplayManager.prototype.get sessionState):
(WebInspector.ReplayManager.prototype.get segmentState):
(WebInspector.ReplayManager.prototype.get activeSessionIdentifier):
(WebInspector.ReplayManager.prototype.get activeSegmentIdentifier):
(WebInspector.ReplayManager.prototype.get playbackSpeed):
(WebInspector.ReplayManager.prototype.set playbackSpeed):
(WebInspector.ReplayManager.prototype.get currentPosition): Add assertions to catch uses of
manager state before the manager is fully initialized.

(WebInspector.ReplayManager.prototype.waitUntilInitialized): Added. It returns a shared promise
that is fulfilled when initialization is complete.

(WebInspector.ReplayManager.prototype.captureStarted):
(WebInspector.ReplayManager.prototype.captureStopped):
(WebInspector.ReplayManager.prototype.playbackStarted):
(WebInspector.ReplayManager.prototype.playbackHitPosition):
(WebInspector.ReplayManager.prototype.playbackPaused):
(WebInspector.ReplayManager.prototype.playbackFinished):
(WebInspector.ReplayManager.prototype.sessionModified):
(WebInspector.ReplayManager.prototype.sessionLoaded):
(WebInspector.ReplayManager.prototype.segmentCompleted.set catch):
(WebInspector.ReplayManager.prototype.segmentCompleted):
(WebInspector.ReplayManager.prototype.segmentRemoved.then):
(WebInspector.ReplayManager.prototype.segmentRemoved):
(WebInspector.ReplayManager.prototype.segmentLoaded): Add initialization guards.
---
 Source/WebCore/ChangeLog                           | 18 +++++
 Source/WebCore/inspector/InspectorReplayAgent.cpp  | 31 ++++++++
 Source/WebCore/inspector/InspectorReplayAgent.h    |  1 +
 Source/WebCore/inspector/protocol/Replay.json      | 21 ++++++
 Source/WebCore/replay/ReplayController.h           |  5 ++
 Source/WebInspectorUI/ChangeLog                    | 54 ++++++++++++++
 .../UserInterface/Controllers/ReplayManager.js     | 87 +++++++++++++++++++++-
 7 files changed, 214 insertions(+), 3 deletions(-)

diff --git a/Source/WebCore/ChangeLog b/Source/WebCore/ChangeLog
index 588da57..e473f00 100644
--- a/Source/WebCore/ChangeLog
+++ b/Source/WebCore/ChangeLog
@@ -1,10 +1,28 @@
+2014-07-23  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Inspector: ReplayManager shouldn't assume replay status when the inspector is opened
+        https://bugs.webkit.org/show_bug.cgi?id=135212
+
+        Reviewed by NOBODY (OOPS!).
+
+        The frontend should be able to introspect the session and segment state machines,
+        currently loaded segment and session identifiers, and replay position.
+
+        * inspector/InspectorReplayAgent.cpp:
+        (WebCore::buildInspectorObjectForSessionState): Added.
+        (WebCore::buildInspectorObjectForSegmentState): Added.
+        (WebCore::InspectorReplayAgent::currentReplayState): Added.
+        * inspector/InspectorReplayAgent.h:
+        * inspector/protocol/Replay.json: Add currentReplayState query command.
+        * replay/ReplayController.h: Add some accessors.
+
 2014-07-22  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Replay: Rename protocol methods for obtaining session/segment data.
         Need the bug URL (OOPS!).
 
         Reviewed by NOBODY (OOPS!).
 
         * inspector/InspectorReplayAgent.cpp:
         (WebCore::InspectorReplayAgent::getSessionData):
         (WebCore::InspectorReplayAgent::getSegmentData):
diff --git a/Source/WebCore/inspector/InspectorReplayAgent.cpp b/Source/WebCore/inspector/InspectorReplayAgent.cpp
index d988a8d..f937bf2 100644
--- a/Source/WebCore/inspector/InspectorReplayAgent.cpp
+++ b/Source/WebCore/inspector/InspectorReplayAgent.cpp
@@ -86,20 +86,39 @@ static PassRefPtr<TypeBuilder::Replay::ReplaySession> buildInspectorObjectForSes
         segments->addItem((*it)->identifier());
 
     RefPtr<TypeBuilder::Replay::ReplaySession> sessionObject = TypeBuilder::Replay::ReplaySession::create()
         .setId(session->identifier())
         .setTimestamp(session->timestamp())
         .setSegments(segments.release());
 
     return sessionObject.release();
 }
 
+static Inspector::TypeBuilder::Replay::SessionState::Enum buildInspectorObjectForSessionState(SessionState sessionState)
+{
+    switch (sessionState) {
+    case SessionState::Capturing: return Inspector::TypeBuilder::Replay::SessionState::Capturing;
+    case SessionState::Inactive: return Inspector::TypeBuilder::Replay::SessionState::Inactive;
+    case SessionState::Replaying: return Inspector::TypeBuilder::Replay::SessionState::Replaying;
+    }
+}
+
+static Inspector::TypeBuilder::Replay::SegmentState::Enum buildInspectorObjectForSegmentState(SegmentState segmentState)
+{
+    switch (segmentState) {
+    case SegmentState::Appending: return Inspector::TypeBuilder::Replay::SegmentState::Appending;
+    case SegmentState::Unloaded: return Inspector::TypeBuilder::Replay::SegmentState::Unloaded;
+    case SegmentState::Loaded: return Inspector::TypeBuilder::Replay::SegmentState::Loaded;
+    case SegmentState::Dispatching: return Inspector::TypeBuilder::Replay::SegmentState::Dispatching;
+    }
+}
+
 class SerializeInputToJSONFunctor {
 public:
     typedef PassRefPtr<TypeBuilder::Array<TypeBuilder::Replay::ReplayInput>> ReturnType;
 
     SerializeInputToJSONFunctor()
         : m_inputs(TypeBuilder::Array<TypeBuilder::Replay::ReplayInput>::create()) { }
     ~SerializeInputToJSONFunctor() { }
 
     void operator()(size_t index, const NondeterministicInputBase* input)
     {
@@ -457,20 +476,32 @@ PassRefPtr<ReplaySessionSegment> InspectorReplayAgent::findSegment(ErrorString*
 
     auto it = m_segmentsMap.find(identifier);
     if (it == m_segmentsMap.end()) {
         *errorString = ASCIILiteral("Couldn't find segment with specified identifier");
         return nullptr;
     }
 
     return it->value;
 }
 
+void InspectorReplayAgent::currentReplayState(ErrorString*, SessionIdentifier* sessionIdentifier, Inspector::TypeBuilder::OptOutput<int>* segmentIdentifier, Inspector::TypeBuilder::Replay::SessionState::Enum* sessionState, Inspector::TypeBuilder::Replay::SegmentState::Enum* segmentState, RefPtr<Inspector::TypeBuilder::Replay::ReplayPosition>& replayPosition)
+{
+    *sessionState = buildInspectorObjectForSessionState(m_page.replayController().sessionState());
+    *segmentState = buildInspectorObjectForSegmentState(m_page.replayController().segmentState());
+
+    *sessionIdentifier = m_page.replayController().loadedSession()->identifier();
+    if (m_page.replayController().loadedSegment())
+        *segmentIdentifier = m_page.replayController().loadedSegment()->identifier();
+
+    replayPosition = buildInspectorObjectForPosition(m_page.replayController().currentPosition());
+}
+
 void InspectorReplayAgent::getAvailableSessions(ErrorString*, RefPtr<Inspector::TypeBuilder::Array<SessionIdentifier>>& sessionsList)
 {
     sessionsList = TypeBuilder::Array<SessionIdentifier>::create();
     for (auto& pair : m_sessionsMap)
         sessionsList->addItem(pair.key);
 }
 
 void InspectorReplayAgent::getSessionData(ErrorString* errorString, SessionIdentifier identifier, RefPtr<Inspector::TypeBuilder::Replay::ReplaySession>& serializedObject)
 {
     RefPtr<ReplaySession> session = findSession(errorString, identifier);
diff --git a/Source/WebCore/inspector/InspectorReplayAgent.h b/Source/WebCore/inspector/InspectorReplayAgent.h
index f57ad54..69c14b6 100644
--- a/Source/WebCore/inspector/InspectorReplayAgent.h
+++ b/Source/WebCore/inspector/InspectorReplayAgent.h
@@ -97,20 +97,21 @@ public:
 
     virtual void replayToPosition(ErrorString*, const RefPtr<Inspector::InspectorObject>&, bool shouldFastForward) override;
     virtual void replayToCompletion(ErrorString*, bool shouldFastForward) override;
     virtual void pausePlayback(ErrorString*) override;
     virtual void cancelPlayback(ErrorString*) override;
 
     virtual void switchSession(ErrorString*, SessionIdentifier) override;
     virtual void insertSessionSegment(ErrorString*, SessionIdentifier, SegmentIdentifier, int segmentIndex) override;
     virtual void removeSessionSegment(ErrorString*, SessionIdentifier, int segmentIndex) override;
 
+    virtual void currentReplayState(ErrorString*, SessionIdentifier*, Inspector::TypeBuilder::OptOutput<int>* segmentIdentifier, Inspector::TypeBuilder::Replay::SessionState::Enum* sessionState, Inspector::TypeBuilder::Replay::SegmentState::Enum* segmentState, RefPtr<Inspector::TypeBuilder::Replay::ReplayPosition>&) override;
     virtual void getAvailableSessions(ErrorString*, RefPtr<Inspector::TypeBuilder::Array<SessionIdentifier>>&) override;
     virtual void getSessionData(ErrorString*, SessionIdentifier, RefPtr<Inspector::TypeBuilder::Replay::ReplaySession>&) override;
     virtual void getSegmentData(ErrorString*, SegmentIdentifier, RefPtr<Inspector::TypeBuilder::Replay::SessionSegment>&) override;
 
 private:
     PassRefPtr<ReplaySession> findSession(ErrorString*, SessionIdentifier);
     PassRefPtr<ReplaySessionSegment> findSegment(ErrorString*, SegmentIdentifier);
     SessionState sessionState() const;
 
     std::unique_ptr<Inspector::InspectorReplayFrontendDispatcher> m_frontendDispatcher;
diff --git a/Source/WebCore/inspector/protocol/Replay.json b/Source/WebCore/inspector/protocol/Replay.json
index 9fb3f3c..6a77726 100644
--- a/Source/WebCore/inspector/protocol/Replay.json
+++ b/Source/WebCore/inspector/protocol/Replay.json
@@ -4,20 +4,30 @@
     "types": [
         {
             "id": "SessionIdentifier", "description": "Unique replay session identifier.",
             "type": "integer"
         },
         {
             "id": "SegmentIdentifier", "description": "Unique session segment identifier.",
             "type": "integer"
         },
         {
+            "id": "SessionState", "description": "State machine's state for the session.",
+            "type": "string",
+            "enum": ["Capturing", "Inactive", "Replaying"]
+        },
+        {
+            "id": "SegmentState", "description": "State machine's state for the session segment.",
+            "type": "string",
+            "enum": ["Appending", "Unloaded", "Loaded", "Dispatching"]
+        },
+        {
             "id": "ReplayPosition",
             "type": "object",
             "properties": [
                { "name": "segmentOffset", "type": "integer", "description": "Offset for a segment within the currently-loaded replay session." },
                { "name": "inputOffset", "type": "integer", "description": "Offset for an event loop input within the specified session segment." }
             ]
         },
         {
             "id": "ReplayInput",
             "type": "object",
@@ -105,20 +115,31 @@
         },
         {
             "name": "removeSessionSegment",
             "description": "Removes the session segment at the specified position from the session.",
             "parameters": [
                 { "name": "sessionIdentifier", "$ref": "SessionIdentifier" },
                 { "name": "segmentIndex", "type": "integer" }
             ]
         },
         {
+            "name": "currentReplayState",
+            "description": "Returns the identifier, position, session state and segment state of the currently loaded session. This is necessary because the inspector may be closed and reopened in the middle of replay.",
+            "returns": [
+                { "name": "sessionIdentifier", "$ref": "SessionIdentifier" },
+                { "name": "segmentIdentifier", "$ref": "SegmentIdentifier", "optional": true, "description": "If no segment is currently loaded, then there is no valid segment identifier." },
+                { "name": "sessionState", "$ref": "SessionState" },
+                { "name": "segmentState", "$ref": "SegmentState" },
+                { "name": "replayPosition", "$ref": "ReplayPosition" }
+            ]
+        },
+        {
             "name": "getAvailableSessions",
             "description": "Returns identifiers of all available sessions.",
             "returns": [
                 { "name": "ids", "type": "array", "items": { "$ref": "SessionIdentifier" } }
             ]
         },
         {
             "name": "getSessionData",
             "description": "Returns an object for the specified session.",
             "parameters": [
diff --git a/Source/WebCore/replay/ReplayController.h b/Source/WebCore/replay/ReplayController.h
index 77eaaf7..70a60d8 100644
--- a/Source/WebCore/replay/ReplayController.h
+++ b/Source/WebCore/replay/ReplayController.h
@@ -129,24 +129,29 @@ public:
     }
 
     void switchSession(PassRefPtr<ReplaySession>);
 
     // InspectorReplayAgent notifications.
     void frameNavigated(DocumentLoader*);
     void frameDetached(Frame*);
     void willDispatchEvent(const Event&, Frame*);
 
     Page& page() const { return m_page; }
+
     SessionState sessionState() const { return m_sessionState; }
+    SegmentState segmentState() const { return m_segmentState; }
+
     PassRefPtr<ReplaySession> loadedSession() const;
     PassRefPtr<ReplaySessionSegment> loadedSegment() const;
+
     JSC::InputCursor& activeInputCursor() const;
+    ReplayPosition currentPosition() const { return m_currentPosition; }
 
 private:
     // EventLoopInputDispatcherClient API
     virtual void willDispatchInput(const EventLoopInputBase&) override;
     virtual void didDispatchInput(const EventLoopInputBase&) override;
     virtual void didDispatchFinalInput() override;
 
     void createSegment();
     void completeSegment();
 
diff --git a/Source/WebInspectorUI/ChangeLog b/Source/WebInspectorUI/ChangeLog
index 7f02730..041fee4 100644
--- a/Source/WebInspectorUI/ChangeLog
+++ b/Source/WebInspectorUI/ChangeLog
@@ -1,10 +1,64 @@
+2014-07-23  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Inspector: ReplayManager shouldn't assume replay status when the inspector is opened
+        https://bugs.webkit.org/show_bug.cgi?id=135212
+
+        Reviewed by NOBODY (OOPS!).
+
+        The inspector could be closed and reopened at any point during capturing or replaying.
+        ReplayManager should query the current state on initialization rather than assuming
+        that the replay controller is still in its initial state.
+
+        ReplayManager's initialization code requires querying the backend for the current replay
+        state. This could race with replay protocol events that mutate the manager's state before
+        it is fully initialized, leading to undefined behavior.
+
+        To mitigate this, all protocol event handlers (called by ReplayObserver) are wrapped
+        with a guard that enqueues the callback if initialization is not yet complete. This
+        queue is implemented via multiple then-chaining of a shared 'initialization' promise
+        which resolves when initialization completes.
+
+        * UserInterface/Controllers/ReplayManager.js:
+        (WebInspector.ReplayManager.then):
+        (WebInspector.ReplayManager.catch):
+        (WebInspector.ReplayManager): Rewrite the initialization code to first query the replay
+        state, set the initialization flag to true, and then request and update session records.
+        The sessions must be loaded after querying initial state because ReplayManager.sessionCreated
+        requires replay state to be initialized.
+
+        (WebInspector.ReplayManager.prototype.get sessionState):
+        (WebInspector.ReplayManager.prototype.get segmentState):
+        (WebInspector.ReplayManager.prototype.get activeSessionIdentifier):
+        (WebInspector.ReplayManager.prototype.get activeSegmentIdentifier):
+        (WebInspector.ReplayManager.prototype.get playbackSpeed):
+        (WebInspector.ReplayManager.prototype.set playbackSpeed):
+        (WebInspector.ReplayManager.prototype.get currentPosition): Add assertions to catch uses of
+        manager state before the manager is fully initialized.
+
+        (WebInspector.ReplayManager.prototype.waitUntilInitialized): Added. It returns a shared promise
+        that is fulfilled when initialization is complete.
+
+        (WebInspector.ReplayManager.prototype.captureStarted):
+        (WebInspector.ReplayManager.prototype.captureStopped):
+        (WebInspector.ReplayManager.prototype.playbackStarted):
+        (WebInspector.ReplayManager.prototype.playbackHitPosition):
+        (WebInspector.ReplayManager.prototype.playbackPaused):
+        (WebInspector.ReplayManager.prototype.playbackFinished):
+        (WebInspector.ReplayManager.prototype.sessionModified):
+        (WebInspector.ReplayManager.prototype.sessionLoaded):
+        (WebInspector.ReplayManager.prototype.segmentCompleted.set catch):
+        (WebInspector.ReplayManager.prototype.segmentCompleted):
+        (WebInspector.ReplayManager.prototype.segmentRemoved.then):
+        (WebInspector.ReplayManager.prototype.segmentRemoved):
+        (WebInspector.ReplayManager.prototype.segmentLoaded): Add initialization guards.
+
 2014-07-22  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Replay: Rename protocol methods for obtaining session/segment data.
         Need the bug URL (OOPS!).
 
         Reviewed by NOBODY (OOPS!).
 
         * UserInterface/Controllers/ReplayManager.js:
         (WebInspector.ReplayManager.prototype.getSession.get var):
         (WebInspector.ReplayManager.prototype.getSegment.get var):
diff --git a/Source/WebInspectorUI/UserInterface/Controllers/ReplayManager.js b/Source/WebInspectorUI/UserInterface/Controllers/ReplayManager.js
index 7154f60..35edbfc 100644
--- a/Source/WebInspectorUI/UserInterface/Controllers/ReplayManager.js
+++ b/Source/WebInspectorUI/UserInterface/Controllers/ReplayManager.js
@@ -27,39 +27,60 @@
 WebInspector.ReplayManager = function()
 {
     WebInspector.Object.call(this);
 
     this._sessionState = WebInspector.ReplayManager.SessionState.Inactive;
     this._segmentState = WebInspector.ReplayManager.SegmentState.Unloaded;
 
     this._activeSessionIdentifier = null;
     this._activeSegmentIdentifier = null;
     this._currentPosition = new WebInspector.ReplayPosition(0, 0);
+    this._initialized = false;
 
     // These hold actual instances of sessions and segments.
     this._sessions = new Map;
     this._segments = new Map;
     // These hold promises that resolve when the instance data is recieved.
     this._sessionPromises = new Map;
     this._segmentPromises = new Map;
 
     // Playback speed is specified in replayToPosition commands, and persists
     // for the duration of the playback command until another playback begins.
     this._playbackSpeed = WebInspector.ReplayManager.PlaybackSpeed.RealTime;
 
     if (!window.ReplayAgent)
         return;
 
-    ReplayAgent.getAvailableSessions.promise()
+    var instance = this;
+
+    this._initializationPromise = ReplayAgent.currentReplayState.promise()
+        .then(function(payload) {
+            console.assert(payload.sessionState in WebInspector.ReplayManager.SessionState, "Unknown session state: " + payload.sessionState);
+            console.assert(payload.segmentState in WebInspector.ReplayManager.SegmentState, "Unknown segment state: " + payload.segmentState);
+
+            instance._activeSessionIdentifier = payload.sessionIdentifier;
+            instance._activeSegmentIdentifier = payload.segmentIdentifier;
+            instance._sessionState = WebInspector.ReplayManager.SessionState[payload.sessionState];
+            instance._segmentState = WebInspector.ReplayManager.SegmentState[payload.segmentState];
+            instance._currentPosition = payload.replayPosition;
+
+            instance._initialized = true;
+        })
+        .then(function() {
+            return ReplayAgent.getAvailableSessions.promise();
+        })
         .then(function(payload) {
             for (var sessionId of payload.ids)
-                WebInspector.replayManager.sessionCreated(sessionId);
+                instance.sessionCreated(sessionId);
+        })
+        .catch(function(err) {
+            console.error("ReplayManager initialization failed: ", err);
         });
 };
 
 WebInspector.ReplayManager.Event = {
     CaptureStarted: "replay-manager-capture-started",
     CaptureStopped: "replay-manager-capture-stopped",
 
     PlaybackStarted: "replay-manager-playback-started",
     PlaybackPaused: "replay-manager-playback-paused",
     PlaybackFinished: "replay-manager-playback-finished",
@@ -92,56 +113,70 @@ WebInspector.ReplayManager.PlaybackSpeed = {
     RealTime: "replay-manager-playback-speed-real-time",
     FastForward: "replay-manager-playback-speed-fast-forward",
 };
 
 WebInspector.ReplayManager.prototype = {
     constructor: WebInspector.ReplayManager,
     __proto__: WebInspector.Object.prototype,
 
     // Public
 
+    // The following state is invalid unless called from a function that's chained
+    // to the (resolved) ReplayManager.waitUntilInitialized promise.
     get sessionState()
     {
+        console.assert(this._initialized);
         return this._sessionState;
     },
 
     get segmentState()
     {
+        console.assert(this._initialized);
         return this._segmentState;
     },
 
     get activeSessionIdentifier()
     {
+        console.assert(this._initialized);
         return this._activeSessionIdentifier;
     },
 
     get activeSegmentIdentifier()
     {
+        console.assert(this._initialized);
         return this._activeSegmentIdentifier;
     },
 
     get playbackSpeed()
     {
+        console.assert(this._initialized);
         return this._playbackSpeed;
     },
 
     set playbackSpeed(value)
     {
+        console.assert(this._initialized);
         this._playbackSpeed = value;
     },
 
     get currentPosition()
     {
+        console.assert(this._initialized);
         return this._currentPosition;
     },
 
     // These return promises even if the relevant instance is already created.
+    waitUntilInitialized: function()
+    {
+        return this._initializationPromise;
+    },
+
     getSession: function(sessionId)
     {
         if (this._sessionPromises.has(sessionId))
             return this._sessionPromises.get(sessionId);
 
         var newPromise = ReplayAgent.getSessionData.promise(sessionId)
             .then(function(payload) {
                 return Promise.resolve(WebInspector.ReplaySession.fromPayload(sessionId, payload));
             });
 
@@ -158,95 +193,126 @@ WebInspector.ReplayManager.prototype = {
             .then(function(payload) {
                 return Promise.resolve(new WebInspector.ReplaySessionSegment(segmentId, payload));
             });
 
         this._segmentPromises.set(segmentId, newPromise);
         return newPromise;
     },
 
     // Protected (called by ReplayObserver)
 
+    // Since these methods update session and segment state, they depend on the manager
+    // being properly initialized. So, each function body is prepended with a retry guard.
+    // This makes call sites simpler and avoids an extra event loop turn in the common case.
+
     captureStarted: function()
     {
+        if (!this._initialized)
+            return this.waitUntilInitialized().then(this.captureStarted.bind(this));
+
         this._changeSessionState(WebInspector.ReplayManager.SessionState.Capturing);
 
         this.dispatchEventToListeners(WebInspector.ReplayManager.Event.CaptureStarted);
     },
 
     captureStopped: function()
     {
+        if (!this._initialized)
+            return this.waitUntilInitialized().then(this.captureStopped.bind(this));
+
         this._changeSessionState(WebInspector.ReplayManager.SessionState.Inactive);
         this._changeSegmentState(WebInspector.ReplayManager.SegmentState.Unloaded);
 
         this.dispatchEventToListeners(WebInspector.ReplayManager.Event.CaptureStopped);
     },
 
     playbackStarted: function()
     {
+        if (!this._initialized)
+            return this.waitUntilInitialized().then(this.playbackStarted.bind(this));
+
         if (this.sessionState === WebInspector.ReplayManager.SessionState.Inactive)
             this._changeSessionState(WebInspector.ReplayManager.SessionState.Replaying);
 
         this._changeSegmentState(WebInspector.ReplayManager.SegmentState.Dispatching);
 
         this.dispatchEventToListeners(WebInspector.ReplayManager.Event.PlaybackStarted);
     },
 
     playbackHitPosition: function(replayPosition, timestamp)
     {
+        if (!this._initialized)
+            return this.waitUntilInitialized().then(this.playbackHitPosition.bind(this, replayPosition, timestamp));
+
         console.assert(this.sessionState === WebInspector.ReplayManager.SessionState.Replaying);
         console.assert(this.segmentState === WebInspector.ReplayManager.SegmentState.Dispatching);
         console.assert(replayPosition instanceof WebInspector.ReplayPosition);
 
         this._currentPosition = replayPosition;
         this.dispatchEventToListeners(WebInspector.ReplayManager.Event.PlaybackPositionChanged);
     },
 
-    playbackPaused: function(mark)
+    playbackPaused: function(position)
     {
+        if (!this._initialized)
+            return this.waitUntilInitialized().then(this.playbackPaused.bind(this, position));
+
         console.assert(this.sessionState === WebInspector.ReplayManager.SessionState.Replaying);
         this._changeSegmentState(WebInspector.ReplayManager.SegmentState.Loaded);
 
         this.dispatchEventToListeners(WebInspector.ReplayManager.Event.PlaybackPaused);
     },
 
     playbackFinished: function()
     {
+        if (!this._initialized)
+            return this.waitUntilInitialized().then(this.playbackFinished.bind(this));
+
         this._changeSessionState(WebInspector.ReplayManager.SessionState.Inactive);
         console.assert(this.segmentState === WebInspector.ReplayManager.SegmentState.Unloaded);
 
         this.dispatchEventToListeners(WebInspector.ReplayManager.Event.PlaybackFinished);
     },
 
     sessionCreated: function(sessionId)
     {
+        if (!this._initialized)
+            return this.waitUntilInitialized().then(this.sessionCreated.bind(this, sessionId));
+
         console.assert(!this._sessions.has(sessionId), "Tried to add duplicate session identifier:", sessionId);
         var sessionMap = this._sessions;
         this.getSession(sessionId)
             .then(function(session) {
                 sessionMap.set(sessionId, session);
             })
             .catch(function(error) {
                 console.error("Error obtaining session data: ", error);
             });
 
         this.dispatchEventToListeners(WebInspector.ReplayManager.Event.SessionAdded, {sessionId: sessionId});
     },
 
     sessionModified: function(sessionId)
     {
+        if (!this._initialized)
+            return this.waitUntilInitialized().then(this.sessionModified.bind(this, sessionId));
+
         this.getSession(sessionId).then(function(session) {
             session.segmentsChanged();
         });
     },
 
     sessionRemoved: function(sessionId)
     {
+        if (!this._initialized)
+            return this.waitUntilInitialized().then(this.sessionRemoved.bind(this, sessionId));
+
         console.assert(this._sessions.has(sessionId), "Unknown session identifier:", sessionId);
 
         if (!this._sessionPromises.has(sessionId))
             return;
 
         var manager = this;
 
         // Wait for any outstanding promise to settle so it doesn't get re-added.
         this.getSession(sessionId)
             .catch(function(error) {
@@ -255,51 +321,60 @@ WebInspector.ReplayManager.prototype = {
             .then(function() {
                 manager._sessionPromises.delete(sessionId);
                 var removedSession = manager._sessions.take(sessionId);
                 console.assert(removedSession);
                 manager.dispatchEventToListeners(WebInspector.ReplayManager.Event.SessionRemoved, {removedSession: removedSession});
             });
     },
 
     segmentCreated: function(segmentId)
     {
+        if (!this._initialized)
+            return this.waitUntilInitialized().then(this.segmentCreated.bind(this, segmentId));
+
         console.assert(!this._segments.has(segmentId), "Tried to add duplicate segment identifier:", segmentId);
 
         this._changeSegmentState(WebInspector.ReplayManager.SegmentState.Appending);
 
         // Create a dummy segment, and don't try to load any data for it. It will
         // be removed once the segment is complete, and then its data will be fetched.
         var incompleteSegment = new WebInspector.IncompleteSessionSegment(segmentId);
         this._segments.set(segmentId, incompleteSegment);
         this._segmentPromises.set(segmentId, Promise.resolve(incompleteSegment));
 
         this.dispatchEventToListeners(WebInspector.ReplayManager.Event.SessionSegmentAdded, {segmentIdentifier: segmentId});
     },
 
     segmentCompleted: function(segmentId)
     {
+        if (!this._initialized)
+            return this.waitUntilInitialized().then(this.segmentCompleted.bind(this, segmentId));
+
         var placeholderSegment = this._segments.take(segmentId);
         console.assert(placeholderSegment instanceof WebInspector.IncompleteSessionSegment);
         this._segmentPromises.delete(segmentId);
 
         var segmentMap = this._segments;
         this.getSegment(segmentId)
             .then(function(segment) {
                 segmentMap.set(segmentId, segment);
             })
             .catch(function(error) {
                 console.error("Error obtaining segment data: ", error);
             });
     },
 
     segmentRemoved: function(segmentId)
     {
+        if (!this._initialized)
+            return this.waitUntilInitialized().then(this.segmentRemoved.bind(this, segmentId));
+
         console.assert(this._segments.has(segmentId), "Unknown segment identifier:", segmentId);
 
         if (!this._segmentPromises.has(segmentId))
             return;
 
         var manager = this;
 
         // Wait for any outstanding promise to settle so it doesn't get re-added.
         this.getSegment(segmentId)
             .catch(function(error) {
@@ -308,32 +383,38 @@ WebInspector.ReplayManager.prototype = {
             .then(function() {
                 manager._segmentPromises.delete(segmentId);
                 var removedSegment = manager._segments.take(segmentId);
                 console.assert(removedSegment);
                 manager.dispatchEventToListeners(WebInspector.ReplayManager.Event.SessionSegmentRemoved, {removedSegment: removedSegment});
             });
     },
 
     segmentLoaded: function(segmentId)
     {
+        if (!this._initialized)
+            return this.waitUntilInitialized().then(this.segmentLoaded.bind(this, segmentId));
+
         console.assert(this._segments.has(segmentId), "Unknown segment identifier:", segmentId);
 
         console.assert(this.sessionState !== WebInspector.ReplayManager.SessionState.Capturing);
         this._changeSegmentState(WebInspector.ReplayManager.SegmentState.Loaded);
 
         var previousIdentifier = this._activeSegmentIdentifier;
         this._activeSegmentIdentifier = segmentId;
         this.dispatchEventToListeners(WebInspector.ReplayManager.Event.ActiveSegmentChanged, {previousSegmentIdentifier: previousIdentifier});
    },
 
     segmentUnloaded: function()
     {
+        if (!this._initialized)
+            return this.waitUntilInitialized().then(this.segmentUnloaded.bind(this));
+
         console.assert(this.sessionState === WebInspector.ReplayManager.SessionState.Replaying);
         this._changeSegmentState(WebInspector.ReplayManager.SegmentState.Unloaded);
 
         var previousIdentifier = this._activeSegmentIdentifier;
         this._activeSegmentIdentifier = null;
         this.dispatchEventToListeners(WebInspector.ReplayManager.Event.ActiveSegmentChanged, {previousSegmentIdentifier: previousIdentifier});
     },
 
     // Private
 
-- 
2.0.1

