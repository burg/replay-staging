From 90bd61cf05cffddfeae5be5771e7cba7711cb5fd Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Fri, 9 Jan 2015 21:37:11 -0800
Subject: [PATCH] CLEANUP move to RefPtr&&/Ref in InputCursor, get rid of
 AtomicString type().

---
 Source/JavaScriptCore/replay/EmptyInputCursor.h |  6 +++---
 Source/JavaScriptCore/replay/InputCursor.h      | 11 +++--------
 Source/WebCore/replay/CapturingInputCursor.cpp  |  2 +-
 Source/WebCore/replay/CapturingInputCursor.h    |  2 +-
 Source/WebCore/replay/FunctorInputCursor.h      | 14 +++++++-------
 Source/WebCore/replay/ReplayingInputCursor.cpp  |  2 +-
 6 files changed, 16 insertions(+), 21 deletions(-)

diff --git a/Source/JavaScriptCore/replay/EmptyInputCursor.h b/Source/JavaScriptCore/replay/EmptyInputCursor.h
index f2a9a40..a38aee2 100644
--- a/Source/JavaScriptCore/replay/EmptyInputCursor.h
+++ b/Source/JavaScriptCore/replay/EmptyInputCursor.h
@@ -33,41 +33,41 @@
 #include <wtf/Assertions.h>
 #include <wtf/Noncopyable.h>
 
 namespace JSC {
 
 class EmptyInputCursor final : public InputCursor {
     WTF_MAKE_NONCOPYABLE(EmptyInputCursor);
 public:
     virtual ~EmptyInputCursor() { }
 
-    static PassRefPtr<EmptyInputCursor> create()
+    static Ref<EmptyInputCursor> create()
     {
-        return adoptRef(new EmptyInputCursor());
+        return adoptRef(*new EmptyInputCursor());
     }
 
     virtual bool isCapturing() const override { return false; }
     virtual bool isReplaying() const override { return false; }
 
     virtual NondeterministicInputBase* uncheckedLoadInput(InputQueue) override
     {
         ASSERT_NOT_REACHED();
         return nullptr;
     }
 
     virtual void storeInput(std::unique_ptr<NondeterministicInputBase>) override
     {
         ASSERT_NOT_REACHED();
     }
 
 protected:
-    virtual NondeterministicInputBase* loadInput(InputQueue, const AtomicString&) override
+    virtual NondeterministicInputBase* loadInput(InputQueue, const String&) override
     {
         ASSERT_NOT_REACHED();
         return nullptr;
     }
 
 private:
     EmptyInputCursor() { }
 };
 
 } // namespace JSC
diff --git a/Source/JavaScriptCore/replay/InputCursor.h b/Source/JavaScriptCore/replay/InputCursor.h
index 5c2a85e..ca3cf2f 100644
--- a/Source/JavaScriptCore/replay/InputCursor.h
+++ b/Source/JavaScriptCore/replay/InputCursor.h
@@ -26,32 +26,27 @@
  */
 
 #ifndef InputCursor_h
 #define InputCursor_h
 
 #if ENABLE(WEB_REPLAY)
 
 #include "NondeterministicInput.h"
 #include <wtf/Noncopyable.h>
 #include <wtf/RefCounted.h>
-#include <wtf/text/AtomicString.h>
 
 namespace JSC {
 
 class InputCursor : public RefCounted<InputCursor> {
     WTF_MAKE_NONCOPYABLE(InputCursor);
 public:
-    InputCursor()
-        : m_withinEventLoopInputExtent(false)
-    {
-    }
-
+    InputCursor() { }
     virtual ~InputCursor() { }
 
     virtual bool isCapturing() const = 0;
     virtual bool isReplaying() const = 0;
 
     void setWithinEventLoopInputExtent(bool withinEventLoopInputExtent)
     {
         // We can be within two input extents when a nested run loop
         // processes additional user inputs while the debugger is paused.
         // However, the debugger should not pause when capturing, and we
@@ -71,23 +66,23 @@ public:
 
     template <class InputType> inline
     InputType* fetchInput()
     {
         return static_cast<InputType*>(loadInput(InputTraits<InputType>::queue(), InputTraits<InputType>::type()));
     }
 
     virtual void storeInput(std::unique_ptr<NondeterministicInputBase>) = 0;
     virtual NondeterministicInputBase* uncheckedLoadInput(InputQueue) = 0;
 protected:
-    virtual NondeterministicInputBase* loadInput(InputQueue, const AtomicString&) = 0;
+    virtual NondeterministicInputBase* loadInput(InputQueue, const String&) = 0;
 
 private:
-    bool m_withinEventLoopInputExtent;
+    bool m_withinEventLoopInputExtent = {false};
 };
 
 } // namespace JSC
 
 using JSC::InputCursor;
 
 #endif // ENABLE(WEB_REPLAY)
 
 #endif // InputCursor_h
diff --git a/Source/WebCore/replay/CapturingInputCursor.cpp b/Source/WebCore/replay/CapturingInputCursor.cpp
index 885df58..c818074 100644
--- a/Source/WebCore/replay/CapturingInputCursor.cpp
+++ b/Source/WebCore/replay/CapturingInputCursor.cpp
@@ -60,21 +60,21 @@ void CapturingInputCursor::storeInput(std::unique_ptr<NondeterministicInputBase>
 
     if (input->queue() == InputQueue::EventLoopInput) {
         // FIXME: rewrite this (and related dispatch code) to use std::chrono.
         double now = monotonicallyIncreasingTime();
         m_segment->eventLoopTimings().append(now);
     }
 
     m_segment->storage().store(WTF::move(input));
 }
 
-NondeterministicInputBase* CapturingInputCursor::loadInput(InputQueue, const AtomicString&)
+NondeterministicInputBase* CapturingInputCursor::loadInput(InputQueue, const String&)
 {
     // Can't load inputs from capturing cursor.
     ASSERT_NOT_REACHED();
     return nullptr;
 }
 
 NondeterministicInputBase* CapturingInputCursor::uncheckedLoadInput(InputQueue)
 {
     // Can't load inputs from capturing cursor.
     ASSERT_NOT_REACHED();
diff --git a/Source/WebCore/replay/CapturingInputCursor.h b/Source/WebCore/replay/CapturingInputCursor.h
index 08017ab..851a889 100644
--- a/Source/WebCore/replay/CapturingInputCursor.h
+++ b/Source/WebCore/replay/CapturingInputCursor.h
@@ -42,21 +42,21 @@ class ReplaySessionSegment;
 class CapturingInputCursor final : public InputCursor {
     WTF_MAKE_NONCOPYABLE(CapturingInputCursor);
 public:
     static Ref<CapturingInputCursor> create(PassRefPtr<ReplaySessionSegment>);
     virtual ~CapturingInputCursor();
 
     virtual bool isCapturing() const override { return true; }
     virtual bool isReplaying() const override { return false; }
 
 protected:
-    virtual NondeterministicInputBase* loadInput(InputQueue, const AtomicString& type) override;
+    virtual NondeterministicInputBase* loadInput(InputQueue, const String& type) override;
 
 private:
     CapturingInputCursor(PassRefPtr<ReplaySessionSegment>);
 
     virtual NondeterministicInputBase* uncheckedLoadInput(InputQueue) override;
     virtual void storeInput(std::unique_ptr<NondeterministicInputBase>) override;
 
     RefPtr<ReplaySessionSegment> m_segment;
 };
 
diff --git a/Source/WebCore/replay/FunctorInputCursor.h b/Source/WebCore/replay/FunctorInputCursor.h
index c8df903..aff46e5 100644
--- a/Source/WebCore/replay/FunctorInputCursor.h
+++ b/Source/WebCore/replay/FunctorInputCursor.h
@@ -36,62 +36,62 @@
 #include <replay/NondeterministicInput.h>
 #include <wtf/Assertions.h>
 #include <wtf/Noncopyable.h>
 #include <wtf/Vector.h>
 
 namespace WebCore {
 
 class FunctorInputCursor final : public InputCursor {
     WTF_MAKE_NONCOPYABLE(FunctorInputCursor);
 public:
-    static PassRefPtr<FunctorInputCursor> create(PassRefPtr<ReplaySessionSegment> segment)
+    static Ref<FunctorInputCursor> create(RefPtr<ReplaySessionSegment>&& segment)
     {
-        return adoptRef(new FunctorInputCursor(segment));
+        return adoptRef(*new FunctorInputCursor(WTF::move(segment)));
     }
 
     // InputCursor
     virtual bool isCapturing() const override { return false; }
     virtual bool isReplaying() const override { return false; }
 
     virtual void storeInput(std::unique_ptr<NondeterministicInputBase>) override;
     virtual NondeterministicInputBase* uncheckedLoadInput(InputQueue) override;
 
     template<typename Functor>
     typename Functor::ReturnType forEachInputInQueue(InputQueue, Functor&);
 protected:
-    virtual NondeterministicInputBase* loadInput(InputQueue, const AtomicString&) override;
+    virtual NondeterministicInputBase* loadInput(InputQueue, const String&) override;
 private:
-    FunctorInputCursor(PassRefPtr<ReplaySessionSegment>);
+    FunctorInputCursor(RefPtr<ReplaySessionSegment>&&);
 
     RefPtr<ReplaySessionSegment> m_segment;
 };
 
 template<typename Functor> inline
 typename Functor::ReturnType FunctorInputCursor::forEachInputInQueue(InputQueue queue, Functor& functor)
 {
     for (size_t i = 0; i < m_segment->storage().queueSize(queue); i++)
         functor(i, m_segment->storage().queue(queue).at(i).get());
 
     return functor.returnValue();
 }
 
-inline FunctorInputCursor::FunctorInputCursor(PassRefPtr<ReplaySessionSegment> segment)
-    : m_segment(segment)
+inline FunctorInputCursor::FunctorInputCursor(RefPtr<ReplaySessionSegment>&& segment)
+    : m_segment(WTF::move(segment))
 {
 }
 
 inline void FunctorInputCursor::storeInput(std::unique_ptr<NondeterministicInputBase>)
 {
     ASSERT_NOT_REACHED();
 }
 
-inline NondeterministicInputBase* FunctorInputCursor::loadInput(InputQueue, const AtomicString&)
+inline NondeterministicInputBase* FunctorInputCursor::loadInput(InputQueue, const String&)
 {
     ASSERT_NOT_REACHED();
     return nullptr;
 }
 
 inline NondeterministicInputBase* FunctorInputCursor::uncheckedLoadInput(InputQueue)
 {
     ASSERT_NOT_REACHED();
     return nullptr;
 }
diff --git a/Source/WebCore/replay/ReplayingInputCursor.cpp b/Source/WebCore/replay/ReplayingInputCursor.cpp
index 8822ee5..0ba370a 100644
--- a/Source/WebCore/replay/ReplayingInputCursor.cpp
+++ b/Source/WebCore/replay/ReplayingInputCursor.cpp
@@ -60,21 +60,21 @@ void ReplayingInputCursor::storeInput(std::unique_ptr<NondeterministicInputBase>
 {
     // Cannot store inputs from a replaying input cursor.
     ASSERT_NOT_REACHED();
 }
 
 NondeterministicInputBase* ReplayingInputCursor::loadInput(InputQueue queue, const AtomicString& type)
 {
     NondeterministicInputBase* input = uncheckedLoadInput(queue);
 
     if (input->type() != type) {
-        LOG_ERROR("%-25s ERROR: Expected replay input of type %s, but got type %s\n", "[ReplayingInputCursor]", type.string().ascii().data(), input->type().ascii().data());
+        LOG_ERROR("%-25s ERROR: Expected replay input of type %s, but got type %s\n", "[ReplayingInputCursor]", type.ascii().data(), input->type().ascii().data());
         return nullptr;
     }
 
     return input;
 }
 
 NondeterministicInputBase* ReplayingInputCursor::uncheckedLoadInput(InputQueue queue)
 {
     if (m_positions[static_cast<size_t>(queue)] >= m_segment->storage().queueSize(queue)) {
         String queueString = EncodingTraits<InputQueue>::encodeValue(queue).convertTo<String>();
-- 
2.0.1

