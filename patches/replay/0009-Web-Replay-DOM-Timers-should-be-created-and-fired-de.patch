From 8cfeb929865df1c6c474c00737fdab0ecf0b844b Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Wed, 16 Jul 2014 14:58:22 -0700
Subject: [PATCH] Web Replay: DOM Timers should be created and fired
 deterministically Need the bug URL (OOPS!).

Reviewed by NOBODY (OOPS!).

Async mechanisms such as window.setTimeout are nondeterministic because the
interleaving of callbacks and other event loop items (which run JS) is also
nondeterministic.

This patch makes DOMTimer optionally deterministic by using custom subclasses
during capturing and replaying. InstrumentedDOMTimer captures timeoutId when
the timer is created, and also captures the instant when the callback fires
relative to other event loop inputs. DeterministicDOMTimer uses the memoized
timeoutId input, and manually invokes timer callbacks rather than scheduling
them through the normal timer heap.

In order to intercept timer creation and firing with subclasses, DOMTimer was
refactored to poison replay-scheduled timers and split callback setup from
the timer constructor.

WIP NOTE: The memoized timeoutId is only used for debugging purposes.

WIP NOTE: ideally, we would not need to use subclasses, and DOMTimer would inherit
from ReplayableTimer rather than SuspendableTimer. This patch may be rewritten
when ReplayableTimer is able to support SuspendableTimer operations.

WIP NOTE: this functionality needs tests

No new tests (OOPS!).

* page/DOMTimer.cpp:
(WebCore::InstrumentedDOMTimer::~InstrumentedDOMTimer): Added.
(WebCore::InstrumentedDOMTimer::InstrumentedDOMTimer): Added.
(WebCore::InstrumentedDOMTimer::start): Save the timeoutId as a memoized input.
(WebCore::InstrumentedDOMTimer::fired): Save the firing as an event loop input.
(WebCore::DeterministicDOMTimer::~DeterministicDOMTimer): Added.
(WebCore::DeterministicDOMTimer::DeterministicDOMTimer):
(WebCore::DeterministicDOMTimer::start): Use the memoized timeoutId.
(WebCore::DOMTimer::DOMTimer): Split construction from scheduling the timer.
Move the singleShot parameter to DOMTimer::start since it isn't used here now.
(WebCore::DOMTimer::~DOMTimer):
(WebCore::DOMTimer::start): Actually schedule the timer here.
(WebCore::DOMTimer::install): Create instrumented timers during capture/replay.
(WebCore::DOMTimer::fired):

* page/DOMTimer.h: Remove final keyword from class, adjust visibility.
* replay/ReplayInputDispatchMethods.cpp:
(WebCore::DOMTimerFired::dispatch): Added.
* replay/WebInputs.json: Add DOMTimerFired and DOMTimerCreated.
---
 Source/WebCore/ChangeLog                           |  52 +++++++
 Source/WebCore/page/DOMTimer.cpp                   | 157 ++++++++++++++++++---
 Source/WebCore/page/DOMTimer.h                     |  16 ++-
 .../WebCore/replay/ReplayInputDispatchMethods.cpp  |  11 ++
 Source/WebCore/replay/WebInputs.json               |  18 +++
 5 files changed, 233 insertions(+), 21 deletions(-)

diff --git a/Source/WebCore/ChangeLog b/Source/WebCore/ChangeLog
index 62e627f..8e44aee 100644
--- a/Source/WebCore/ChangeLog
+++ b/Source/WebCore/ChangeLog
@@ -1,10 +1,62 @@
+2014-07-16  Brian J. Burg  <burg@cs.washington.edu>
+
+        [WIP] Web Replay: DOM Timers should be created and fired deterministically
+        Need the bug URL (OOPS!).
+
+        Reviewed by NOBODY (OOPS!).
+
+        Async mechanisms such as window.setTimeout are nondeterministic because the
+        interleaving of callbacks and other event loop items (which run JS) is also
+        nondeterministic.
+
+        This patch makes DOMTimer optionally deterministic by using custom subclasses
+        during capturing and replaying. InstrumentedDOMTimer captures timeoutId when
+        the timer is created, and also captures the instant when the callback fires
+        relative to other event loop inputs. DeterministicDOMTimer uses the memoized
+        timeoutId input, and manually invokes timer callbacks rather than scheduling
+        them through the normal timer heap.
+
+        In order to intercept timer creation and firing with subclasses, DOMTimer was
+        refactored to poison replay-scheduled timers and split callback setup from
+        the timer constructor.
+
+        WIP NOTE: The memoized timeoutId is only used for debugging purposes.
+
+        WIP NOTE: ideally, we would not need to use subclasses, and DOMTimer would inherit
+        from ReplayableTimer rather than SuspendableTimer. This patch may be rewritten
+        when ReplayableTimer is able to support SuspendableTimer operations.
+
+        WIP NOTE: this functionality needs tests
+
+        No new tests (OOPS!).
+
+        * page/DOMTimer.cpp:
+        (WebCore::InstrumentedDOMTimer::~InstrumentedDOMTimer): Added.
+        (WebCore::InstrumentedDOMTimer::InstrumentedDOMTimer): Added.
+        (WebCore::InstrumentedDOMTimer::start): Save the timeoutId as a memoized input.
+        (WebCore::InstrumentedDOMTimer::fired): Save the firing as an event loop input.
+        (WebCore::DeterministicDOMTimer::~DeterministicDOMTimer): Added.
+        (WebCore::DeterministicDOMTimer::DeterministicDOMTimer):
+        (WebCore::DeterministicDOMTimer::start): Use the memoized timeoutId.
+        (WebCore::DOMTimer::DOMTimer): Split construction from scheduling the timer.
+        Move the singleShot parameter to DOMTimer::start since it isn't used here now.
+        (WebCore::DOMTimer::~DOMTimer):
+        (WebCore::DOMTimer::start): Actually schedule the timer here.
+        (WebCore::DOMTimer::install): Create instrumented timers during capture/replay.
+        (WebCore::DOMTimer::fired):
+
+        * page/DOMTimer.h: Remove final keyword from class, adjust visibility.
+        * replay/ReplayInputDispatchMethods.cpp:
+        (WebCore::DOMTimerFired::dispatch): Added.
+        * replay/WebInputs.json: Add DOMTimerFired and DOMTimerCreated.
+
 2014-07-15  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Replay: save and restore page history state at main frame navigations
         https://bugs.webkit.org/show_bug.cgi?id=131043
 
         Reviewed by NOBODY (OOPS!).
 
         To make uses of window.history deterministic, we must save and restore
         the contents of the back-forward list at each main frame navigation.
         This can be done before the initial navigation that's kicked off when
diff --git a/Source/WebCore/page/DOMTimer.cpp b/Source/WebCore/page/DOMTimer.cpp
index 0712556..c7f43d5 100644
--- a/Source/WebCore/page/DOMTimer.cpp
+++ b/Source/WebCore/page/DOMTimer.cpp
@@ -36,77 +36,196 @@
 #include <wtf/StdLibExtras.h>
 
 #if PLATFORM(IOS)
 #include "Chrome.h"
 #include "ChromeClient.h"
 #include "Frame.h"
 #include "Page.h"
 #include "WKContentObservation.h"
 #endif
 
+#if ENABLE(WEB_REPLAY)
+#include "CapturingInputCursor.h"
+#include "SerializationMethods.h"
+#include "WebReplayInputs.h"
+#endif
+
 namespace WebCore {
 
 static const int maxIntervalForUserGestureForwarding = 1000; // One second matches Gecko.
 static const int maxTimerNestingLevel = 5;
 static const double oneMillisecond = 0.001;
 
 static int timerNestingLevel = 0;
     
 static inline bool shouldForwardUserGesture(int interval, int nestingLevel)
 {
     return UserGestureIndicator::processingUserGesture()
         && interval <= maxIntervalForUserGestureForwarding
         && nestingLevel == 1; // Gestures should not be forwarded to nested timers.
 }
 
-DOMTimer::DOMTimer(ScriptExecutionContext* context, std::unique_ptr<ScheduledAction> action, int interval, bool singleShot)
+#if ENABLE(WEB_REPLAY)
+class InstrumentedDOMTimer : public DOMTimer {
+public:
+    InstrumentedDOMTimer(ScriptExecutionContext*, std::unique_ptr<ScheduledAction>, int originalInterval);
+    virtual ~InstrumentedDOMTimer() { }
+protected:
+    virtual void start(int timeout, bool singleShot) override;
+    virtual void fired() override;
+};
+
+class DeterministicDOMTimer : public DOMTimer {
+public:
+    DeterministicDOMTimer(ScriptExecutionContext*, std::unique_ptr<ScheduledAction>, int originalInterval);
+    virtual ~DeterministicDOMTimer() { }
+protected:
+    virtual void start(int timeout, bool singleShot) override;
+};
+
+InstrumentedDOMTimer::InstrumentedDOMTimer(ScriptExecutionContext* context, std::unique_ptr<ScheduledAction> action, int originalInterval)
+    : DOMTimer(context, WTF::move(action), originalInterval)
+{
+}
+
+void InstrumentedDOMTimer::start(int timeout, bool singleShot)
+{
+    // Schedule the timer normally, then save the timeoutId assigned by the execution context.
+    DOMTimer::start(timeout, singleShot);
+    if (!scriptExecutionContext()->isDocument())
+        return;
+
+    Document& document = toDocument(*scriptExecutionContext());
+    InputCursor& cursor = document.inputCursor();
+    ASSERT(cursor.isCapturing());
+
+    cursor.appendInput<DOMTimerCreated>(frameIndexFromDocument(&document), m_timeoutId);
+}
+
+void InstrumentedDOMTimer::fired()
+{
+    ASSERT(scriptExecutionContext());
+    if (!scriptExecutionContext()->isDocument()) {
+        DOMTimer::fired();
+        return;
+    }
+
+    Document& document = toDocument(*scriptExecutionContext());
+    InputCursor& cursor = document.inputCursor();
+    // The timer could fire after capturing has stopped, since we don't replace
+    // instrumented DOM timers with normal DOM timers. 
+    if (!cursor.isCapturing()) {
+        DOMTimer::fired();
+        return;
+    }
+
+    cursor.appendInput<DOMTimerFired>(frameIndexFromDocument(&document), m_timeoutId);
+
+    EventLoopInputExtent extent(cursor);
+    DOMTimer::fired();
+}
+
+DeterministicDOMTimer::DeterministicDOMTimer(ScriptExecutionContext* context, std::unique_ptr<ScheduledAction> action, int originalInterval)
+    : DOMTimer(context, WTF::move(action), originalInterval)
+{
+    // override the default behavior set in DOMTimer constructor.
+    m_shouldScheduleNormally = false;
+}
+
+void DeterministicDOMTimer::start(int timeout, bool singleShot)
+{
+    if (!scriptExecutionContext()->isDocument())
+        return;
+
+    Document& document = toDocument(*scriptExecutionContext());
+    InputCursor& cursor = document.inputCursor();
+    ASSERT(cursor.isReplaying());
+
+    DOMTimerCreated* input = cursor.fetchInput<DOMTimerCreated>();
+    // Error handling case: if fetch failed, schedule normally.
+    if (!input) {
+        DOMTimer::start(timeout, singleShot);
+        return;
+    }
+
+    // Set the timeoutId from memoized data, and register the timer with the execution context.
+    ASSERT(input->frameIndex() == frameIndexFromDocument(&document));
+    m_timeoutId = input->timerIdentifier();
+    bool wasAdded = scriptExecutionContext()->addTimeout(m_timeoutId, this);
+    ASSERT_UNUSED(wasAdded, wasAdded);
+}
+#endif // ENABLE(WEB_REPLAY)
+
+DOMTimer::DOMTimer(ScriptExecutionContext* context, std::unique_ptr<ScheduledAction> action, int interval)
     : SuspendableTimer(context)
+    , m_timeoutId(0)
+    , m_shouldScheduleNormally(true)
     , m_nestingLevel(timerNestingLevel + 1)
     , m_action(WTF::move(action))
     , m_originalInterval(interval)
     , m_shouldForwardUserGesture(shouldForwardUserGesture(interval, m_nestingLevel))
 {
+}
+
+DOMTimer::~DOMTimer()
+{
+    if (scriptExecutionContext())
+        scriptExecutionContext()->removeTimeout(m_timeoutId);
+}
+
+void DOMTimer::start(int interval, bool singleShot)
+{
     // Keep asking for the next id until we're given one that we don't already have.
     do {
-        m_timeoutId = context->circularSequentialID();
-    } while (!context->addTimeout(m_timeoutId, this));
+        m_timeoutId = scriptExecutionContext()->circularSequentialID();
+    } while (!scriptExecutionContext()->addTimeout(m_timeoutId, this));
 
-    double intervalMilliseconds = intervalClampedToMinimum(interval, context->minimumTimerInterval());
+    double intervalMilliseconds = intervalClampedToMinimum(interval, scriptExecutionContext()->minimumTimerInterval());
     if (singleShot)
         startOneShot(intervalMilliseconds);
     else
         startRepeating(intervalMilliseconds);
 }
 
-DOMTimer::~DOMTimer()
-{
-    if (scriptExecutionContext())
-        scriptExecutionContext()->removeTimeout(m_timeoutId);
-}
-
 int DOMTimer::install(ScriptExecutionContext* context, std::unique_ptr<ScheduledAction> action, int timeout, bool singleShot)
 {
     // DOMTimer constructor links the new timer into a list of ActiveDOMObjects held by the 'context'.
     // The timer is deleted when context is deleted (DOMTimer::contextDestroyed) or explicitly via DOMTimer::removeById(),
     // or if it is a one-time timer and it has fired (DOMTimer::fired).
-    DOMTimer* timer = new DOMTimer(context, WTF::move(action), timeout, singleShot);
+    DOMTimer* timer = nullptr;
+#if ENABLE(WEB_REPLAY)
+    do {
+        if (!context->isDocument())
+            break;
+
+        InputCursor& cursor = toDocument(*context).inputCursor();
+        if (cursor.isCapturing())
+            timer = new InstrumentedDOMTimer(context, WTF::move(action), timeout);
+        if (cursor.isReplaying())
+            timer = new DeterministicDOMTimer(context, WTF::move(action), timeout);
+    } while (0);
+    if (!timer)
+#endif
+    timer = new DOMTimer(context, WTF::move(action), timeout);
+
 #if PLATFORM(IOS)
     if (context->isDocument()) {
         Document& document = toDocument(*context);
         bool didDeferTimeout = document.frame() && document.frame()->timersPaused();
         if (!didDeferTimeout && timeout <= 100 && singleShot) {
             WKSetObservedContentChange(WKContentIndeterminateChange);
             WebThreadAddObservedContentModifier(timer); // Will only take affect if not already visibility change.
         }
     }
 #endif
 
+    timer->start(timeout, singleShot);
     timer->suspendIfNeeded();
     InspectorInstrumentation::didInstallTimer(context, timer->m_timeoutId, timeout, singleShot);
 
     return timer->m_timeoutId;
 }
 
 void DOMTimer::removeById(ScriptExecutionContext* context, int timeoutId)
 {
     // timeout IDs have to be positive, and 0 and -1 are unsafe to
     // even look up since they are the empty and deleted value
@@ -132,27 +251,29 @@ void DOMTimer::fired()
 #endif
     timerNestingLevel = m_nestingLevel;
     ASSERT(!isSuspended());
     ASSERT(!context->activeDOMObjectsAreSuspended());
     UserGestureIndicator gestureIndicator(m_shouldForwardUserGesture ? DefinitelyProcessingUserGesture : PossiblyProcessingUserGesture);
     // Only the first execution of a multi-shot timer should get an affirmative user gesture indicator.
     m_shouldForwardUserGesture = false;
 
     InspectorInstrumentationCookie cookie = InspectorInstrumentation::willFireTimer(context, m_timeoutId);
 
-    // Simple case for non-one-shot timers.
     if (isActive()) {
-        double minimumInterval = context->minimumTimerInterval();
-        if (repeatInterval() && repeatInterval() < minimumInterval) {
-            m_nestingLevel++;
-            if (m_nestingLevel >= maxTimerNestingLevel)
-                augmentRepeatInterval(minimumInterval - repeatInterval());
+        if (m_shouldScheduleNormally) {
+            // Simple case for non-one-shot timers.
+            double minimumInterval = context->minimumTimerInterval();
+            if (repeatInterval() && repeatInterval() < minimumInterval) {
+                m_nestingLevel++;
+                if (m_nestingLevel >= maxTimerNestingLevel)
+                    augmentRepeatInterval(minimumInterval - repeatInterval());
+            }
         }
 
         // No access to member variables after this point, it can delete the timer.
         m_action->execute(context);
 
         InspectorInstrumentation::didFireTimer(cookie);
 
         return;
     }
 
@@ -205,20 +326,22 @@ void DOMTimer::contextDestroyed()
 void DOMTimer::didStop()
 {
     // Need to release JS objects potentially protected by ScheduledAction
     // because they can form circular references back to the ScriptExecutionContext
     // which will cause a memory leak.
     m_action = nullptr;
 }
 
 void DOMTimer::adjustMinimumTimerInterval(double oldMinimumTimerInterval)
 {
+    if (!m_shouldScheduleNormally)
+        return;
     if (m_nestingLevel < maxTimerNestingLevel)
         return;
 
     double newMinimumInterval = scriptExecutionContext()->minimumTimerInterval();
     double newClampedInterval = intervalClampedToMinimum(m_originalInterval, newMinimumInterval);
 
     if (repeatInterval()) {
         augmentRepeatInterval(newClampedInterval - repeatInterval());
         return;
     }
diff --git a/Source/WebCore/page/DOMTimer.h b/Source/WebCore/page/DOMTimer.h
index 9f1cbaa..7fcfbb4 100644
--- a/Source/WebCore/page/DOMTimer.h
+++ b/Source/WebCore/page/DOMTimer.h
@@ -26,50 +26,58 @@
 
 #ifndef DOMTimer_h
 #define DOMTimer_h
 
 #include "SuspendableTimer.h"
 #include <memory>
 
 namespace WebCore {
 
     class ScheduledAction;
+    class DOMTimerFired;
 
-    class DOMTimer final : public SuspendableTimer {
+    class DOMTimer : public SuspendableTimer {
     public:
         virtual ~DOMTimer();
         // Creates a new timer owned by specified ScriptExecutionContext, starts it
         // and returns its Id.
         static int install(ScriptExecutionContext*, std::unique_ptr<ScheduledAction>, int timeout, bool singleShot);
         static void removeById(ScriptExecutionContext*, int timeoutId);
 
         // Adjust to a change in the ScriptExecutionContext's minimum timer interval.
         // This allows the minimum allowable interval time to be changed in response
         // to events like moving a tab to the background.
         void adjustMinimumTimerInterval(double oldMinimumTimerInterval);
 
-    private:
-        DOMTimer(ScriptExecutionContext*, std::unique_ptr<ScheduledAction>, int interval, bool singleShot);
+    protected:
+        DOMTimer(ScriptExecutionContext*, std::unique_ptr<ScheduledAction>, int interval);
+        // Provide a hook for replay-specific subclasses to capture or block DOM timers.
+        virtual void start(int timeout, bool singleShot);
+        // Also fired synthetically during web replay.
         virtual void fired() override;
 
+        int m_timeoutId;
+        bool m_shouldScheduleNormally;
+    private:
+        friend class DOMTimerFired;
+
         // ActiveDOMObject
         virtual void contextDestroyed() override;
 
         // SuspendableTimer
         virtual void didStop() override;
 
         double intervalClampedToMinimum(int timeout, double minimumTimerInterval) const;
 
         // Retuns timer fire time rounded to the next multiple of timer alignment interval.
         virtual double alignedFireTime(double) const override;
 
-        int m_timeoutId;
         int m_nestingLevel;
         std::unique_ptr<ScheduledAction> m_action;
         int m_originalInterval;
         bool m_shouldForwardUserGesture;
     };
 
 } // namespace WebCore
 
 #endif // DOMTimer_h
 
diff --git a/Source/WebCore/replay/ReplayInputDispatchMethods.cpp b/Source/WebCore/replay/ReplayInputDispatchMethods.cpp
index d242aae..4c8d8ae 100644
--- a/Source/WebCore/replay/ReplayInputDispatchMethods.cpp
+++ b/Source/WebCore/replay/ReplayInputDispatchMethods.cpp
@@ -23,20 +23,21 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 
 #if ENABLE(WEB_REPLAY)
 
 #include "AllReplayInputs.h"
 #include "BackForwardController.h"
+#include "DOMTimer.h"
 #include "Document.h"
 #include "DocumentLoader.h"
 #include "FrameLoadRequest.h"
 #include "FrameLoader.h"
 #include "HistoryController.h"
 #include "MainFrame.h"
 #include "NavigationScheduler.h"
 #include "Page.h"
 #include "ReplayController.h"
 #include "ReplayableTimers.h"
@@ -193,13 +194,23 @@ void ResourceLoaderDidSendData::dispatch(ReplayController& controller)
 }
 
 // Other event loop inputs.
 void AsyncTimerFired::dispatch(ReplayController& controller)
 {
     Document* document = documentFromFrameIndex(&controller.page(), m_frameIndex);
     if (!document || !document->replayableTimers().fireTimer(m_ordinal))
         LOG_ERROR("%-30s REPLAY DIVERGENCE! Couldn't find async timer %d/%" PRIu64 ".\n", "[ReplayController]", m_frameIndex, m_ordinal);
 }
 
+void DOMTimerFired::dispatch(ReplayController& controller)
+{
+    Document* document = documentFromFrameIndex(&controller.page(), m_frameIndex);
+    DOMTimer* timer = document->findTimeout(m_timerIdentifier);
+    if (timer)
+        timer->fired();
+    else
+       LOG_ERROR("REPLAY DIVERGENCE! Couldn't find and fire DOM timer %" PRIu32 "/%" PRIu32 ".\n", m_frameIndex, m_timerIdentifier);
+}
+
 } // namespace WebCore
 
 #endif // ENABLE(WEB_REPLAY)
diff --git a/Source/WebCore/replay/WebInputs.json b/Source/WebCore/replay/WebInputs.json
index bcf3002..0c27dc8 100644
--- a/Source/WebCore/replay/WebInputs.json
+++ b/Source/WebCore/replay/WebInputs.json
@@ -235,20 +235,38 @@
         },
         {
             "name": "DocumentLastModifiedDate",
             "description": "A fallback value used for the document's last modified date if the Last-Modified header can't be found or used.",
             "queue": "SCRIPT_MEMOIZED",
             "members": [
                 { "name": "fallbackValue", "type": "double" }
             ]
         },
         {
+            "name": "DOMTimerCreated",
+            "description": "The memoized timer identifier that's chosen when a new DOMTimer is installed.",
+            "queue": "SCRIPT_MEMOIZED",
+            "members": [
+                { "name": "frameIndex", "type": "uint32_t" },
+                { "name": "timerIdentifier", "type": "uint32_t"}
+            ]
+        },
+        {
+            "name": "DOMTimerFired",
+            "description": "A DOM Timer has fired.",
+            "queue": "EVENT_LOOP",
+            "members": [
+                { "name": "frameIndex", "type": "uint32_t" },
+                { "name": "timerIdentifier", "type": "uint32_t"}
+            ]
+        },
+        {
             "name": "EndSegmentSentinel",
             "description": "A sentinel input to signal the end of a segment.",
             "queue": "EVENT_LOOP",
             "members": [ ]
         },
         {
             "name": "HandleMouseMove",
             "description": "The embedder signalled a mouse move event.",
             "queue": "EVENT_LOOP",
             "members": [
-- 
2.0.1

