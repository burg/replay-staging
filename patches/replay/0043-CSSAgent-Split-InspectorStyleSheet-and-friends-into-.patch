From 82803bd1271733be0356370b8deba09fb7f7adcf Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Sat, 21 Feb 2015 20:59:53 -0800
Subject: [PATCH] [CSSAgent] Split InspectorStyleSheet and friends into their
 own classes.

---
 Source/JavaScriptCore/inspector/protocol/CSS.json  |    2 +-
 Source/WebCore/WebCore.xcodeproj/project.pbxproj   |   48 +-
 Source/WebCore/css/CSSComputedStyleDeclaration.h   |    4 +-
 Source/WebCore/css/CSSStyleSheet.h                 |    1 +
 Source/WebCore/inspector/InspectorCSSAgent.cpp     |  629 +++++----
 Source/WebCore/inspector/InspectorCSSAgent.h       |   63 +-
 Source/WebCore/inspector/InspectorCSSId.h          |   79 ++
 .../inspector/InspectorInlineStyleRuleSet.cpp      |  111 ++
 .../inspector/InspectorInlineStyleRuleSet.h        |   83 ++
 Source/WebCore/inspector/InspectorStyleProperty.h  |   62 +
 Source/WebCore/inspector/InspectorStyleRule.cpp    |  331 +++++
 Source/WebCore/inspector/InspectorStyleRule.h      |   76 ++
 Source/WebCore/inspector/InspectorStyleRuleSet.cpp |  244 ++++
 Source/WebCore/inspector/InspectorStyleRuleSet.h   |  125 ++
 Source/WebCore/inspector/InspectorStyleSheet.cpp   | 1363 --------------------
 Source/WebCore/inspector/InspectorStyleSheet.h     |  294 -----
 .../inspector/InspectorStylesheetRuleSet.cpp       |  484 +++++++
 .../WebCore/inspector/InspectorStylesheetRuleSet.h |  157 +++
 18 files changed, 2231 insertions(+), 1925 deletions(-)
 create mode 100644 Source/WebCore/inspector/InspectorCSSId.h
 create mode 100644 Source/WebCore/inspector/InspectorInlineStyleRuleSet.cpp
 create mode 100644 Source/WebCore/inspector/InspectorInlineStyleRuleSet.h
 create mode 100644 Source/WebCore/inspector/InspectorStyleProperty.h
 create mode 100644 Source/WebCore/inspector/InspectorStyleRule.cpp
 create mode 100644 Source/WebCore/inspector/InspectorStyleRule.h
 create mode 100644 Source/WebCore/inspector/InspectorStyleRuleSet.cpp
 create mode 100644 Source/WebCore/inspector/InspectorStyleRuleSet.h
 delete mode 100644 Source/WebCore/inspector/InspectorStyleSheet.cpp
 delete mode 100644 Source/WebCore/inspector/InspectorStyleSheet.h
 create mode 100644 Source/WebCore/inspector/InspectorStylesheetRuleSet.cpp
 create mode 100644 Source/WebCore/inspector/InspectorStylesheetRuleSet.h

diff --git a/Source/JavaScriptCore/inspector/protocol/CSS.json b/Source/JavaScriptCore/inspector/protocol/CSS.json
index f02216d..893dba4 100644
--- a/Source/JavaScriptCore/inspector/protocol/CSS.json
+++ b/Source/JavaScriptCore/inspector/protocol/CSS.json
@@ -1,18 +1,18 @@
 {
     "domain": "CSS",
     "description": "This domain exposes CSS read/write operations. All CSS objects, like stylesheets, rules, and styles, have an associated <code>id</code> used in subsequent operations on the related object. Each object type has a specific <code>id</code> structure, and those are not interchangeable between objects of different kinds. CSS objects can be loaded using the <code>get*ForNode()</code> calls (which accept a DOM node id). Alternatively, a client can discover all the existing stylesheets with the <code>getAllStyleSheets()</code> method and subsequently load the required stylesheet contents using the <code>getStyleSheet[Text]()</code> methods.",
     "availability": "web",
     "types": [
         {
             "id": "StyleSheetId",
-            "type": "string"
+            "type": "integer"
         },
         {
             "id": "CSSStyleId",
             "type": "object",
             "properties": [
                 { "name": "styleSheetId", "$ref": "StyleSheetId", "description": "Enclosing stylesheet identifier." },
                 { "name": "ordinal", "type": "integer", "description": "The style ordinal within the stylesheet." }
             ],
             "description": "This object identifies a CSS style in a unique way."
         },
diff --git a/Source/WebCore/WebCore.xcodeproj/project.pbxproj b/Source/WebCore/WebCore.xcodeproj/project.pbxproj
index be014fd..8fd94fc 100644
--- a/Source/WebCore/WebCore.xcodeproj/project.pbxproj
+++ b/Source/WebCore/WebCore.xcodeproj/project.pbxproj
@@ -2553,22 +2553,20 @@
 		7EE6847112D26E3800E79415 /* ResourceResponseCFNet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7EE6845E12D26E3800E79415 /* ResourceResponseCFNet.cpp */; };
 		7EE6847512D26E7000E79415 /* ResourceLoaderCFNet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7EE6847412D26E7000E79415 /* ResourceLoaderCFNet.cpp */; };
 		8102C5881325BB1100DDE67A /* StringCallback.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 8102C5871325BB1100DDE67A /* StringCallback.cpp */; };
 		81AC5999131636E60009A7E0 /* DataTransferItem.h in Headers */ = {isa = PBXBuildFile; fileRef = 81AC5997131636E60009A7E0 /* DataTransferItem.h */; };
 		81AC599A131636E60009A7E0 /* DataTransferItemList.h in Headers */ = {isa = PBXBuildFile; fileRef = 81AC5998131636E60009A7E0 /* DataTransferItemList.h */; };
 		81AC6C36131C57D30009A7E0 /* StringCallback.h in Headers */ = {isa = PBXBuildFile; fileRef = 81AC6C35131C57D30009A7E0 /* StringCallback.h */; };
 		81BE20D311F4BC3200915DFA /* JSIDBCursor.h in Headers */ = {isa = PBXBuildFile; fileRef = 81BE20A811F4B66F00915DFA /* JSIDBCursor.h */; };
 		81F65FF613788FAA00FF6F2D /* DragState.h in Headers */ = {isa = PBXBuildFile; fileRef = 81F65FF513788FAA00FF6F2D /* DragState.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		82AB1743124B99EC00C5069D /* InspectorCSSAgent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 82AB1741124B99EC00C5069D /* InspectorCSSAgent.cpp */; };
 		82AB1744124B99EC00C5069D /* InspectorCSSAgent.h in Headers */ = {isa = PBXBuildFile; fileRef = 82AB1742124B99EC00C5069D /* InspectorCSSAgent.h */; };
-		82AB1773125C826700C5069D /* InspectorStyleSheet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 82AB176F125C826700C5069D /* InspectorStyleSheet.cpp */; };
-		82AB1774125C826700C5069D /* InspectorStyleSheet.h in Headers */ = {isa = PBXBuildFile; fileRef = 82AB1770125C826700C5069D /* InspectorStyleSheet.h */; };
 		82AB1775125C826700C5069D /* InspectorResourceAgent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 82AB1771125C826700C5069D /* InspectorResourceAgent.cpp */; };
 		82AB1776125C826700C5069D /* InspectorResourceAgent.h in Headers */ = {isa = PBXBuildFile; fileRef = 82AB1772125C826700C5069D /* InspectorResourceAgent.h */; };
 		82E3D8DE122EA0D1003AE5BC /* CSSPropertySourceData.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 82E3D8DC122EA0D1003AE5BC /* CSSPropertySourceData.cpp */; };
 		82E3D8DF122EA0D1003AE5BC /* CSSPropertySourceData.h in Headers */ = {isa = PBXBuildFile; fileRef = 82E3D8DD122EA0D1003AE5BC /* CSSPropertySourceData.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		832B843419D8E55100B26055 /* SVGAnimateElementBase.h in Headers */ = {isa = PBXBuildFile; fileRef = 832B843319D8E55100B26055 /* SVGAnimateElementBase.h */; };
 		832B843619D8E57400B26055 /* SVGAnimateElementBase.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 832B843519D8E57400B26055 /* SVGAnimateElementBase.cpp */; };
 		83520C7E1A71BFCC006BD2AA /* CSSFontFamily.h in Headers */ = {isa = PBXBuildFile; fileRef = 83520C7D1A71BFCC006BD2AA /* CSSFontFamily.h */; };
 		835D363719FF6193004C93AB /* StyleBuilderCustom.h in Headers */ = {isa = PBXBuildFile; fileRef = 835D363619FF6193004C93AB /* StyleBuilderCustom.h */; };
 		836FBCEA178C113200B21A15 /* SVGAnimatedTypeAnimator.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 836FBCE9178C113200B21A15 /* SVGAnimatedTypeAnimator.cpp */; };
 		836FBCEC178C117F00B21A15 /* SVGAnimatedProperty.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 836FBCEB178C117F00B21A15 /* SVGAnimatedProperty.cpp */; };
@@ -5565,20 +5563,30 @@
 		C49474A819A2D612009B3DE8 /* EventSender.h in Headers */ = {isa = PBXBuildFile; fileRef = CE5CB1B314EDAB6F00BB2795 /* EventSender.h */; };
 		C49474AA19A2E2E5009B3DE8 /* SharedEventSenders.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C49474A919A2E2E5009B3DE8 /* SharedEventSenders.cpp */; };
 		C49474AC19A3F7A2009B3DE8 /* ReplayClient.h in Headers */ = {isa = PBXBuildFile; fileRef = C49474AB19A3F7A2009B3DE8 /* ReplayClient.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C49E39F71A70334100429A46 /* WebInputs.json in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B4C18BE9849006CEBCC /* WebInputs.json */; settings = {ATTRIBUTES = (Private, ); }; };
 		C4CD629A18383766007EBAF1 /* FrameSnapshotting.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4CD629818383766007EBAF1 /* FrameSnapshotting.cpp */; };
 		C4CD629B18383766007EBAF1 /* FrameSnapshotting.h in Headers */ = {isa = PBXBuildFile; fileRef = C4CD629918383766007EBAF1 /* FrameSnapshotting.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C4D4F52B1975C88B003EF5BC /* ReplayableTimer.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4D4F5271975C88B003EF5BC /* ReplayableTimer.cpp */; };
 		C4D4F52C1975C88B003EF5BC /* ReplayableTimer.h in Headers */ = {isa = PBXBuildFile; fileRef = C4D4F5281975C88B003EF5BC /* ReplayableTimer.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C4D4F52D1975C88B003EF5BC /* ReplayableTimers.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4D4F5291975C88B003EF5BC /* ReplayableTimers.cpp */; };
 		C4D4F52E1975C88B003EF5BC /* ReplayableTimers.h in Headers */ = {isa = PBXBuildFile; fileRef = C4D4F52A1975C88B003EF5BC /* ReplayableTimers.h */; settings = {ATTRIBUTES = (Private, ); }; };
+		C4E657F21A97F7A700479C15 /* InspectorCSSId.h in Headers */ = {isa = PBXBuildFile; fileRef = C4E657F11A97F7A700479C15 /* InspectorCSSId.h */; };
+		C4E657FA1A97FBED00479C15 /* InspectorInlineStyleRuleSet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4E657F31A97FBED00479C15 /* InspectorInlineStyleRuleSet.cpp */; };
+		C4E657FB1A97FBED00479C15 /* InspectorInlineStyleRuleSet.h in Headers */ = {isa = PBXBuildFile; fileRef = C4E657F41A97FBED00479C15 /* InspectorInlineStyleRuleSet.h */; };
+		C4E657FC1A97FBED00479C15 /* InspectorStyleRule.h in Headers */ = {isa = PBXBuildFile; fileRef = C4E657F51A97FBED00479C15 /* InspectorStyleRule.h */; };
+		C4E657FD1A97FBED00479C15 /* InspectorStyleProperty.h in Headers */ = {isa = PBXBuildFile; fileRef = C4E657F61A97FBED00479C15 /* InspectorStyleProperty.h */; };
+		C4E657FE1A97FBED00479C15 /* InspectorStyleRuleSet.h in Headers */ = {isa = PBXBuildFile; fileRef = C4E657F71A97FBED00479C15 /* InspectorStyleRuleSet.h */; };
+		C4E657FF1A97FBED00479C15 /* InspectorStylesheetRuleSet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4E657F81A97FBED00479C15 /* InspectorStylesheetRuleSet.cpp */; };
+		C4E658001A97FBED00479C15 /* InspectorStylesheetRuleSet.h in Headers */ = {isa = PBXBuildFile; fileRef = C4E657F91A97FBED00479C15 /* InspectorStylesheetRuleSet.h */; };
+		C4E658021A98016800479C15 /* InspectorStyleRule.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4E658011A98016800479C15 /* InspectorStyleRule.cpp */; };
+		C4E658041A984B5200479C15 /* InspectorStyleRuleSet.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C4E658031A984B5200479C15 /* InspectorStyleRuleSet.cpp */; };
 		C50D0E830FF4272900AC2644 /* StorageNamespace.h in Headers */ = {isa = PBXBuildFile; fileRef = C50D0E810FF4272900AC2644 /* StorageNamespace.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C5137CF211A58378004ADB99 /* JSDOMStringList.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C5137CF011A58378004ADB99 /* JSDOMStringList.cpp */; };
 		C5137CF311A58378004ADB99 /* JSDOMStringList.h in Headers */ = {isa = PBXBuildFile; fileRef = C5137CF111A58378004ADB99 /* JSDOMStringList.h */; };
 		C5278B0C17F212EA003A2998 /* PlatformPasteboardIOS.mm in Sources */ = {isa = PBXBuildFile; fileRef = C5278B0B17F212EA003A2998 /* PlatformPasteboardIOS.mm */; };
 		C544274B11A57E7A0063A749 /* DOMStringList.h in Headers */ = {isa = PBXBuildFile; fileRef = C544274911A57E7A0063A749 /* DOMStringList.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		C55610F111A704EB00B82D27 /* DOMStringList.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C55610F011A704EB00B82D27 /* DOMStringList.cpp */; };
 		C55C7BA11718AFBA001327E4 /* RenderThemeIOS.mm in Sources */ = {isa = PBXBuildFile; fileRef = C55C7BA01718AFBA001327E4 /* RenderThemeIOS.mm */; };
 		C572EE1F1201C9BC007D8F82 /* JSIDBIndex.h in Headers */ = {isa = PBXBuildFile; fileRef = C572EE1D1201C9BC007D8F82 /* JSIDBIndex.h */; };
 		C57FEDE11212EE9C0097BE65 /* FileSystem.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C57FEDE01212EE9C0097BE65 /* FileSystem.cpp */; };
 		C58361A91744523F00173511 /* FontServicesIOS.h in Headers */ = {isa = PBXBuildFile; fileRef = C58361A71744523F00173511 /* FontServicesIOS.h */; };
@@ -9766,22 +9774,20 @@
 		81AC5998131636E60009A7E0 /* DataTransferItemList.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DataTransferItemList.h; sourceTree = "<group>"; };
 		81AC5AE81316392E0009A7E0 /* DataTransferItem.idl */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = DataTransferItem.idl; sourceTree = "<group>"; };
 		81AC5AE91316392E0009A7E0 /* DataTransferItemList.idl */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = DataTransferItemList.idl; sourceTree = "<group>"; };
 		81AC6C34131C57C20009A7E0 /* StringCallback.idl */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = StringCallback.idl; sourceTree = "<group>"; };
 		81AC6C35131C57D30009A7E0 /* StringCallback.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StringCallback.h; sourceTree = "<group>"; };
 		81BE20A811F4B66F00915DFA /* JSIDBCursor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JSIDBCursor.h; sourceTree = "<group>"; };
 		81F65FF513788FAA00FF6F2D /* DragState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DragState.h; sourceTree = "<group>"; };
 		8225432CA9D4B4CF4628EC7F /* JSBeforeUnloadEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JSBeforeUnloadEvent.cpp; sourceTree = "<group>"; };
 		82AB1741124B99EC00C5069D /* InspectorCSSAgent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorCSSAgent.cpp; sourceTree = "<group>"; };
 		82AB1742124B99EC00C5069D /* InspectorCSSAgent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorCSSAgent.h; sourceTree = "<group>"; };
-		82AB176F125C826700C5069D /* InspectorStyleSheet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorStyleSheet.cpp; sourceTree = "<group>"; };
-		82AB1770125C826700C5069D /* InspectorStyleSheet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorStyleSheet.h; sourceTree = "<group>"; };
 		82AB1771125C826700C5069D /* InspectorResourceAgent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorResourceAgent.cpp; sourceTree = "<group>"; };
 		82AB1772125C826700C5069D /* InspectorResourceAgent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorResourceAgent.h; sourceTree = "<group>"; };
 		82E3D8DC122EA0D1003AE5BC /* CSSPropertySourceData.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CSSPropertySourceData.cpp; sourceTree = "<group>"; };
 		82E3D8DD122EA0D1003AE5BC /* CSSPropertySourceData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CSSPropertySourceData.h; sourceTree = "<group>"; };
 		832B843319D8E55100B26055 /* SVGAnimateElementBase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SVGAnimateElementBase.h; sourceTree = "<group>"; };
 		832B843519D8E57400B26055 /* SVGAnimateElementBase.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SVGAnimateElementBase.cpp; sourceTree = "<group>"; };
 		83520C7D1A71BFCC006BD2AA /* CSSFontFamily.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CSSFontFamily.h; sourceTree = "<group>"; };
 		835D363619FF6193004C93AB /* StyleBuilderCustom.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StyleBuilderCustom.h; sourceTree = "<group>"; };
 		836FBCE9178C113200B21A15 /* SVGAnimatedTypeAnimator.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SVGAnimatedTypeAnimator.cpp; sourceTree = "<group>"; };
 		836FBCEB178C117F00B21A15 /* SVGAnimatedProperty.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SVGAnimatedProperty.cpp; sourceTree = "<group>"; };
@@ -13030,20 +13036,30 @@
 		C46871B91A67220B00860C87 /* InspectorDOMTracingAgent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorDOMTracingAgent.h; sourceTree = "<group>"; };
 		C49474A019A2847C009B3DE8 /* SharedEventSenders.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SharedEventSenders.h; sourceTree = "<group>"; };
 		C49474A919A2E2E5009B3DE8 /* SharedEventSenders.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SharedEventSenders.cpp; sourceTree = "<group>"; };
 		C49474AB19A3F7A2009B3DE8 /* ReplayClient.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ReplayClient.h; sourceTree = "<group>"; };
 		C4CD629818383766007EBAF1 /* FrameSnapshotting.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FrameSnapshotting.cpp; sourceTree = "<group>"; };
 		C4CD629918383766007EBAF1 /* FrameSnapshotting.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FrameSnapshotting.h; sourceTree = "<group>"; };
 		C4D4F5271975C88B003EF5BC /* ReplayableTimer.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ReplayableTimer.cpp; sourceTree = "<group>"; };
 		C4D4F5281975C88B003EF5BC /* ReplayableTimer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ReplayableTimer.h; sourceTree = "<group>"; };
 		C4D4F5291975C88B003EF5BC /* ReplayableTimers.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ReplayableTimers.cpp; sourceTree = "<group>"; };
 		C4D4F52A1975C88B003EF5BC /* ReplayableTimers.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ReplayableTimers.h; sourceTree = "<group>"; };
+		C4E657F11A97F7A700479C15 /* InspectorCSSId.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorCSSId.h; sourceTree = "<group>"; };
+		C4E657F31A97FBED00479C15 /* InspectorInlineStyleRuleSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorInlineStyleRuleSet.cpp; sourceTree = "<group>"; };
+		C4E657F41A97FBED00479C15 /* InspectorInlineStyleRuleSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorInlineStyleRuleSet.h; sourceTree = "<group>"; };
+		C4E657F51A97FBED00479C15 /* InspectorStyleRule.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorStyleRule.h; sourceTree = "<group>"; };
+		C4E657F61A97FBED00479C15 /* InspectorStyleProperty.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorStyleProperty.h; sourceTree = "<group>"; };
+		C4E657F71A97FBED00479C15 /* InspectorStyleRuleSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorStyleRuleSet.h; sourceTree = "<group>"; };
+		C4E657F81A97FBED00479C15 /* InspectorStylesheetRuleSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorStylesheetRuleSet.cpp; sourceTree = "<group>"; };
+		C4E657F91A97FBED00479C15 /* InspectorStylesheetRuleSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InspectorStylesheetRuleSet.h; sourceTree = "<group>"; };
+		C4E658011A98016800479C15 /* InspectorStyleRule.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorStyleRule.cpp; sourceTree = "<group>"; };
+		C4E658031A984B5200479C15 /* InspectorStyleRuleSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InspectorStyleRuleSet.cpp; sourceTree = "<group>"; };
 		C50D0E810FF4272900AC2644 /* StorageNamespace.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StorageNamespace.h; sourceTree = "<group>"; };
 		C5137CF011A58378004ADB99 /* JSDOMStringList.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JSDOMStringList.cpp; sourceTree = "<group>"; };
 		C5137CF111A58378004ADB99 /* JSDOMStringList.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JSDOMStringList.h; sourceTree = "<group>"; };
 		C5278B0B17F212EA003A2998 /* PlatformPasteboardIOS.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; name = PlatformPasteboardIOS.mm; path = ios/PlatformPasteboardIOS.mm; sourceTree = "<group>"; };
 		C544274911A57E7A0063A749 /* DOMStringList.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DOMStringList.h; sourceTree = "<group>"; };
 		C544274A11A57E7A0063A749 /* DOMStringList.idl */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = DOMStringList.idl; sourceTree = "<group>"; };
 		C55610F011A704EB00B82D27 /* DOMStringList.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DOMStringList.cpp; sourceTree = "<group>"; };
 		C55C7BA01718AFBA001327E4 /* RenderThemeIOS.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; path = RenderThemeIOS.mm; sourceTree = "<group>"; };
 		C572EE1D1201C9BC007D8F82 /* JSIDBIndex.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JSIDBIndex.h; sourceTree = "<group>"; };
 		C57FEDE01212EE9C0097BE65 /* FileSystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FileSystem.cpp; sourceTree = "<group>"; };
@@ -15275,20 +15291,21 @@
 				C450BFDA1A8AABD000D18277 /* ElementTraceOperations.h */,
 				B885E8D211E06DD2009FFBF4 /* InspectorApplicationCacheAgent.cpp */,
 				B885E8D311E06DD2009FFBF4 /* InspectorApplicationCacheAgent.h */,
 				7A1F2B51126C61B20006A7E6 /* InspectorClient.cpp */,
 				1C81B9580E97330800266E07 /* InspectorClient.h */,
 				F3F5CF1012ED81A80084C569 /* InspectorConsoleInstrumentation.h */,
 				1C81B9570E97330800266E07 /* InspectorController.cpp */,
 				1C81B9560E97330800266E07 /* InspectorController.h */,
 				82AB1741124B99EC00C5069D /* InspectorCSSAgent.cpp */,
 				82AB1742124B99EC00C5069D /* InspectorCSSAgent.h */,
+				C4E657F11A97F7A700479C15 /* InspectorCSSId.h */,
 				7AB0B1BE1211A62200A76940 /* InspectorDatabaseAgent.cpp */,
 				7AB0B1BF1211A62200A76940 /* InspectorDatabaseAgent.h */,
 				F3F5CF1212ED81B30084C569 /* InspectorDatabaseInstrumentation.h */,
 				41F062130F5F192600A07EAC /* InspectorDatabaseResource.cpp */,
 				41F062120F5F192600A07EAC /* InspectorDatabaseResource.h */,
 				7A2458791021EAF4000A00AA /* InspectorDOMAgent.cpp */,
 				7A24587A1021EAF4000A00AA /* InspectorDOMAgent.h */,
 				F3D4C47612E07663003DA150 /* InspectorDOMDebuggerAgent.cpp */,
 				F3D4C47712E07663003DA150 /* InspectorDOMDebuggerAgent.h */,
 				7A74ECB8101839A500BF939E /* InspectorDOMStorageAgent.cpp */,
@@ -15299,41 +15316,48 @@
 				F344C7121125B82C00F26EEE /* InspectorFrontendClient.h */,
 				F344C75711294FF600F26EEE /* InspectorFrontendClientLocal.cpp */,
 				F344C75211294D9D00F26EEE /* InspectorFrontendClientLocal.h */,
 				7A0E770B10C00A8800A0276E /* InspectorFrontendHost.cpp */,
 				7A0E770C10C00A8800A0276E /* InspectorFrontendHost.h */,
 				7A0E770D10C00A8800A0276E /* InspectorFrontendHost.idl */,
 				7A54857D14E02D51006AE05A /* InspectorHistory.cpp */,
 				7A54857E14E02D51006AE05A /* InspectorHistory.h */,
 				7ACD88D114C08BD60084EDD2 /* InspectorIndexedDBAgent.cpp */,
 				7ACD88D214C08BD60084EDD2 /* InspectorIndexedDBAgent.h */,
+				C4E657F31A97FBED00479C15 /* InspectorInlineStyleRuleSet.cpp */,
+				C4E657F41A97FBED00479C15 /* InspectorInlineStyleRuleSet.h */,
 				20D629241253690B00081543 /* InspectorInstrumentation.cpp */,
 				20D629251253690B00081543 /* InspectorInstrumentation.h */,
 				A5840E1A187B74D500843B10 /* InspectorInstrumentationCookie.cpp */,
 				A5840E1B187B74D500843B10 /* InspectorInstrumentationCookie.h */,
 				71B1E123164048CC00B1880A /* InspectorLayerTreeAgent.cpp */,
 				71B1E124164048CC00B1880A /* InspectorLayerTreeAgent.h */,
 				504AACCB1834455900E3D9BC /* InspectorNodeFinder.cpp */,
 				504AACCC1834455900E3D9BC /* InspectorNodeFinder.h */,
 				7C522D4915B477E8009B7C95 /* InspectorOverlay.cpp */,
 				7C522D4A15B478B2009B7C95 /* InspectorOverlay.h */,
 				A518225417E2A0D400A9BA1D /* InspectorOverlayPage.css */,
 				7A7256B915EB9F5B007323A7 /* InspectorOverlayPage.html */,
 				A518225517E2A0D400A9BA1D /* InspectorOverlayPage.js */,
 				4F6FDD621341DEDD001F8EE3 /* InspectorPageAgent.cpp */,
 				4F6FDD631341DEDD001F8EE3 /* InspectorPageAgent.h */,
 				99CC0B6418BE9F15006CEBCC /* InspectorReplayAgent.cpp */,
 				99CC0B6518BE9F15006CEBCC /* InspectorReplayAgent.h */,
 				82AB1771125C826700C5069D /* InspectorResourceAgent.cpp */,
 				82AB1772125C826700C5069D /* InspectorResourceAgent.h */,
-				82AB176F125C826700C5069D /* InspectorStyleSheet.cpp */,
-				82AB1770125C826700C5069D /* InspectorStyleSheet.h */,
+				C4E658011A98016800479C15 /* InspectorStyleRule.cpp */,
+				C4E657F51A97FBED00479C15 /* InspectorStyleRule.h */,
+				C4E657F61A97FBED00479C15 /* InspectorStyleProperty.h */,
+				C4E658031A984B5200479C15 /* InspectorStyleRuleSet.cpp */,
+				C4E657F71A97FBED00479C15 /* InspectorStyleRuleSet.h */,
+				C4E657F81A97FBED00479C15 /* InspectorStylesheetRuleSet.cpp */,
+				C4E657F91A97FBED00479C15 /* InspectorStylesheetRuleSet.h */,
 				754133A9102E00F400075D00 /* InspectorTimelineAgent.cpp */,
 				754133A7102E00E800075D00 /* InspectorTimelineAgent.h */,
 				A593CF8A1840535200BFCE27 /* InspectorWebAgentBase.h */,
 				F3810C191365A49600ED6E33 /* InspectorWorkerAgent.cpp */,
 				F3810C1A1365A49600ED6E33 /* InspectorWorkerAgent.h */,
 				F375CC061150D300008DDB81 /* InspectorWorkerResource.h */,
 				F350B73413F1377D00880C43 /* InstrumentingAgents.cpp */,
 				F3ABFE0B130E9DA000E7F7D1 /* InstrumentingAgents.h */,
 				59C27F04138D28C10079B7E2 /* NetworkResourcesData.cpp */,
 				59C27F06138D28CF0079B7E2 /* NetworkResourcesData.h */,
@@ -24028,20 +24052,21 @@
 				FCD8832A16A49F8200962227 /* DOMCSSSupportsRule.h in Headers */,
 				FCEBBAAB16A4967A00FA20A6 /* DOMCSSSupportsRuleInternal.h in Headers */,
 				85032DE90AA8C9BE007D3B7D /* DOMCSSUnknownRule.h in Headers */,
 				85909CE40ACC7A7E00DF01F1 /* DOMCSSUnknownRuleInternal.h in Headers */,
 				858C381C0AA8E29600B187A4 /* DOMCSSValue.h in Headers */,
 				85B498F30ADB336A00925CBB /* DOMCSSValueInternal.h in Headers */,
 				858C383C0AA8ED8200B187A4 /* DOMCSSValueList.h in Headers */,
 				85909D2B0ACC7D5500DF01F1 /* DOMCSSValueListInternal.h in Headers */,
 				E10B9CCC0B747A44003ED890 /* DOMCustomXPathNSResolver.h in Headers */,
 				85ACABB00A9CAF8000671E90 /* DOMDocument.h in Headers */,
+				C4E657FB1A97FBED00479C15 /* InspectorInlineStyleRuleSet.h in Headers */,
 				85089CDB0A98C42800A275AA /* DOMDocumentFragment.h in Headers */,
 				44311F8212E4E66C000A8D19 /* DOMDocumentFragmentInternal.h in Headers */,
 				44311CD612E4E22D000A8D19 /* DOMDocumentFragmentPrivate.h in Headers */,
 				85E711950AC5D5350053270F /* DOMDocumentInternal.h in Headers */,
 				44311CD712E4E22D000A8D19 /* DOMDocumentPrivate.h in Headers */,
 				85CA975C0A962E5400690CCF /* DOMDocumentType.h in Headers */,
 				85E711960AC5D5350053270F /* DOMDocumentTypeInternal.h in Headers */,
 				319848011A1D817B00A13318 /* AnimationEvent.h in Headers */,
 				8518DCE90A9CC80D0091B7A6 /* DOMDOMImplementation.h in Headers */,
 				85E711970AC5D5350053270F /* DOMDOMImplementationInternal.h in Headers */,
@@ -24556,20 +24581,21 @@
 				5179CE37195CAC7E0019C198 /* HIDGamepadProvider.h in Headers */,
 				BC94D1540C275C8B006BC617 /* History.h in Headers */,
 				97DCE20210807C750057D394 /* HistoryController.h in Headers */,
 				51741D110B07259A00ED442C /* HistoryItem.h in Headers */,
 				4969B0F313D0B33F00DF3521 /* HitTestingTransformState.h in Headers */,
 				2D8287F716E4A0380086BD00 /* HitTestLocation.h in Headers */,
 				930908910AF7EDE40081DF01 /* HitTestRequest.h in Headers */,
 				9307F1D80AF2D59000DBA31A /* HitTestResult.h in Headers */,
 				BC3BC29C0E91AB0F00835588 /* HostWindow.h in Headers */,
 				FD31609912B026F700C1A359 /* HRTFDatabase.h in Headers */,
+				C4E657FE1A97FBED00479C15 /* InspectorStyleRuleSet.h in Headers */,
 				FD31609B12B026F700C1A359 /* HRTFDatabaseLoader.h in Headers */,
 				FD31609D12B026F700C1A359 /* HRTFElevation.h in Headers */,
 				FD31609F12B026F700C1A359 /* HRTFKernel.h in Headers */,
 				FD3160A112B026F700C1A359 /* HRTFPanner.h in Headers */,
 				BC97E23A109144950010D361 /* HTMLAllCollection.h in Headers */,
 				CD5E5B5F1A15CE54000C609E /* PageConfiguration.h in Headers */,
 				A8CFF7AB0A156978000A4234 /* HTMLAnchorElement.h in Headers */,
 				A871D45D0A127CBC00B12A68 /* HTMLAppletElement.h in Headers */,
 				A8EA7D2E0A19385500A8EF5F /* HTMLAreaElement.h in Headers */,
 				E44613A20CD6331000FADA75 /* HTMLAudioElement.h in Headers */,
@@ -24808,21 +24834,20 @@
 				7A54858014E02D51006AE05A /* InspectorHistory.h in Headers */,
 				7ACD88D414C08BD60084EDD2 /* InspectorIndexedDBAgent.h in Headers */,
 				20D629271253690B00081543 /* InspectorInstrumentation.h in Headers */,
 				A5840E1D187B74D500843B10 /* InspectorInstrumentationCookie.h in Headers */,
 				71B1E125164048F700B1880A /* InspectorLayerTreeAgent.h in Headers */,
 				504AACCE1834455900E3D9BC /* InspectorNodeFinder.h in Headers */,
 				0F03C0751884805500A5F8CA /* InspectorOverlay.h in Headers */,
 				4F6FDD651341DEDD001F8EE3 /* InspectorPageAgent.h in Headers */,
 				99CC0B6718BE9F15006CEBCC /* InspectorReplayAgent.h in Headers */,
 				82AB1776125C826700C5069D /* InspectorResourceAgent.h in Headers */,
-				82AB1774125C826700C5069D /* InspectorStyleSheet.h in Headers */,
 				754133A8102E00E800075D00 /* InspectorTimelineAgent.h in Headers */,
 				A593CF8B1840535200BFCE27 /* InspectorWebAgentBase.h in Headers */,
 				F3810C1C1365A49600ED6E33 /* InspectorWorkerAgent.h in Headers */,
 				F375CC071150D300008DDB81 /* InspectorWorkerResource.h in Headers */,
 				F3ABFE0C130E9DA000E7F7D1 /* InstrumentingAgents.h in Headers */,
 				B27535720B053814002CE64F /* IntPoint.h in Headers */,
 				E462A4A1113E71BE004A4220 /* IntPointHash.h in Headers */,
 				B27535740B053814002CE64F /* IntRect.h in Headers */,
 				A2B9217316C5CC420041DCD9 /* IntRectExtent.h in Headers */,
 				E134F5AB12EE343F004EC58D /* IntRectHash.h in Headers */,
@@ -25383,20 +25408,21 @@
 				49EED1471051969400099FAB /* JSWebGLRenderingContext.h in Headers */,
 				49C7B9A31042D2D30009D447 /* JSWebGLShader.h in Headers */,
 				A07D3356152B630E001B6393 /* JSWebGLShaderPrecisionFormat.h in Headers */,
 				49C7B9A51042D2D30009D447 /* JSWebGLTexture.h in Headers */,
 				0C45342810CDBBFA00869157 /* JSWebGLUniformLocation.h in Headers */,
 				77EF62F412F9DB7400C77BD2 /* JSWebGLVertexArrayObjectOES.h in Headers */,
 				31C0FF3E0E4CEFAC007D6FE5 /* JSWebKitAnimationEvent.h in Headers */,
 				310603751432819C00ABF4BA /* JSWebKitCSSFilterValue.h in Headers */,
 				316FE0720E6CCBEE00BF6088 /* JSCSSKeyframeRule.h in Headers */,
 				316FE0740E6CCBEE00BF6088 /* JSCSSKeyframesRule.h in Headers */,
+				C4E657FD1A97FBED00479C15 /* InspectorStyleProperty.h in Headers */,
 				498391400F1E767500C23782 /* JSWebKitCSSMatrix.h in Headers */,
 				8AD0A59514C88336000D83C5 /* JSWebKitCSSRegionRule.h in Headers */,
 				31611E5B0E1C4DE000F6A579 /* JSWebKitCSSTransformValue.h in Headers */,
 				3F2B33EF165AF15600E3987C /* JSWebKitCSSViewportRule.h in Headers */,
 				7CC69941191EC5F500AF2270 /* JSWebKitNamespace.h in Headers */,
 				0FDA7C271883333200C954B5 /* JSWebKitPlaybackTargetAvailabilityEvent.h in Headers */,
 				494BD79E0F55C94C00747828 /* JSWebKitPoint.h in Headers */,
 				31C0FF400E4CEFAC007D6FE5 /* JSWebKitTransitionEvent.h in Headers */,
 				5DA5E0FD102B953800088CF9 /* JSWebSocket.h in Headers */,
 				65DF320609D1CC60000BE325 /* JSWheelEvent.h in Headers */,
@@ -25439,20 +25465,21 @@
 				A12538D413F9B60A00024754 /* LayoutRepainter.h in Headers */,
 				141DC054164834B900371E5A /* LayoutSize.h in Headers */,
 				2D9066070BE141D400956998 /* LayoutState.h in Headers */,
 				141DC0481648348F00371E5A /* LayoutUnit.h in Headers */,
 				E4C3B1FA0F0E4161009693F6 /* LegacyTileCache.h in Headers */,
 				E4B65A58132FA8E70070E7BE /* LegacyTileGrid.h in Headers */,
 				E424A39E1330DF0100CF6DC9 /* LegacyTileGridTile.h in Headers */,
 				E4B65A5C132FACB00070E7BE /* LegacyTileLayer.h in Headers */,
 				E4E39AFB1330EFA8003AB274 /* LegacyTileLayerPool.h in Headers */,
 				512DD8F50D91E6AF000F89EE /* LegacyWebArchive.h in Headers */,
+				C4E657FC1A97FBED00479C15 /* InspectorStyleRule.h in Headers */,
 				BCE65BEB0EACDF16007E4533 /* Length.h in Headers */,
 				BCFF64910EAD15C200C1D6F7 /* LengthBox.h in Headers */,
 				E5BA7D63151437CA00FE1E3F /* LengthFunctions.h in Headers */,
 				F42FFB461984B71600F6837F /* LengthRepeat.h in Headers */,
 				BCFF64920EAD15C200C1D6F7 /* LengthSize.h in Headers */,
 				84730D911248F0B300D3A9C9 /* LightSource.h in Headers */,
 				B22279650D00BF220071B782 /* LinearGradientAttributes.h in Headers */,
 				A5ABB78713B904BC00F197E3 /* LineBreakIteratorPoolICU.h in Headers */,
 				AB31C91E10AE1B8E000C7B92 /* LineClampValue.h in Headers */,
 				89B5EAA211E8003D00F2367E /* LineEnding.h in Headers */,
@@ -26511,20 +26538,21 @@
 				436708FA12D9CA4B00044234 /* SVGResourcesCycleSolver.h in Headers */,
 				0854B0231255E4E600B9CDD0 /* SVGRootInlineBox.h in Headers */,
 				B2227AA30D00BF220071B782 /* SVGScriptElement.h in Headers */,
 				B2227AA60D00BF220071B782 /* SVGSetElement.h in Headers */,
 				E4AFD0100DAF335500F5F55C /* SVGSMILElement.h in Headers */,
 				0880F70E1282B46D00948505 /* SVGStaticListPropertyTearOff.h in Headers */,
 				0813A4EA1284132600992511 /* SVGStaticPropertyTearOff.h in Headers */,
 				B2227AA90D00BF220071B782 /* SVGStopElement.h in Headers */,
 				B2227AAC0D00BF220071B782 /* SVGStringList.h in Headers */,
 				B2227AB80D00BF220071B782 /* SVGStyleElement.h in Headers */,
+				C4E657F21A97F7A700479C15 /* InspectorCSSId.h in Headers */,
 				B2227ABB0D00BF220071B782 /* SVGSVGElement.h in Headers */,
 				D3F3D3681A69B1A50059FC2B /* JSWebGLRenderingContextBase.h in Headers */,
 				B2227ABE0D00BF220071B782 /* SVGSwitchElement.h in Headers */,
 				B2227AC10D00BF220071B782 /* SVGSymbolElement.h in Headers */,
 				B2227AC50D00BF220071B782 /* SVGTests.h in Headers */,
 				08F0BFC31255C53C00075185 /* SVGTextChunk.h in Headers */,
 				081668D4125603BF006F25DE /* SVGTextChunkBuilder.h in Headers */,
 				B2227AC80D00BF220071B782 /* SVGTextContentElement.h in Headers */,
 				B2227ACB0D00BF220071B782 /* SVGTextElement.h in Headers */,
 				08F0BFC41255C53C00075185 /* SVGTextFragment.h in Headers */,
@@ -26914,20 +26942,21 @@
 				BC772C470C4EB2C60083285F /* XMLHttpRequest.h in Headers */,
 				BC60D9C90D2A29E500B9918F /* XMLHttpRequestException.h in Headers */,
 				F9F0ED7A0DB50CA200D16DB9 /* XMLHttpRequestProgressEvent.h in Headers */,
 				A136A00D1134DBD200CC8D50 /* XMLHttpRequestProgressEventThrottle.h in Headers */,
 				BCDFD48E0E305290009D10AD /* XMLHttpRequestUpload.h in Headers */,
 				A833C80D0A2CF25600D57664 /* XMLNames.h in Headers */,
 				E15A36D71104572000B7B639 /* XMLNSNames.h in Headers */,
 				1ACE53EB0A8D18E70022947D /* XMLSerializer.h in Headers */,
 				5905ADC01302F3CE00F116DF /* XMLTreeViewer.h in Headers */,
 				1AB7FC690A8B92EC00D9D37B /* XPathEvaluator.h in Headers */,
+				C4E658001A97FBED00479C15 /* InspectorStylesheetRuleSet.h in Headers */,
 				BC60DA5B0D2A31F700B9918F /* XPathException.h in Headers */,
 				1AB7FC6C0A8B92EC00D9D37B /* XPathExpression.h in Headers */,
 				1AB7FC6F0A8B92EC00D9D37B /* XPathExpressionNode.h in Headers */,
 				1AB7FC710A8B92EC00D9D37B /* XPathFunctions.h in Headers */,
 				1A7629D60A07425100989F5B /* XPathGrammar.h in Headers */,
 				E1EC29A00BB04C6B00EA187B /* XPathNodeSet.h in Headers */,
 				1AB7FC760A8B92EC00D9D37B /* XPathNSResolver.h in Headers */,
 				1AB7FC790A8B92EC00D9D37B /* XPathParser.h in Headers */,
 				1AB7FC7B0A8B92EC00D9D37B /* XPathPath.h in Headers */,
 				1AB7FC7D0A8B92EC00D9D37B /* XPathPredicate.h in Headers */,
@@ -28127,20 +28156,21 @@
 				A8EA79FC0A1916DF00A8EF5F /* HTMLLIElement.cpp in Sources */,
 				A871DC210A15205700B12A68 /* HTMLLinkElement.cpp in Sources */,
 				A8EA7D320A19385500A8EF5F /* HTMLMapElement.cpp in Sources */,
 				A8EA7CAC0A192B9C00A8EF5F /* HTMLMarqueeElement.cpp in Sources */,
 				E44613A40CD6331000FADA75 /* HTMLMediaElement.cpp in Sources */,
 				0779BF0D18453168000B6AE7 /* HTMLMediaElementMediaStream.cpp in Sources */,
 				07FE99DC18807A7D00256648 /* HTMLMediaSession.cpp in Sources */,
 				A8EA79F80A1916DF00A8EF5F /* HTMLMenuElement.cpp in Sources */,
 				2BE8E2C912A58A0100FAD550 /* HTMLMetaCharsetParser.cpp in Sources */,
 				A871DC270A15205700B12A68 /* HTMLMetaElement.cpp in Sources */,
+				C4E658021A98016800479C15 /* InspectorStyleRule.cpp in Sources */,
 				A454424A119B3661009BE912 /* HTMLMeterElement.cpp in Sources */,
 				A8CFF7A90A156978000A4234 /* HTMLModElement.cpp in Sources */,
 				A8DF3FD5097FA0FC0052981B /* HTMLNameCollection.cpp in Sources */,
 				A8D06B3A0A265DCD005E7203 /* HTMLNames.cpp in Sources */,
 				A871D45B0A127CBC00B12A68 /* HTMLObjectElement.cpp in Sources */,
 				A8EA79FB0A1916DF00A8EF5F /* HTMLOListElement.cpp in Sources */,
 				A81369DF097374F600D74463 /* HTMLOptGroupElement.cpp in Sources */,
 				A81369DD097374F600D74463 /* HTMLOptionElement.cpp in Sources */,
 				9327A94209968D1A0068A546 /* HTMLOptionsCollection.cpp in Sources */,
 				4AD01008127E642A0015035F /* HTMLOutputElement.cpp in Sources */,
@@ -28288,21 +28318,20 @@
 				6F995A211A7078B100A735F4 /* WebGLSampler.cpp in Sources */,
 				20D629261253690B00081543 /* InspectorInstrumentation.cpp in Sources */,
 				A5840E1C187B74D500843B10 /* InspectorInstrumentationCookie.cpp in Sources */,
 				71B1E1261640491A00B1880A /* InspectorLayerTreeAgent.cpp in Sources */,
 				504AACCD1834455900E3D9BC /* InspectorNodeFinder.cpp in Sources */,
 				26F0C89B1A2EC110002794F8 /* ContentExtensionRule.cpp in Sources */,
 				7C522D4B15B477E8009B7C95 /* InspectorOverlay.cpp in Sources */,
 				4F6FDD641341DEDD001F8EE3 /* InspectorPageAgent.cpp in Sources */,
 				99CC0B6618BE9F15006CEBCC /* InspectorReplayAgent.cpp in Sources */,
 				82AB1775125C826700C5069D /* InspectorResourceAgent.cpp in Sources */,
-				82AB1773125C826700C5069D /* InspectorStyleSheet.cpp in Sources */,
 				754133AA102E00F400075D00 /* InspectorTimelineAgent.cpp in Sources */,
 				F3810C1B1365A49600ED6E33 /* InspectorWorkerAgent.cpp in Sources */,
 				F350B73513F1377D00880C43 /* InstrumentingAgents.cpp in Sources */,
 				2D46F04E17B96FBD005647F0 /* IntPoint.cpp in Sources */,
 				B27535600B053814002CE64F /* IntPointCG.cpp in Sources */,
 				B275357C0B053814002CE64F /* IntPointMac.mm in Sources */,
 				B27535730B053814002CE64F /* IntRect.cpp in Sources */,
 				B27535610B053814002CE64F /* IntRectCG.cpp in Sources */,
 				B275357D0B053814002CE64F /* IntRectMac.mm in Sources */,
 				2D46F05017B96FD2005647F0 /* IntSize.cpp in Sources */,
@@ -28973,20 +29002,21 @@
 				49C7B9A21042D2D30009D447 /* JSWebGLShader.cpp in Sources */,
 				A07D3355152B630E001B6393 /* JSWebGLShaderPrecisionFormat.cpp in Sources */,
 				49C7B9A41042D2D30009D447 /* JSWebGLTexture.cpp in Sources */,
 				0C45342710CDBBFA00869157 /* JSWebGLUniformLocation.cpp in Sources */,
 				77EF62F312F9DB7400C77BD2 /* JSWebGLVertexArrayObjectOES.cpp in Sources */,
 				31C0FF3D0E4CEFAC007D6FE5 /* JSWebKitAnimationEvent.cpp in Sources */,
 				310603741432819C00ABF4BA /* JSWebKitCSSFilterValue.cpp in Sources */,
 				316FE0710E6CCBEE00BF6088 /* JSCSSKeyframeRule.cpp in Sources */,
 				316FE0730E6CCBEE00BF6088 /* JSCSSKeyframesRule.cpp in Sources */,
 				4983913F0F1E767500C23782 /* JSWebKitCSSMatrix.cpp in Sources */,
+				C4E657FA1A97FBED00479C15 /* InspectorInlineStyleRuleSet.cpp in Sources */,
 				8AD0A59414C88336000D83C5 /* JSWebKitCSSRegionRule.cpp in Sources */,
 				31611E5A0E1C4DE000F6A579 /* JSWebKitCSSTransformValue.cpp in Sources */,
 				3F2B33EE165AF15600E3987C /* JSWebKitCSSViewportRule.cpp in Sources */,
 				D7613AC414753E5600DB8606 /* JSWebKitNamedFlow.cpp in Sources */,
 				7CC69940191EC5F500AF2270 /* JSWebKitNamespace.cpp in Sources */,
 				0FDA7C261883333200C954B5 /* JSWebKitPlaybackTargetAvailabilityEvent.cpp in Sources */,
 				494BD79D0F55C94C00747828 /* JSWebKitPoint.cpp in Sources */,
 				BC275B7911C5D1C300C9206C /* JSWebKitPointCustom.cpp in Sources */,
 				31C0FF3F0E4CEFAC007D6FE5 /* JSWebKitTransitionEvent.cpp in Sources */,
 				5DA5E0FC102B953800088CF9 /* JSWebSocket.cpp in Sources */,
@@ -29353,20 +29383,21 @@
 				BCEA486D097D93020094C9E4 /* RenderDeprecatedFlexibleBox.cpp in Sources */,
 				D302754912A5FE84004BD828 /* RenderDetailsMarker.cpp in Sources */,
 				9B32CDAA13DF7FA900F34D13 /* RenderedPosition.cpp in Sources */,
 				E43A023D17EB3713004CDD25 /* RenderElement.cpp in Sources */,
 				0F5B7A5410F65D7A00376302 /* RenderEmbeddedObject.cpp in Sources */,
 				A8EA73C30A1900E300A8EF5F /* RenderFieldset.cpp in Sources */,
 				066C77300AB603FD00238CC4 /* RenderFileUploadControl.cpp in Sources */,
 				53C8298D13D8D92700DE2DEB /* RenderFlexibleBox.cpp in Sources */,
 				508CCA5013CF106B003151F3 /* RenderFlowThread.cpp in Sources */,
 				A871DED40A1530C700B12A68 /* RenderFrame.cpp in Sources */,
+				C4E657FF1A97FBED00479C15 /* InspectorStylesheetRuleSet.cpp in Sources */,
 				0FD3080E117CF7E700A791F7 /* RenderFrameBase.cpp in Sources */,
 				A871DED20A1530C700B12A68 /* RenderFrameSet.cpp in Sources */,
 				CDEA7C851276230400B846DD /* RenderFullScreen.cpp in Sources */,
 				0F3F0E59157030C3006DA57F /* RenderGeometryMap.cpp in Sources */,
 				BC128B01137C8D4600CAC845 /* RenderGrid.cpp in Sources */,
 				BCEA4869097D93020094C9E4 /* RenderHTMLCanvas.cpp in Sources */,
 				0FD308D5117D168500A791F7 /* RenderIFrame.cpp in Sources */,
 				BCEA4875097D93020094C9E4 /* RenderImage.cpp in Sources */,
 				08F2F0091213E61700DCEC48 /* RenderImageResource.cpp in Sources */,
 				08641D4712142F7D008DE9F6 /* RenderImageResourceStyleImage.cpp in Sources */,
@@ -29985,20 +30016,21 @@
 				FFAC30FF184FB145008C4F1E /* TrailingObjects.cpp in Sources */,
 				49E911C30EF86D47009D0CAF /* TransformationMatrix.cpp in Sources */,
 				494BC40D12AEDD9E00743BD2 /* TransformationMatrixCA.cpp in Sources */,
 				B27535580B053814002CE64F /* TransformationMatrixCG.cpp in Sources */,
 				FB484F4C171F821E00040755 /* TransformFunctions.cpp in Sources */,
 				49E911CF0EF86D47009D0CAF /* TransformOperations.cpp in Sources */,
 				5DB1BC6B10715A6400EFAA49 /* TransformSourceLibxslt.cpp in Sources */,
 				4198BDF01A81142200B22FB5 /* ReadableStreamJSSource.cpp in Sources */,
 				4945BFD313CF809000CC3B38 /* TransformState.cpp in Sources */,
 				E17B491516A9B094001C8839 /* TransitionEvent.cpp in Sources */,
+				C4E658041A984B5200479C15 /* InspectorStyleRuleSet.cpp in Sources */,
 				49E911D10EF86D47009D0CAF /* TranslateTransformOperation.cpp in Sources */,
 				854FE7360A2297BE0058D7AD /* Traversal.cpp in Sources */,
 				14D64B5C134A5B6B00E58FDA /* TreeScope.cpp in Sources */,
 				A77E1FEF14AACB6E005B7CB6 /* TreeScopeAdopter.cpp in Sources */,
 				854FE7380A2297BE0058D7AD /* TreeWalker.cpp in Sources */,
 				C375D7FD16639519006184AB /* TypeAhead.cpp in Sources */,
 				93309E19099E64920056E581 /* TypingCommand.cpp in Sources */,
 				85031B4D0A44EFC700F992E0 /* UIEvent.cpp in Sources */,
 				93354A3C0B24F8C9003F6DEA /* UIEventWithKeyState.cpp in Sources */,
 				AA4739D11757AFEC00E76767 /* UIRequestEvent.cpp in Sources */,
diff --git a/Source/WebCore/css/CSSComputedStyleDeclaration.h b/Source/WebCore/css/CSSComputedStyleDeclaration.h
index efdc157..42f291a 100644
--- a/Source/WebCore/css/CSSComputedStyleDeclaration.h
+++ b/Source/WebCore/css/CSSComputedStyleDeclaration.h
@@ -78,23 +78,23 @@ private:
     PassRefPtr<CSSValueList> getBackgroundShorthandValue() const;
     PassRefPtr<CSSValueList> getCSSPropertyValuesForGridShorthand(const StylePropertyShorthand&) const;
 
     RefPtr<Node> m_node;
     PseudoId m_pseudoElementSpecifier;
     bool m_allowVisitedStyle;
 };
 
 class CSSComputedStyleDeclaration final : public CSSStyleDeclaration {
 public:
-    static PassRefPtr<CSSComputedStyleDeclaration> create(PassRefPtr<Node> node, bool allowVisitedStyle = false, const String& pseudoElementName = String())
+    static Ref<CSSComputedStyleDeclaration> create(PassRefPtr<Node> node, bool allowVisitedStyle = false, const String& pseudoElementName = String())
     {
-        return adoptRef(new CSSComputedStyleDeclaration(node, allowVisitedStyle, pseudoElementName));
+        return adoptRef(*new CSSComputedStyleDeclaration(node, allowVisitedStyle, pseudoElementName));
     }
     virtual ~CSSComputedStyleDeclaration();
 
     WEBCORE_EXPORT virtual void ref() override;
     WEBCORE_EXPORT virtual void deref() override;
 
     String getPropertyValue(CSSPropertyID) const;
 
 private:
     WEBCORE_EXPORT CSSComputedStyleDeclaration(PassRefPtr<Node>, bool allowVisitedStyle, const String&);
diff --git a/Source/WebCore/css/CSSStyleSheet.h b/Source/WebCore/css/CSSStyleSheet.h
index d312eec..0daf21a 100644
--- a/Source/WebCore/css/CSSStyleSheet.h
+++ b/Source/WebCore/css/CSSStyleSheet.h
@@ -110,20 +110,21 @@ public:
 
     WhetherContentsWereClonedForMutation willMutateRules();
     void didMutateRules(RuleMutationType, WhetherContentsWereClonedForMutation, StyleRuleKeyframes* insertedKeyframesRule);
     void didMutateRuleFromCSSStyleDeclaration();
     void didMutate();
     
     void clearChildRuleCSSOMWrappers();
     void reattachChildRuleCSSOMWrappers();
 
     StyleSheetContents& contents() { return m_contents; }
+    const StyleSheetContents& contents() const { return m_contents; }
 
     void detachFromDocument() { m_ownerNode = nullptr; }
 
 private:
     CSSStyleSheet(Ref<StyleSheetContents>&&, CSSImportRule* ownerRule);
     CSSStyleSheet(Ref<StyleSheetContents>&&, Node* ownerNode, bool isInlineStylesheet);
 
     virtual bool isCSSStyleSheet() const override { return true; }
     virtual String type() const override { return ASCIILiteral("text/css"); }
 
diff --git a/Source/WebCore/inspector/InspectorCSSAgent.cpp b/Source/WebCore/inspector/InspectorCSSAgent.cpp
index 926302c..f277b55 100644
--- a/Source/WebCore/inspector/InspectorCSSAgent.cpp
+++ b/Source/WebCore/inspector/InspectorCSSAgent.cpp
@@ -20,48 +20,53 @@
  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "InspectorCSSAgent.h"
 
 #include "CSSComputedStyleDeclaration.h"
 #include "CSSImportRule.h"
+#include "CSSMediaRule.h"
 #include "CSSPropertyNames.h"
 #include "CSSPropertySourceData.h"
 #include "CSSRule.h"
 #include "CSSRuleList.h"
 #include "CSSStyleRule.h"
 #include "CSSStyleSheet.h"
 #include "ContentSecurityPolicy.h"
 #include "DOMWindow.h"
 #include "ExceptionCodePlaceholder.h"
 #include "HTMLHeadElement.h"
 #include "HTMLStyleElement.h"
 #include "InspectorDOMAgent.h"
 #include "InspectorPageAgent.h"
 #include "InspectorHistory.h"
+#include "InspectorInlineStyleRuleSet.h"
 #include "InspectorInstrumentation.h"
+#include "InspectorStyleRule.h"
 #include "InstrumentingAgents.h"
 #include "NamedFlowCollection.h"
 #include "Node.h"
 #include "NodeList.h"
 #include "RenderNamedFlowFragment.h"
 #include "SVGStyleElement.h"
 #include "SelectorChecker.h"
 #include "StyleProperties.h"
 #include "StylePropertyShorthand.h"
 #include "StyleResolver.h"
 #include "StyleRule.h"
 #include "StyleSheetList.h"
+#include "StyleSheetContents.h"
 #include "WebKitNamedFlow.h"
+#include <inspector/ContentSearchUtilities.h>
 #include <inspector/InspectorProtocolObjects.h>
 #include <wtf/HashSet.h>
 #include <wtf/Ref.h>
 #include <wtf/Vector.h>
 #include <wtf/text/CString.h>
 #include <wtf/text/StringConcatenate.h>
 
 using namespace Inspector;
 
 namespace WebCore {
@@ -144,212 +149,213 @@ void ChangeRegionOversetTask::reset()
 
 void ChangeRegionOversetTask::timerFired()
 {
     // The timer is stopped on m_cssAgent destruction, so this method will never be called after m_cssAgent has been destroyed.
     for (HashMap<WebKitNamedFlow*, int>::iterator it = m_namedFlows.begin(), end = m_namedFlows.end(); it != end; ++it)
         m_cssAgent->regionOversetChanged(it->key, it->value);
 
     m_namedFlows.clear();
 }
 
-class InspectorCSSAgent::StyleSheetAction : public InspectorHistory::Action {
-    WTF_MAKE_NONCOPYABLE(StyleSheetAction);
+class InspectorCSSAgent::StyleRuleSetAction : public InspectorHistory::Action {
+    WTF_MAKE_NONCOPYABLE(StyleRuleSetAction);
 public:
-    StyleSheetAction(const String& name, InspectorStyleSheet* styleSheet)
+    StyleRuleSetAction(const String& name, Ref<StyleRuleSet>&& ruleSet)
         : InspectorHistory::Action(name)
-        , m_styleSheet(styleSheet)
+        , m_ruleSet(WTF::move(ruleSet))
     {
     }
 
 protected:
-    RefPtr<InspectorStyleSheet> m_styleSheet;
+    Ref<StyleRuleSet> m_ruleSet;
 };
 
-class InspectorCSSAgent::SetStyleSheetTextAction final : public InspectorCSSAgent::StyleSheetAction {
+class InspectorCSSAgent::SetStyleSheetTextAction final : public InspectorCSSAgent::StyleRuleSetAction {
     WTF_MAKE_NONCOPYABLE(SetStyleSheetTextAction);
 public:
-    SetStyleSheetTextAction(InspectorStyleSheet* styleSheet, const String& text)
-        : InspectorCSSAgent::StyleSheetAction(ASCIILiteral("SetStyleSheetText"), styleSheet)
+    SetStyleSheetTextAction(Ref<StyleRuleSet>&& ruleSet, const String& text)
+        : InspectorCSSAgent::StyleRuleSetAction(ASCIILiteral("SetStyleSheetText"), WTF::move(ruleSet))
         , m_text(text)
     {
     }
 
     virtual bool perform(ExceptionCode& ec) override
     {
-        if (!m_styleSheet->getText(&m_oldText))
-            return false;
+        m_oldText = m_ruleSet->getText();
         return redo(ec);
     }
 
-    virtual bool undo(ExceptionCode& ec) override
+    virtual bool undo(ExceptionCode&) override
     {
-        if (m_styleSheet->setText(m_oldText, ec)) {
-            m_styleSheet->reparseStyleSheet(m_oldText);
-            return true;
-        }
-        return false;
+        m_ruleSet->replaceText(m_oldText);
+        return true;
     }
 
-    virtual bool redo(ExceptionCode& ec) override
+    virtual bool redo(ExceptionCode&) override
     {
-        if (m_styleSheet->setText(m_text, ec)) {
-            m_styleSheet->reparseStyleSheet(m_text);
-            return true;
-        }
-        return false;
+        m_ruleSet->replaceText(m_text);
+        return true;
     }
 
     virtual String mergeId() override
     {
-        return String::format("SetStyleSheetText %s", m_styleSheet->id().utf8().data());
+        return String::format("SetStyleSheetText %" PRIu64, m_ruleSet->identifier());
     }
 
-    virtual void merge(std::unique_ptr<Action> action) override
+    virtual void merge(std::unique_ptr<InspectorHistory::Action> action) override
     {
         ASSERT(action->mergeId() == mergeId());
 
         SetStyleSheetTextAction* other = static_cast<SetStyleSheetTextAction*>(action.get());
         m_text = other->m_text;
     }
 
 private:
     String m_text;
     String m_oldText;
 };
 
-class InspectorCSSAgent::SetStyleTextAction final : public InspectorCSSAgent::StyleSheetAction {
+class InspectorCSSAgent::SetStyleTextAction final : public InspectorCSSAgent::StyleRuleSetAction {
     WTF_MAKE_NONCOPYABLE(SetStyleTextAction);
 public:
-    SetStyleTextAction(InspectorStyleSheet* styleSheet, const InspectorCSSId& cssId, const String& text)
-        : InspectorCSSAgent::StyleSheetAction(ASCIILiteral("SetStyleText"), styleSheet)
+    SetStyleTextAction(Ref<StyleRuleSet>&& ruleSet, const CSSId& cssId, const String& text)
+        : InspectorCSSAgent::StyleRuleSetAction(ASCIILiteral("SetStyleText"), WTF::move(ruleSet))
         , m_cssId(cssId)
         , m_text(text)
     {
     }
 
     virtual bool perform(ExceptionCode& ec) override
     {
         return redo(ec);
     }
 
-    virtual bool undo(ExceptionCode& ec) override
+    virtual bool undo(ExceptionCode&) override
     {
-        return m_styleSheet->setStyleText(m_cssId, m_oldText, nullptr, ec);
+        String dummyOldText;
+        return m_ruleSet->setTextForStyle(m_cssId, m_oldText, dummyOldText);
     }
 
-    virtual bool redo(ExceptionCode& ec) override
+    virtual bool redo(ExceptionCode&) override
     {
-        return m_styleSheet->setStyleText(m_cssId, m_text, &m_oldText, ec);
+        return m_ruleSet->setTextForStyle(m_cssId, m_text, m_oldText);
     }
 
     virtual String mergeId() override
     {
-        ASSERT(m_styleSheet->id() == m_cssId.styleSheetId());
-        return String::format("SetStyleText %s:%u", m_styleSheet->id().utf8().data(), m_cssId.ordinal());
+        ASSERT(m_ruleSet->identifier() == m_cssId.stylesheetId());
+        return String::format("SetStyleText %" PRIu64 ":%" PRIu64, m_ruleSet->identifier(), m_cssId.ruleOrdinal());
     }
 
     virtual void merge(std::unique_ptr<Action> action) override
     {
         ASSERT(action->mergeId() == mergeId());
 
         SetStyleTextAction* other = static_cast<SetStyleTextAction*>(action.get());
         m_text = other->m_text;
     }
 
 private:
-    InspectorCSSId m_cssId;
+    CSSId m_cssId;
     String m_text;
     String m_oldText;
 };
 
-class InspectorCSSAgent::SetRuleSelectorAction final : public InspectorCSSAgent::StyleSheetAction {
+class InspectorCSSAgent::SetRuleSelectorAction final : public InspectorCSSAgent::StyleRuleSetAction {
     WTF_MAKE_NONCOPYABLE(SetRuleSelectorAction);
 public:
-    SetRuleSelectorAction(InspectorStyleSheet* styleSheet, const InspectorCSSId& cssId, const String& selector)
-        : InspectorCSSAgent::StyleSheetAction(ASCIILiteral("SetRuleSelector"), styleSheet)
+    SetRuleSelectorAction(Ref<StyleRuleSet>&& ruleSet, const CSSId& cssId, const String& selectorText)
+        : InspectorCSSAgent::StyleRuleSetAction(ASCIILiteral("SetRuleSelector"), WTF::move(ruleSet))
         , m_cssId(cssId)
-        , m_selector(selector)
+        , m_selectorText(selectorText)
     {
     }
 
     virtual bool perform(ExceptionCode& ec) override
     {
-        m_oldSelector = m_styleSheet->ruleSelector(m_cssId, ec);
-        if (ec)
+        if (!is<StylesheetRuleSet>(m_ruleSet))
             return false;
+
+        if (!downcast<StylesheetRuleSet>(m_ruleSet.get()).selectorTextForRule(m_cssId, m_oldSelectorText))
+            return false;
+
         return redo(ec);
     }
 
-    virtual bool undo(ExceptionCode& ec) override
+    virtual bool undo(ExceptionCode&) override
     {
-        return m_styleSheet->setRuleSelector(m_cssId, m_oldSelector, ec);
+        if (!is<StylesheetRuleSet>(m_ruleSet))
+            return false;
+
+        return downcast<StylesheetRuleSet>(m_ruleSet.get()).setSelectorTextForRule(m_cssId, m_oldSelectorText);
     }
 
-    virtual bool redo(ExceptionCode& ec) override
+    virtual bool redo(ExceptionCode&) override
     {
-        return m_styleSheet->setRuleSelector(m_cssId, m_selector, ec);
+        if (!is<StylesheetRuleSet>(m_ruleSet))
+            return false;
+
+        return downcast<StylesheetRuleSet>(m_ruleSet.get()).setSelectorTextForRule(m_cssId, m_selectorText);
     }
 
 private:
-    InspectorCSSId m_cssId;
-    String m_selector;
-    String m_oldSelector;
+    CSSId m_cssId;
+    String m_selectorText;
+    String m_oldSelectorText;
 };
 
-class InspectorCSSAgent::AddRuleAction final : public InspectorCSSAgent::StyleSheetAction {
+class InspectorCSSAgent::AddRuleAction final : public InspectorCSSAgent::StyleRuleSetAction {
     WTF_MAKE_NONCOPYABLE(AddRuleAction);
 public:
-    AddRuleAction(InspectorStyleSheet* styleSheet, const String& selector)
-        : InspectorCSSAgent::StyleSheetAction(ASCIILiteral("AddRule"), styleSheet)
+    AddRuleAction(Ref<StyleRuleSet>&& ruleSet, const String& selector)
+        : InspectorCSSAgent::StyleRuleSetAction(ASCIILiteral("AddRule"), WTF::move(ruleSet))
         , m_selector(selector)
     {
     }
 
     virtual bool perform(ExceptionCode& ec) override
     {
         return redo(ec);
     }
 
     virtual bool undo(ExceptionCode& ec) override
     {
-        return m_styleSheet->deleteRule(m_newId, ec);
+        if (!is<StylesheetRuleSet>(m_ruleSet))
+            return false;
+        
+        return downcast<StylesheetRuleSet>(m_ruleSet.get()).deleteRule(m_newId, ec);
     }
 
     virtual bool redo(ExceptionCode& ec) override
     {
-        CSSStyleRule* cssStyleRule = m_styleSheet->addRule(m_selector, ec);
-        if (ec)
+        if (!is<StylesheetRuleSet>(m_ruleSet))
+            return false;
+        
+        StylesheetRuleSet& ruleSet = downcast<StylesheetRuleSet>(m_ruleSet.get());
+        CSSStyleRule* cssStyleRule = ruleSet.addRule(m_selector, ec);
+        if (ec || !cssStyleRule)
             return false;
-        m_newId = m_styleSheet->ruleId(cssStyleRule);
+        m_newId = ruleSet.ruleId(*cssStyleRule);
         return true;
     }
 
-    InspectorCSSId newRuleId() { return m_newId; }
+    CSSId newRuleId() { return m_newId; }
 
 private:
-    InspectorCSSId m_newId;
+    CSSId m_newId;
     String m_selector;
     String m_oldSelector;
 };
 
-// static
-CSSStyleRule* InspectorCSSAgent::asCSSStyleRule(CSSRule& rule)
-{
-    if (!is<CSSStyleRule>(rule))
-        return nullptr;
-    return downcast<CSSStyleRule>(&rule);
-}
-
 InspectorCSSAgent::InspectorCSSAgent(InstrumentingAgents* instrumentingAgents, InspectorDOMAgent* domAgent)
     : InspectorAgentBase(ASCIILiteral("CSS"), instrumentingAgents)
     , m_domAgent(domAgent)
-    , m_lastStyleSheetId(1)
 {
     m_domAgent->setDOMListener(this);
 }
 
 InspectorCSSAgent::~InspectorCSSAgent()
 {
     ASSERT(!m_domAgent);
     reset();
 }
 
@@ -368,24 +374,24 @@ void InspectorCSSAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReaso
 }
 
 void InspectorCSSAgent::discardAgent()
 {
     m_domAgent->setDOMListener(nullptr);
     m_domAgent = nullptr;
 }
 
 void InspectorCSSAgent::reset()
 {
-    m_idToInspectorStyleSheet.clear();
-    m_cssStyleSheetToInspectorStyleSheet.clear();
-    m_nodeToInspectorStyleSheet.clear();
-    m_documentToInspectorStyleSheet.clear();
+    m_identifierToRuleSetMap.clear();
+    m_cssStyleSheetToRuleSetMap.clear();
+    m_nodeToInlineRuleSetMap.clear();
+    m_documentToInspectorRuleSetMap.clear();
     resetNonPersistentData();
 }
 
 void InspectorCSSAgent::resetNonPersistentData()
 {
     m_namedFlowCollectionsRequested.clear();
     if (m_changeRegionOversetTask)
         m_changeRegionOversetTask->reset();
     resetPseudoStates();
 }
@@ -537,159 +543,170 @@ void InspectorCSSAgent::getMatchedStylesForNode(ErrorString& errorString, int no
     if (!includeInherited || *includeInherited) {
         auto entries = Inspector::Protocol::Array<Inspector::Protocol::CSS::InheritedStyleEntry>::create();
         Element* parentElement = element->parentElement();
         while (parentElement) {
             StyleResolver& parentStyleResolver = parentElement->document().ensureStyleResolver();
             auto parentMatchedRules = parentStyleResolver.styleRulesForElement(parentElement, StyleResolver::AllCSSRules);
             auto entry = Inspector::Protocol::CSS::InheritedStyleEntry::create()
                 .setMatchedCSSRules(buildArrayForMatchedRuleList(parentMatchedRules, styleResolver, parentElement))
                 .release();
             if (parentElement->style() && parentElement->style()->length()) {
-                InspectorStyleSheetForInlineStyle* styleSheet = asInspectorStyleSheet(parentElement);
-                if (styleSheet)
-                    entry->setInlineStyle(styleSheet->buildObjectForStyle(styleSheet->styleForId(InspectorCSSId(styleSheet->id(), 0))));
+                InlineStyleRuleSet* ruleSet = asInlineRuleSet(*parentElement);
+                CSSStyleDeclaration* style = ruleSet ? ruleSet->inlineStyle() : nullptr;
+                if (style)
+                    entry->setInlineStyle(ruleSet->buildObjectForStyle(*style));
             }
 
             entries->addItem(WTF::move(entry));
             parentElement = parentElement->parentElement();
         }
 
         inheritedEntries = WTF::move(entries);
     }
 }
 
-void InspectorCSSAgent::getInlineStylesForNode(ErrorString& errorString, int nodeId, RefPtr<Inspector::Protocol::CSS::CSSStyle>& inlineStyle, RefPtr<Inspector::Protocol::CSS::CSSStyle>& attributesStyle)
+void InspectorCSSAgent::getInlineStylesForNode(ErrorString& errorString, int nodeId, RefPtr<Inspector::Protocol::CSS::CSSStyle>& inlineStyleObject, RefPtr<Inspector::Protocol::CSS::CSSStyle>& attributesStyleObject)
 {
     Element* element = elementForId(errorString, nodeId);
     if (!element)
         return;
 
-    InspectorStyleSheetForInlineStyle* styleSheet = asInspectorStyleSheet(element);
-    if (!styleSheet)
+    InlineStyleRuleSet* ruleSet = asInlineRuleSet(*element);
+    if (!ruleSet)
+        return;
+
+    CSSStyleDeclaration* style = element->style();
+    if (!style)
         return;
 
-    inlineStyle = styleSheet->buildObjectForStyle(element->style());
-    RefPtr<Inspector::Protocol::CSS::CSSStyle> attributes = buildObjectForAttributesStyle(element);
-    attributesStyle = attributes ? attributes.release() : nullptr;
+    inlineStyleObject = ruleSet->buildObjectForStyle(*style);
+    attributesStyleObject = buildObjectForAttributesStyle(*element);
 }
 
 void InspectorCSSAgent::getComputedStyleForNode(ErrorString& errorString, int nodeId, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>>& style)
 {
     Element* element = elementForId(errorString, nodeId);
     if (!element)
         return;
 
-    RefPtr<CSSComputedStyleDeclaration> computedStyleInfo = CSSComputedStyleDeclaration::create(element, true);
-    Ref<InspectorStyle> inspectorStyle = InspectorStyle::create(InspectorCSSId(), computedStyleInfo, nullptr);
-    style = inspectorStyle->buildArrayForComputedStyle();
+    Ref<CSSComputedStyleDeclaration> computedStyle = CSSComputedStyleDeclaration::create(element, true);
+    Ref<Inspector::StyleRule> styleRule = Inspector::StyleRule::create(CSSId(), WTF::move(computedStyle), nullptr);
+    style = styleRule->buildArrayForComputedStyle();
 }
 
 void InspectorCSSAgent::getAllStyleSheets(ErrorString&, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSStyleSheetHeader>>& styleInfos)
 {
     styleInfos = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSStyleSheetHeader>::create();
     Vector<Document*> documents = m_domAgent->documents();
     for (Vector<Document*>::iterator it = documents.begin(); it != documents.end(); ++it) {
         StyleSheetList& list = (*it)->styleSheets();
         for (unsigned i = 0; i < list.length(); ++i) {
             StyleSheet& styleSheet = *list.item(i);
             if (is<CSSStyleSheet>(styleSheet))
                 collectStyleSheets(downcast<CSSStyleSheet>(styleSheet), *styleInfos);
         }
     }
 }
 
-void InspectorCSSAgent::getStyleSheet(ErrorString& errorString, const String& styleSheetId, RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody>& styleSheetObject)
+void InspectorCSSAgent::getStyleSheet(ErrorString& errorString, Inspector::Protocol::CSS::StyleSheetId stylesheetId, RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody>& styleSheetObject)
 {
-    InspectorStyleSheet* inspectorStyleSheet = assertStyleSheetForId(errorString, styleSheetId);
-    if (!inspectorStyleSheet)
+    StyleRuleSet* ruleSet = ruleSetForStylesheetId(errorString, stylesheetId);
+    if (!is<StylesheetRuleSet>(ruleSet))
         return;
 
-    styleSheetObject = inspectorStyleSheet->buildObjectForStyleSheet();
+    styleSheetObject = downcast<StylesheetRuleSet>(ruleSet)->buildObjectForStyleSheet();
 }
 
-void InspectorCSSAgent::getStyleSheetText(ErrorString& errorString, const String& styleSheetId, String* result)
+void InspectorCSSAgent::getStyleSheetText(ErrorString& errorString, Inspector::Protocol::CSS::StyleSheetId stylesheetId, String* result)
 {
-    InspectorStyleSheet* inspectorStyleSheet = assertStyleSheetForId(errorString, styleSheetId);
-    if (!inspectorStyleSheet)
+    StyleRuleSet* ruleSet = ruleSetForStylesheetId(errorString, stylesheetId);
+    if (!is<StylesheetRuleSet>(ruleSet))
         return;
 
-    inspectorStyleSheet->getText(result);
+    *result = ruleSet->getText();
 }
 
-void InspectorCSSAgent::setStyleSheetText(ErrorString& errorString, const String& styleSheetId, const String& text)
+void InspectorCSSAgent::setStyleSheetText(ErrorString& errorString, Inspector::Protocol::CSS::StyleSheetId stylesheetId, const String& text)
 {
-    InspectorStyleSheet* inspectorStyleSheet = assertStyleSheetForId(errorString, styleSheetId);
-    if (!inspectorStyleSheet)
+    StyleRuleSet* ruleSet = ruleSetForStylesheetId(errorString, stylesheetId);
+    if (!ruleSet)
         return;
 
     ExceptionCode ec = 0;
-    m_domAgent->history()->perform(std::make_unique<SetStyleSheetTextAction>(inspectorStyleSheet, text), ec);
+    m_domAgent->history()->perform(std::make_unique<SetStyleSheetTextAction>(*ruleSet, text), ec);
     errorString = InspectorDOMAgent::toErrorString(ec);
 }
 
-void InspectorCSSAgent::setStyleText(ErrorString& errorString, const RefPtr<InspectorObject>&& fullStyleId, const String& text, RefPtr<Inspector::Protocol::CSS::CSSStyle>& result)
+void InspectorCSSAgent::setStyleText(ErrorString& errorString, const RefPtr<InspectorObject>&& styleIdObject, const String& text, RefPtr<Inspector::Protocol::CSS::CSSStyle>& result)
 {
-    InspectorCSSId compoundId(fullStyleId.copyRef());
-    ASSERT(!compoundId.isEmpty());
+    CSSId styleId(styleIdObject.copyRef());
+    ASSERT(!styleId.isEmpty());
 
-    InspectorStyleSheet* inspectorStyleSheet = assertStyleSheetForId(errorString, compoundId.styleSheetId());
-    if (!inspectorStyleSheet)
+    StyleRuleSet* ruleSet = ruleSetForStylesheetId(errorString, styleId.stylesheetId());
+    if (!ruleSet)
         return;
 
     ExceptionCode ec = 0;
-    bool success = m_domAgent->history()->perform(std::make_unique<SetStyleTextAction>(inspectorStyleSheet, compoundId, text), ec);
-    if (success)
-        result = inspectorStyleSheet->buildObjectForStyle(inspectorStyleSheet->styleForId(compoundId));
+    bool success = m_domAgent->history()->perform(std::make_unique<SetStyleTextAction>(*ruleSet, styleId, text), ec);
+
+    if (success) {
+        if (CSSStyleDeclaration* style = ruleSet->styleForId(styleId))
+            result = ruleSet->buildObjectForStyle(*style);
+    }
     errorString = InspectorDOMAgent::toErrorString(ec);
 }
 
-void InspectorCSSAgent::setRuleSelector(ErrorString& errorString, const RefPtr<InspectorObject>&& fullRuleId, const String& selector, RefPtr<Inspector::Protocol::CSS::CSSRule>& result)
+void InspectorCSSAgent::setRuleSelector(ErrorString& errorString, const RefPtr<InspectorObject>&& ruleIdObject, const String& selectorText, RefPtr<Inspector::Protocol::CSS::CSSRule>& result)
 {
-    InspectorCSSId compoundId(fullRuleId.copyRef());
-    ASSERT(!compoundId.isEmpty());
+    CSSId ruleId(ruleIdObject.copyRef());
+    ASSERT(!ruleId.isEmpty());
 
-    InspectorStyleSheet* inspectorStyleSheet = assertStyleSheetForId(errorString, compoundId.styleSheetId());
-    if (!inspectorStyleSheet)
+    StyleRuleSet* ruleSet = ruleSetForStylesheetId(errorString, ruleId.stylesheetId());
+    if (!is<StylesheetRuleSet>(ruleSet))
         return;
 
+    StylesheetRuleSet& stylesheetRuleSet = downcast<StylesheetRuleSet>(*ruleSet);
+    
     ExceptionCode ec = 0;
-    bool success = m_domAgent->history()->perform(std::make_unique<SetRuleSelectorAction>(inspectorStyleSheet, compoundId, selector), ec);
+    if (!m_domAgent->history()->perform(std::make_unique<SetRuleSelectorAction>(stylesheetRuleSet, ruleId, selectorText), ec)) {
+        errorString = InspectorDOMAgent::toErrorString(ec);
+        return;
+    }
 
-    if (success)
-        result = inspectorStyleSheet->buildObjectForRule(inspectorStyleSheet->ruleForId(compoundId), nullptr);
-    errorString = InspectorDOMAgent::toErrorString(ec);
+    if (CSSStyleRule* styleRule = stylesheetRuleSet.ruleForId(ruleId))
+        result = WebCore::buildObjectForStyleRule(*styleRule, stylesheetRuleSet, nullptr);
 }
 
-void InspectorCSSAgent::addRule(ErrorString& errorString, const int contextNodeId, const String& selector, RefPtr<Inspector::Protocol::CSS::CSSRule>& result)
+void InspectorCSSAgent::addRule(ErrorString& errorString, const int contextNodeId, const String& selectorText, RefPtr<Inspector::Protocol::CSS::CSSRule>& result)
 {
     Node* node = m_domAgent->assertNode(errorString, contextNodeId);
     if (!node)
         return;
 
-    InspectorStyleSheet* inspectorStyleSheet = viaInspectorStyleSheet(&node->document(), true);
-    if (!inspectorStyleSheet) {
+    StylesheetRuleSet* ruleSet = inspectorRuleSetForDocument(node->document(), true);
+    if (!ruleSet) {
         errorString = ASCIILiteral("No target stylesheet found");
         return;
     }
 
     ExceptionCode ec = 0;
-    auto action = std::make_unique<AddRuleAction>(inspectorStyleSheet, selector);
+    auto action = std::make_unique<AddRuleAction>(*ruleSet, selectorText);
     AddRuleAction* rawAction = action.get();
     bool success = m_domAgent->history()->perform(WTF::move(action), ec);
     if (!success) {
         errorString = InspectorDOMAgent::toErrorString(ec);
         return;
     }
 
-    InspectorCSSId ruleId = rawAction->newRuleId();
-    CSSStyleRule* rule = inspectorStyleSheet->ruleForId(ruleId);
-    result = inspectorStyleSheet->buildObjectForRule(rule, nullptr);
+    CSSId ruleId = rawAction->newRuleId();
+    if (CSSStyleRule* rule = ruleSet->ruleForId(ruleId))
+        result = WebCore::buildObjectForStyleRule(*rule, *ruleSet, nullptr);
 }
 
 void InspectorCSSAgent::getSupportedCSSProperties(ErrorString&, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSPropertyInfo>>& cssProperties)
 {
     auto properties = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSPropertyInfo>::create();
     for (int i = firstCSSProperty; i <= lastCSSProperty; ++i) {
         CSSPropertyID id = convertToCSSPropertyID(i);
         auto property = Inspector::Protocol::CSS::CSSPropertyInfo::create()
             .setName(getPropertyNameString(id))
             .release();
@@ -740,36 +757,33 @@ void InspectorCSSAgent::getNamedFlowCollection(ErrorString& errorString, int doc
 
     Vector<RefPtr<WebKitNamedFlow>> namedFlowsVector = document->namedFlows().namedFlows();
     auto namedFlows = Inspector::Protocol::Array<Inspector::Protocol::CSS::NamedFlow>::create();
 
     for (Vector<RefPtr<WebKitNamedFlow>>::iterator it = namedFlowsVector.begin(); it != namedFlowsVector.end(); ++it)
         namedFlows->addItem(buildObjectForNamedFlow(errorString, it->get(), documentNodeId));
 
     result = WTF::move(namedFlows);
 }
 
-InspectorStyleSheetForInlineStyle* InspectorCSSAgent::asInspectorStyleSheet(Element* element)
+InlineStyleRuleSet* InspectorCSSAgent::asInlineRuleSet(Element& element)
 {
-    NodeToInspectorStyleSheet::iterator it = m_nodeToInspectorStyleSheet.find(element);
-    if (it == m_nodeToInspectorStyleSheet.end()) {
-        CSSStyleDeclaration* style = element->isStyledElement() ? element->style() : nullptr;
-        if (!style)
-            return nullptr;
+    auto findResult = m_nodeToInlineRuleSetMap.find(&element);
+    if (findResult != m_nodeToInlineRuleSetMap.end())
+        return findResult->value.get();
 
-        String newStyleSheetId = String::number(m_lastStyleSheetId++);
-        RefPtr<InspectorStyleSheetForInlineStyle> inspectorStyleSheet = InspectorStyleSheetForInlineStyle::create(newStyleSheetId, element, StyleSheetOrigin::Author, this);
-        m_idToInspectorStyleSheet.set(newStyleSheetId, inspectorStyleSheet);
-        m_nodeToInspectorStyleSheet.set(element, inspectorStyleSheet);
-        return inspectorStyleSheet.get();
-    }
+    if (!element.isStyledElement())
+        return nullptr;
 
-    return it->value.get();
+    RefPtr<InlineStyleRuleSet> inlineStyle = InlineStyleRuleSet::create(element);
+    m_identifierToRuleSetMap.set(inlineStyle->identifier(), inlineStyle);
+    m_nodeToInlineRuleSetMap.set(&element, inlineStyle);
+    return inlineStyle.get();
 }
 
 Element* InspectorCSSAgent::elementForId(ErrorString& errorString, int nodeId)
 {
     Node* node = m_domAgent->nodeForId(nodeId);
     if (!node) {
         errorString = ASCIILiteral("No node with given id found");
         return nullptr;
     }
     if (!is<Element>(*node)) {
@@ -781,180 +795,337 @@ Element* InspectorCSSAgent::elementForId(ErrorString& errorString, int nodeId)
 
 int InspectorCSSAgent::documentNodeWithRequestedFlowsId(Document* document)
 {
     int documentNodeId = m_domAgent->boundNodeId(document);
     if (!documentNodeId || !m_namedFlowCollectionsRequested.contains(documentNodeId))
         return 0;
 
     return documentNodeId;
 }
 
-static Ref<Inspector::Protocol::CSS::CSSStyleSheetHeader> buildObjectForStyleSheetInfo(InspectorStyleSheet& sheet)
+static Ref<Inspector::Protocol::CSS::CSSStyleSheetHeader> buildObjectForStyleSheetInfo(StylesheetRuleSet& stylesheet)
 {
     String frameId = ASCIILiteral("(Unknown)");
-    Document* document = sheet.ownerDocument();
+    Document* document = stylesheet.ownerDocument();
     Frame* frame = document ? document->frame() : nullptr;
     if (InstrumentingAgents* instrumentingAgents = InspectorInstrumentation::instrumentingAgentsForFrame(frame))
         if (InspectorPageAgent* pageAgent = instrumentingAgents->inspectorPageAgent())
             frameId = pageAgent->frameId(frame);
-    
+
     return Inspector::Protocol::CSS::CSSStyleSheetHeader::create()
-    .setStyleSheetId(sheet.id())
-    .setOrigin(stylesheetOriginToProtocolEnum(sheet.origin()))
-    .setDisabled(!sheet.isEnabled())
-    .setSourceURL(sheet.finalURL())
-    .setTitle(sheet.title())
+    .setStyleSheetId(stylesheet.identifier())
+    .setOrigin(stylesheetOriginToProtocolEnum(stylesheet.origin()))
+    .setDisabled(!stylesheet.isEnabled())
+    .setSourceURL(stylesheet.finalURL())
+    .setTitle(stylesheet.title())
     .setFrameId(frameId)
     .release();
 }
 
-void InspectorCSSAgent::collectStyleSheets(CSSStyleSheet& styleSheet, Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSStyleSheetHeader>& result)
+void InspectorCSSAgent::collectStyleSheets(CSSStyleSheet& stylesheet, Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSStyleSheetHeader>& result)
 {
-    if (InspectorStyleSheet* inspectorStyleSheet = bindStyleSheet(&styleSheet))
-        result.addItem(buildObjectForStyleSheetInfo(*inspectorStyleSheet));
+    StylesheetRuleSet& ruleSet = bindStyleSheet(stylesheet);
+    result.addItem(buildObjectForStyleSheetInfo(ruleSet));
 
-    for (unsigned i = 0, size = styleSheet.length(); i < size; ++i) {
-        CSSRule* rule = styleSheet.item(i);
+    for (unsigned i = 0, size = stylesheet.length(); i < size; ++i) {
+        CSSRule* rule = stylesheet.item(i);
         if (!is<CSSImportRule>(rule))
             continue;
-        
-        if (CSSStyleSheet* importedStyleSheet = downcast<CSSImportRule>(*rule).styleSheet())
-            collectStyleSheets(*importedStyleSheet, result);
+
+        if (CSSStyleSheet* importedStylesheet = downcast<CSSImportRule>(*rule).styleSheet())
+            collectStyleSheets(*importedStylesheet, result);
     }
 }
 
-InspectorStyleSheet* InspectorCSSAgent::bindStyleSheet(CSSStyleSheet* styleSheet)
+StylesheetRuleSet& InspectorCSSAgent::bindStyleSheet(CSSStyleSheet& stylesheet)
 {
-    RefPtr<InspectorStyleSheet> inspectorStyleSheet = m_cssStyleSheetToInspectorStyleSheet.get(styleSheet);
-    if (!inspectorStyleSheet) {
-        String id = String::number(m_lastStyleSheetId++);
-        Document* document = styleSheet->ownerDocument();
-        inspectorStyleSheet = InspectorStyleSheet::create(id, styleSheet, detectOrigin(styleSheet, document), InspectorDOMAgent::documentURLString(document), this);
-        m_idToInspectorStyleSheet.set(id, inspectorStyleSheet);
-        m_cssStyleSheetToInspectorStyleSheet.set(styleSheet, inspectorStyleSheet);
-    }
-    return inspectorStyleSheet.get();
+    auto findResult = m_cssStyleSheetToRuleSetMap.find(&stylesheet);
+    if (findResult != m_cssStyleSheetToRuleSetMap.end())
+        return *findResult->value;
+
+    Document* document = stylesheet.ownerDocument();
+    RefPtr<StylesheetRuleSet> ruleSet = StylesheetRuleSet::create(stylesheet, detectOrigin(stylesheet, document), InspectorDOMAgent::documentURLString(document), this);
+    m_identifierToRuleSetMap.set(ruleSet->identifier(), ruleSet);
+    m_cssStyleSheetToRuleSetMap.set(&stylesheet, ruleSet);
+    return *ruleSet;
 }
 
-InspectorStyleSheet* InspectorCSSAgent::viaInspectorStyleSheet(Document* document, bool createIfAbsent)
+StylesheetRuleSet* InspectorCSSAgent::inspectorRuleSetForDocument(Document& document, bool createIfAbsent)
 {
-    if (!document) {
-        ASSERT(!createIfAbsent);
-        return nullptr;
-    }
-
-    if (!document->isHTMLDocument() && !document->isSVGDocument())
+    if (!document.isHTMLDocument() && !document.isSVGDocument())
         return nullptr;
 
-    RefPtr<InspectorStyleSheet> inspectorStyleSheet = m_documentToInspectorStyleSheet.get(document);
-    if (inspectorStyleSheet || !createIfAbsent)
-        return inspectorStyleSheet.get();
+    RefPtr<StylesheetRuleSet> ruleSet = m_documentToInspectorRuleSetMap.get(&document);
+    if (ruleSet || !createIfAbsent)
+        return ruleSet.get();
 
     ExceptionCode ec = 0;
-    RefPtr<Element> styleElement = document->createElement("style", ec);
+    RefPtr<Element> styleElement = document.createElement("style", ec);
     if (!ec)
         styleElement->setAttribute("type", "text/css", ec);
     if (!ec) {
         ContainerNode* targetNode;
         // HEAD is absent in ImageDocuments, for example.
-        if (auto* head = document->head())
+        if (auto* head = document.head())
             targetNode = head;
-        else if (auto* body = document->bodyOrFrameset())
+        else if (auto* body = document.bodyOrFrameset())
             targetNode = body;
         else
             return nullptr;
 
-        InlineStyleOverrideScope overrideScope(document);
+        InlineStyleOverrideScope overrideScope(&document);
         targetNode->appendChild(styleElement, ec);
     }
     if (ec)
         return nullptr;
 
-    CSSStyleSheet* cssStyleSheet = nullptr;
+    CSSStyleSheet* stylesheet = nullptr;
     if (styleElement->isHTMLElement())
-        cssStyleSheet = downcast<HTMLStyleElement>(*styleElement).sheet();
+        stylesheet = downcast<HTMLStyleElement>(*styleElement).sheet();
     else if (styleElement->isSVGElement())
-        cssStyleSheet = downcast<SVGStyleElement>(*styleElement).sheet();
+        stylesheet = downcast<SVGStyleElement>(*styleElement).sheet();
 
-    if (!cssStyleSheet)
+    if (!stylesheet)
         return nullptr;
 
-    String id = String::number(m_lastStyleSheetId++);
-    inspectorStyleSheet = InspectorStyleSheet::create(id, cssStyleSheet, StyleSheetOrigin::Inspector, InspectorDOMAgent::documentURLString(document), this);
-    m_idToInspectorStyleSheet.set(id, inspectorStyleSheet);
-    m_cssStyleSheetToInspectorStyleSheet.set(cssStyleSheet, inspectorStyleSheet);
-    m_documentToInspectorStyleSheet.set(document, inspectorStyleSheet);
-    return inspectorStyleSheet.get();
+    RefPtr<StylesheetRuleSet> newRuleSet = StylesheetRuleSet::create(*stylesheet, StyleSheetOrigin::Inspector, InspectorDOMAgent::documentURLString(&document), this);
+    m_identifierToRuleSetMap.set(newRuleSet->identifier(), newRuleSet);
+    m_cssStyleSheetToRuleSetMap.set(stylesheet, newRuleSet);
+    m_documentToInspectorRuleSetMap.set(&document, newRuleSet);
+    return newRuleSet.get();
 }
 
-InspectorStyleSheet* InspectorCSSAgent::assertStyleSheetForId(ErrorString& errorString, const String& styleSheetId)
+StyleRuleSet* InspectorCSSAgent::ruleSetForStylesheetId(ErrorString& errorString, Inspector::Protocol::CSS::StyleSheetId stylesheetId)
 {
-    IdToInspectorStyleSheet::iterator it = m_idToInspectorStyleSheet.find(styleSheetId);
-    if (it == m_idToInspectorStyleSheet.end()) {
-        errorString = ASCIILiteral("No style sheet with given id found");
+    if (stylesheetId <= 0) {
+        errorString = ASCIILiteral("Invalid idenifier for stylesheet.");
         return nullptr;
     }
-    return it->value.get();
+
+    uint64_t key = static_cast<uint64_t>(stylesheetId);
+    auto findResult = m_identifierToRuleSetMap.find(key);
+    if (findResult == m_identifierToRuleSetMap.end()) {
+        errorString = ASCIILiteral("No stylesheet with given id found");
+        return nullptr;
+    }
+    return findResult->value.get();
 }
 
-StyleSheetOrigin InspectorCSSAgent::detectOrigin(CSSStyleSheet* pageStyleSheet, Document* ownerDocument)
+StyleSheetOrigin InspectorCSSAgent::detectOrigin(CSSStyleSheet& stylesheet, Document* ownerDocument)
 {
-    if (!pageStyleSheet)
-        return StyleSheetOrigin::Author;
-
-    Node* ownerNode = pageStyleSheet->ownerNode();
-    if (!ownerNode && pageStyleSheet->href().isEmpty())
+    Node* ownerNode = stylesheet.ownerNode();
+    if (!ownerNode && stylesheet.href().isEmpty())
         return StyleSheetOrigin::UserAgent;
 
     if (ownerNode && ownerNode->nodeName() == "#document")
         return StyleSheetOrigin::User;
 
-    InspectorStyleSheet* injectedStylesheet = viaInspectorStyleSheet(ownerDocument, false);
-    if (injectedStylesheet && pageStyleSheet == injectedStylesheet->pageStyleSheet())
+    StylesheetRuleSet* inspectorRuleSet = ownerDocument ? inspectorRuleSetForDocument(*ownerDocument, false) : nullptr;
+    if (inspectorRuleSet && &inspectorRuleSet->pageStyleSheet()== &stylesheet)
         return StyleSheetOrigin::Inspector;
 
     return StyleSheetOrigin::Author;
 }
 
-RefPtr<Inspector::Protocol::CSS::CSSRule> InspectorCSSAgent::buildObjectForRule(StyleRule* styleRule, StyleResolver& styleResolver, Element* element)
+// Code for translating between inspector CSS wrappers and inspector protocol.
+// TODO: almost all of the build*Object and *ToProtocolEnum functions should be static.
+
+Inspector::Protocol::CSS::StyleSheetOrigin stylesheetOriginToProtocolEnum(StyleSheetOrigin origin)
 {
-    if (!styleRule)
-        return nullptr;
+    switch (origin) {
+    case StyleSheetOrigin::Inspector:
+        return Inspector::Protocol::CSS::StyleSheetOrigin::Inspector;
+    case StyleSheetOrigin::UserAgent:
+        return Inspector::Protocol::CSS::StyleSheetOrigin::UserAgent;
+    case StyleSheetOrigin::User:
+        return Inspector::Protocol::CSS::StyleSheetOrigin::User;
+    case StyleSheetOrigin::Author:
+        return Inspector::Protocol::CSS::StyleSheetOrigin::Regular;
+    default:
+        ASSERT_NOT_REACHED();
+        return Inspector::Protocol::CSS::StyleSheetOrigin::Regular;
+    }
+}
 
+Inspector::Protocol::CSS::CSSMedia::Source mediaListSourceToProtocolEnum(MediaListSource source)
+{
+    switch (source) {
+    case MediaListSource::MediaRule:
+        return Inspector::Protocol::CSS::CSSMedia::Source::MediaRule;
+    case MediaListSource::ImportRule:
+        return Inspector::Protocol::CSS::CSSMedia::Source::ImportRule;
+        break;
+    case MediaListSource::LinkedSheet:
+        return Inspector::Protocol::CSS::CSSMedia::Source::LinkedSheet;
+        break;
+    case MediaListSource::InlineSheet:
+        return Inspector::Protocol::CSS::CSSMedia::Source::InlineSheet;
+        break;
+    default:
+        ASSERT_NOT_REACHED();
+        return Inspector::Protocol::CSS::CSSMedia::Source::InlineSheet;
+    }
+}
+
+RefPtr<Inspector::Protocol::CSS::SourceRange> buildSourceRangeObject(const SourceRange& range, Vector<size_t>& lineEndings)
+{
+    TextPosition start = ContentSearchUtilities::textPositionFromOffset(range.start, lineEndings);
+    TextPosition end = ContentSearchUtilities::textPositionFromOffset(range.end, lineEndings);
+
+    return Inspector::Protocol::CSS::SourceRange::create()
+        .setStartLine(start.m_line.zeroBasedInt())
+        .setStartColumn(start.m_column.zeroBasedInt())
+        .setEndLine(end.m_line.zeroBasedInt())
+        .setEndColumn(end.m_column.zeroBasedInt())
+        .release();
+}
+
+Ref<Inspector::Protocol::CSS::CSSMedia> buildMediaObject(const MediaList& media, MediaListSource mediaListSource, const String& sourceURL)
+{
+    auto mediaObject = Inspector::Protocol::CSS::CSSMedia::create()
+        .setText(media.mediaText())
+        .setSource(mediaListSourceToProtocolEnum(mediaListSource))
+        .release();
+
+    if (!sourceURL.isEmpty()) {
+        mediaObject->setSourceURL(sourceURL);
+        mediaObject->setSourceLine(media.queries()->lastLine());
+    }
+    return WTF::move(mediaObject);
+}
+
+void fillMediaListChain(CSSRule& rule, Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSMedia>& mediaArray)
+{
+    MediaList* mediaList;
+    CSSRule* parentRule = &rule;
+    String sourceURL;
+    while (parentRule) {
+        CSSStyleSheet* parentStyleSheet = nullptr;
+        bool isMediaRule = true;
+        if (is<CSSMediaRule>(*parentRule)) {
+            CSSMediaRule& mediaRule = downcast<CSSMediaRule>(*parentRule);
+            mediaList = mediaRule.media();
+            parentStyleSheet = mediaRule.parentStyleSheet();
+        } else if (is<CSSImportRule>(*parentRule)) {
+            CSSImportRule& importRule = downcast<CSSImportRule>(*parentRule);
+            mediaList = &importRule.media();
+            parentStyleSheet = importRule.parentStyleSheet();
+            isMediaRule = false;
+        } else
+            mediaList = nullptr;
+
+        if (parentStyleSheet) {
+            sourceURL = parentStyleSheet->contents().baseURL();
+            if (sourceURL.isEmpty())
+                sourceURL = InspectorDOMAgent::documentURLString(parentStyleSheet->ownerDocument());
+        } else
+            sourceURL = "";
+
+        if (mediaList && mediaList->length())
+            mediaArray.addItem(buildMediaObject(*mediaList, isMediaRule ? MediaListSource::MediaRule : MediaListSource::ImportRule, sourceURL));
+
+        if (parentRule->parentRule())
+            parentRule = parentRule->parentRule();
+        else {
+            CSSStyleSheet* styleSheet = parentRule->parentStyleSheet();
+            while (styleSheet) {
+                mediaList = styleSheet->media();
+                if (mediaList && mediaList->length()) {
+                    Document* doc = styleSheet->ownerDocument();
+                    if (doc)
+                        sourceURL = doc->url();
+                    else if (!styleSheet->contents().baseURL().isEmpty())
+                        sourceURL = styleSheet->contents().baseURL();
+                    else
+                        sourceURL = "";
+                    mediaArray.addItem(buildMediaObject(*mediaList, styleSheet->ownerNode() ? MediaListSource::LinkedSheet : MediaListSource::InlineSheet, sourceURL));
+                }
+                parentRule = styleSheet->ownerRule();
+                if (parentRule)
+                    break;
+                styleSheet = styleSheet->parentStyleSheet();
+            }
+        }
+    }
+}
+
+Ref<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSRule>> buildArrayForRuleList(StyleRuleList& ruleList, StylesheetRuleSet& stylesheet)
+{
+    auto result = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSRule>::create();
+    for (auto& rule : ruleList) {
+        if (!rule)
+            continue;
+
+        result->addItem(buildObjectForStyleRule(*rule, stylesheet, nullptr));
+    }
+    return WTF::move(result);
+}
+
+RefPtr<Inspector::Protocol::CSS::CSSRule> buildObjectForStyleRule(CSSStyleRule& rule, StylesheetRuleSet& stylesheet, Element* element)
+{
+    auto result = Inspector::Protocol::CSS::CSSRule::create()
+        .setSelectorList(stylesheet.buildObjectForSelectorList(rule, element))
+        .setSourceLine(rule.styleRule().sourceLine())
+        .setOrigin(stylesheetOriginToProtocolEnum(stylesheet.origin()))
+        .setStyle(stylesheet.buildObjectForStyle(rule.style()))
+        .release();
+
+    // "sourceURL" is present only for regular rules, otherwise "origin" should be used in the frontend.
+    if (stylesheet.origin() == StyleSheetOrigin::Author)
+        result->setSourceURL(stylesheet.finalURL());
+
+    if (stylesheet.canBind()) {
+        CSSId id(stylesheet.ruleId(rule));
+        if (!id.isEmpty())
+            result->setRuleId(id.asProtocolValue<Inspector::Protocol::CSS::CSSRuleId>());
+    }
+
+    auto mediaArray = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSMedia>::create();
+
+    fillMediaListChain(rule, mediaArray.get());
+    if (mediaArray->length())
+        result->setMedia(WTF::move(mediaArray));
+
+    return WTF::move(result);
+}
+
+RefPtr<Inspector::Protocol::CSS::CSSRule> InspectorCSSAgent::buildObjectForMatchedRule(StyleRule& styleRule, StyleResolver& styleResolver, Element* element)
+{
     // StyleRules returned by StyleResolver::styleRulesForElement lack parent pointers since that infomation is not cheaply available.
     // Since the inspector wants to walk the parent chain, we construct the full wrappers here.
-    CSSStyleRule* cssomWrapper = styleResolver.inspectorCSSOMWrappers().getWrapperForRuleInSheets(styleRule, styleResolver.document().styleSheetCollection());
-    if (!cssomWrapper)
+    CSSStyleRule* styleRuleWrapper = styleResolver.inspectorCSSOMWrappers().getWrapperForRuleInSheets(&styleRule, styleResolver.document().styleSheetCollection());
+    if (!styleRuleWrapper || !styleRuleWrapper->parentStyleSheet())
         return nullptr;
-    InspectorStyleSheet* inspectorStyleSheet = bindStyleSheet(cssomWrapper->parentStyleSheet());
-    return inspectorStyleSheet ? inspectorStyleSheet->buildObjectForRule(cssomWrapper, element) : nullptr;
+
+    StylesheetRuleSet& ruleSet = bindStyleSheet(*styleRuleWrapper->parentStyleSheet());
+    return WebCore::buildObjectForStyleRule(*styleRuleWrapper, ruleSet, element);
 }
 
-RefPtr<Inspector::Protocol::CSS::CSSRule> InspectorCSSAgent::buildObjectForRule(CSSStyleRule* rule)
+RefPtr<Inspector::Protocol::CSS::CSSRule> InspectorCSSAgent::buildObjectForStyleRule(CSSStyleRule& rule)
 {
-    if (!rule)
-        return nullptr;
-
-    ASSERT(rule->parentStyleSheet());
-    InspectorStyleSheet* inspectorStyleSheet = bindStyleSheet(rule->parentStyleSheet());
-    return inspectorStyleSheet ? inspectorStyleSheet->buildObjectForRule(rule, nullptr) : nullptr;
+    ASSERT(rule.parentStyleSheet());
+    StylesheetRuleSet& ruleSet = bindStyleSheet(*rule.parentStyleSheet());
+    return WebCore::buildObjectForStyleRule(rule, ruleSet, nullptr);
 }
 
 RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::RuleMatch>> InspectorCSSAgent::buildArrayForMatchedRuleList(const Vector<RefPtr<StyleRule>>& matchedRules, StyleResolver& styleResolver, Element* element)
 {
     auto result = Inspector::Protocol::Array<Inspector::Protocol::CSS::RuleMatch>::create();
 
     SelectorChecker::CheckingContext context(SelectorChecker::Mode::CollectingRules);
     SelectorChecker selectorChecker(element->document());
 
     for (auto& matchedRule : matchedRules) {
-        RefPtr<Inspector::Protocol::CSS::CSSRule> ruleObject = buildObjectForRule(matchedRule.get(), styleResolver, element);
+        if (!matchedRule)
+            continue;
+
+        RefPtr<Inspector::Protocol::CSS::CSSRule> ruleObject = buildObjectForMatchedRule(*matchedRule, styleResolver, element);
         if (!ruleObject)
             continue;
 
         auto matchingSelectors = Inspector::Protocol::Array<int>::create();
         const CSSSelectorList& selectorList = matchedRule->selectorList();
         long index = 0;
         for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector)) {
             unsigned ignoredSpecificity;
             bool matched = selectorChecker.match(selector, element, context, ignoredSpecificity);
             if (matched)
@@ -965,36 +1136,35 @@ RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::RuleMatch>> Inspecto
         auto match = Inspector::Protocol::CSS::RuleMatch::create()
             .setRule(WTF::move(ruleObject))
             .setMatchingSelectors(WTF::move(matchingSelectors))
             .release();
         result->addItem(WTF::move(match));
     }
 
     return WTF::move(result);
 }
 
-RefPtr<Inspector::Protocol::CSS::CSSStyle> InspectorCSSAgent::buildObjectForAttributesStyle(Element* element)
+RefPtr<Inspector::Protocol::CSS::CSSStyle> InspectorCSSAgent::buildObjectForAttributesStyle(Element& element)
 {
-    ASSERT(element);
-    if (!is<StyledElement>(*element))
+    if (!is<StyledElement>(element))
         return nullptr;
 
     // FIXME: Ugliness below.
-    StyleProperties* attributeStyle = const_cast<StyleProperties*>(downcast<StyledElement>(element)->presentationAttributeStyle());
+    StyleProperties* attributeStyle = const_cast<StyleProperties*>(downcast<StyledElement>(element).presentationAttributeStyle());
     if (!attributeStyle)
         return nullptr;
 
     ASSERT_WITH_SECURITY_IMPLICATION(attributeStyle->isMutable());
     MutableStyleProperties* mutableAttributeStyle = static_cast<MutableStyleProperties*>(attributeStyle);
 
-    Ref<InspectorStyle> inspectorStyle = InspectorStyle::create(InspectorCSSId(), mutableAttributeStyle->ensureCSSStyleDeclaration(), nullptr);
-    return inspectorStyle->buildObjectForStyle();
+    Ref<Inspector::StyleRule> styleRule = Inspector::StyleRule::create(CSSId(), *mutableAttributeStyle->ensureCSSStyleDeclaration(), nullptr);
+    return styleRule->buildObjectForStyle();
 }
 
 RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::Region>> InspectorCSSAgent::buildArrayForRegions(ErrorString& errorString, RefPtr<NodeList>&& regionList, int documentNodeId)
 {
     auto regions = Inspector::Protocol::Array<Inspector::Protocol::CSS::Region>::create();
 
     for (unsigned i = 0; i < regionList->length(); ++i) {
         Inspector::Protocol::CSS::Region::RegionOverset regionOverset;
 
         switch (downcast<Element>(regionList->item(i))->regionOversetState()) {
@@ -1041,62 +1211,61 @@ RefPtr<Inspector::Protocol::CSS::NamedFlow> InspectorCSSAgent::buildObjectForNam
         .setName(webkitNamedFlow->name().string())
         .setOverset(webkitNamedFlow->overset())
         .setContent(WTF::move(content))
         .setRegions(buildArrayForRegions(errorString, webkitNamedFlow->getRegions(), documentNodeId))
         .release();
 }
 
 void InspectorCSSAgent::didRemoveDocument(Document* document)
 {
     if (document)
-        m_documentToInspectorStyleSheet.remove(document);
+        m_documentToInspectorRuleSetMap.remove(document);
 }
 
 void InspectorCSSAgent::didRemoveDOMNode(Node* node)
 {
     if (!node)
         return;
 
     int nodeId = m_domAgent->boundNodeId(node);
     if (nodeId)
         m_nodeIdToForcedPseudoState.remove(nodeId);
 
-    NodeToInspectorStyleSheet::iterator it = m_nodeToInspectorStyleSheet.find(node);
-    if (it == m_nodeToInspectorStyleSheet.end())
+    RefPtr<InlineStyleRuleSet> foundRuleSet = m_nodeToInlineRuleSetMap.take(node);
+    if (!foundRuleSet)
         return;
-
-    m_idToInspectorStyleSheet.remove(it->value->id());
-    m_nodeToInspectorStyleSheet.remove(node);
+    m_identifierToRuleSetMap.remove(foundRuleSet->identifier());
 }
 
 void InspectorCSSAgent::didModifyDOMAttr(Element* element)
 {
     if (!element)
         return;
 
-    NodeToInspectorStyleSheet::iterator it = m_nodeToInspectorStyleSheet.find(element);
-    if (it == m_nodeToInspectorStyleSheet.end())
+    auto findResult = m_nodeToInlineRuleSetMap.find(element);
+    if (findResult == m_nodeToInlineRuleSetMap.end())
         return;
 
-    it->value->didModifyElementAttribute();
+    findResult->value->didModifyElementAttribute();
 }
 
-void InspectorCSSAgent::styleSheetChanged(InspectorStyleSheet& styleSheet)
+void InspectorCSSAgent::styleSheetChanged(StylesheetRuleSet& stylesheet)
 {
     if (m_frontendDispatcher)
-        m_frontendDispatcher->styleSheetChanged(styleSheet.id());
+        m_frontendDispatcher->styleSheetChanged(stylesheet.identifier());
 }
 
 void InspectorCSSAgent::resetPseudoStates()
 {
     HashSet<Document*> documentsToChange;
-    for (NodeIdToForcedPseudoState::iterator it = m_nodeIdToForcedPseudoState.begin(), end = m_nodeIdToForcedPseudoState.end(); it != end; ++it) {
-        if (Element* element = downcast<Element>(m_domAgent->nodeForId(it->key)))
-            documentsToChange.add(&element->document());
+    for (auto& nodeId : m_nodeIdToForcedPseudoState.keys()) {
+        Node* node = m_domAgent->nodeForId(nodeId);
+        if (is<Element>(node))
+            documentsToChange.add(&downcast<Element>(node)->document());
     }
 
     m_nodeIdToForcedPseudoState.clear();
-    for (HashSet<Document*>::iterator it = documentsToChange.begin(), end = documentsToChange.end(); it != end; ++it)
-        (*it)->styleResolverChanged(RecalcStyleImmediately);
+    for (Document* document : documentsToChange)
+        document->styleResolverChanged(RecalcStyleImmediately);
 }
 
 } // namespace WebCore
diff --git a/Source/WebCore/inspector/InspectorCSSAgent.h b/Source/WebCore/inspector/InspectorCSSAgent.h
index b331a77..b9dee17 100644
--- a/Source/WebCore/inspector/InspectorCSSAgent.h
+++ b/Source/WebCore/inspector/InspectorCSSAgent.h
@@ -21,32 +21,33 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef InspectorCSSAgent_h
 #define InspectorCSSAgent_h
 
 #include "CSSSelector.h"
 #include "ContentSecurityPolicy.h"
 #include "InspectorDOMAgent.h"
-#include "InspectorStyleSheet.h"
+#include "InspectorStylesheetRuleSet.h"
 #include "InspectorWebAgentBase.h"
 #include "SecurityContext.h"
 #include <inspector/InspectorBackendDispatchers.h>
 #include <inspector/InspectorValues.h>
 #include <wtf/HashMap.h>
 #include <wtf/HashSet.h>
 #include <wtf/RefPtr.h>
 #include <wtf/text/WTFString.h>
 
 namespace Inspector {
 class CSSFrontendDispatcher;
+class InlineStyleRuleSet;
 }
 
 namespace WebCore {
 
 class CSSRule;
 class CSSRuleList;
 class CSSStyleDeclaration;
 class CSSStyleRule;
 class CSSStyleSheet;
 class Document;
@@ -58,21 +59,21 @@ class NameNodeMap;
 class Node;
 class NodeList;
 class StyleResolver;
 class StyleRule;
 class ChangeRegionOversetTask;
 
 class InspectorCSSAgent final
     : public InspectorAgentBase
     , public InspectorDOMAgent::DOMListener
     , public Inspector::CSSBackendDispatcherHandler
-    , public InspectorStyleSheet::Listener {
+    , public Inspector::StylesheetRuleSet::Listener {
     WTF_MAKE_NONCOPYABLE(InspectorCSSAgent);
     WTF_MAKE_FAST_ALLOCATED;
 public:
     class InlineStyleOverrideScope {
     public:
         InlineStyleOverrideScope(SecurityContext* context)
             : m_contentSecurityPolicy(context->contentSecurityPolicy())
         {
             m_contentSecurityPolicy->setOverrideAllowInlineStyle(true);
         }
@@ -82,22 +83,20 @@ public:
             m_contentSecurityPolicy->setOverrideAllowInlineStyle(false);
         }
 
     private:
         ContentSecurityPolicy* m_contentSecurityPolicy;
     };
 
     InspectorCSSAgent(InstrumentingAgents*, InspectorDOMAgent*);
     virtual ~InspectorCSSAgent();
 
-    static CSSStyleRule* asCSSStyleRule(CSSRule&);
-
     virtual void didCreateFrontendAndBackend(Inspector::FrontendChannel*, Inspector::BackendDispatcher*) override;
     virtual void willDestroyFrontendAndBackend(Inspector::DisconnectReason) override;
     virtual void discardAgent() override;
     virtual void enable(ErrorString&) override;
     virtual void disable(ErrorString&) override;
     void regionOversetChanged(WebKitNamedFlow*, int documentNodeId);
     void reset();
 
     // InspectorInstrumentation callbacks.
     void mediaQueryResultChanged();
@@ -105,80 +104,90 @@ public:
     void willRemoveNamedFlow(Document&, WebKitNamedFlow&);
     void didChangeRegionOverset(Document&, WebKitNamedFlow&);
     void didRegisterNamedFlowContentElement(Document&, WebKitNamedFlow&, Node& contentElement, Node* nextContentElement = nullptr);
     void didUnregisterNamedFlowContentElement(Document&, WebKitNamedFlow&, Node& contentElement);
     bool forcePseudoState(Element&, CSSSelector::PseudoClassType);
 
     virtual void getComputedStyleForNode(ErrorString&, int nodeId, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>>&) override;
     virtual void getInlineStylesForNode(ErrorString&, int nodeId, RefPtr<Inspector::Protocol::CSS::CSSStyle>& inlineStyle, RefPtr<Inspector::Protocol::CSS::CSSStyle>& attributes) override;
     virtual void getMatchedStylesForNode(ErrorString&, int nodeId, const bool* includePseudo, const bool* includeInherited, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::RuleMatch>>& matchedCSSRules, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::PseudoIdMatches>>& pseudoIdMatches, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::InheritedStyleEntry>>& inheritedEntries) override;
     virtual void getAllStyleSheets(ErrorString&, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSStyleSheetHeader>>& styleSheetInfos) override;
-    virtual void getStyleSheet(ErrorString&, const String& styleSheetId, RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody>& result) override;
-    virtual void getStyleSheetText(ErrorString&, const String& styleSheetId, String* result) override;
-    virtual void setStyleSheetText(ErrorString&, const String& styleSheetId, const String& text) override;
+    virtual void getStyleSheet(ErrorString&, Inspector::Protocol::CSS::StyleSheetId styleSheetId, RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody>& result) override;
+    virtual void getStyleSheetText(ErrorString&, Inspector::Protocol::CSS::StyleSheetId styleSheetId, String* result) override;
+    virtual void setStyleSheetText(ErrorString&, Inspector::Protocol::CSS::StyleSheetId styleSheetId, const String& text) override;
     virtual void setStyleText(ErrorString&, const RefPtr<Inspector::InspectorObject>&& styleId, const String& text, RefPtr<Inspector::Protocol::CSS::CSSStyle>& result) override;
     virtual void setRuleSelector(ErrorString&, const RefPtr<Inspector::InspectorObject>&& ruleId, const String& selector, RefPtr<Inspector::Protocol::CSS::CSSRule>& result) override;
     virtual void addRule(ErrorString&, int contextNodeId, const String& selector, RefPtr<Inspector::Protocol::CSS::CSSRule>& result) override;
     virtual void getSupportedCSSProperties(ErrorString&, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSPropertyInfo>>& result) override;
     virtual void forcePseudoState(ErrorString&, int nodeId, const RefPtr<Inspector::InspectorArray>&& forcedPseudoClasses) override;
     virtual void getNamedFlowCollection(ErrorString&, int documentNodeId, RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::NamedFlow>>& result) override;
 
 private:
-    class StyleSheetAction;
+    class StyleRuleSetAction;
     class SetStyleSheetTextAction;
     class SetStyleTextAction;
     class SetRuleSelectorAction;
     class AddRuleAction;
 
-    typedef HashMap<String, RefPtr<InspectorStyleSheet>> IdToInspectorStyleSheet;
-    typedef HashMap<CSSStyleSheet*, RefPtr<InspectorStyleSheet>> CSSStyleSheetToInspectorStyleSheet;
-    typedef HashMap<Node*, RefPtr<InspectorStyleSheetForInlineStyle>> NodeToInspectorStyleSheet; // bogus "stylesheets" with elements' inline styles
-    typedef HashMap<RefPtr<Document>, RefPtr<InspectorStyleSheet>> DocumentToViaInspectorStyleSheet; // "via inspector" stylesheets
+    typedef HashMap<uint64_t, RefPtr<Inspector::StyleRuleSet>> IdentifierToRuleSetMap;
+    typedef HashMap<CSSStyleSheet*, RefPtr<Inspector::StylesheetRuleSet>> CSSStyleSheetToRuleSetMap;
+    typedef HashMap<Node*, RefPtr<Inspector::InlineStyleRuleSet>> NodeToInlineRuleSetMap;
+    typedef HashMap<RefPtr<Document>, RefPtr<Inspector::StylesheetRuleSet>> DocumentToInspectorRuleSetMap; // "via inspector" stylesheets
     typedef HashMap<int, unsigned> NodeIdToForcedPseudoState;
 
     void resetNonPersistentData();
-    InspectorStyleSheetForInlineStyle* asInspectorStyleSheet(Element* element);
+    Inspector::InlineStyleRuleSet* asInlineRuleSet(Element& element);
     Element* elementForId(ErrorString&, int nodeId);
     int documentNodeWithRequestedFlowsId(Document*);
     void collectStyleSheets(CSSStyleSheet&, Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSStyleSheetHeader>&);
 
-    InspectorStyleSheet* bindStyleSheet(CSSStyleSheet*);
-    InspectorStyleSheet* viaInspectorStyleSheet(Document*, bool createIfAbsent);
-    InspectorStyleSheet* assertStyleSheetForId(ErrorString&, const String&);
+    Inspector::StylesheetRuleSet& bindStyleSheet(CSSStyleSheet&);
+    Inspector::StylesheetRuleSet* inspectorRuleSetForDocument(Document&, bool createIfAbsent);
+    Inspector::StyleRuleSet* ruleSetForStylesheetId(ErrorString&, Inspector::Protocol::CSS::StyleSheetId);
 
-    StyleSheetOrigin detectOrigin(CSSStyleSheet* pageStyleSheet, Document* ownerDocument);
+    Inspector::StyleSheetOrigin detectOrigin(CSSStyleSheet& pageStyleSheet, Document* ownerDocument);
 
-    RefPtr<Inspector::Protocol::CSS::CSSRule> buildObjectForRule(StyleRule*, StyleResolver&, Element*);
-    RefPtr<Inspector::Protocol::CSS::CSSRule> buildObjectForRule(CSSStyleRule*);
+    RefPtr<Inspector::Protocol::CSS::CSSRule> buildObjectForMatchedRule(StyleRule&, StyleResolver&, Element*);
+    RefPtr<Inspector::Protocol::CSS::CSSRule> buildObjectForStyleRule(CSSStyleRule&);
     RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::RuleMatch>> buildArrayForMatchedRuleList(const Vector<RefPtr<StyleRule>>&, StyleResolver&, Element*);
-    RefPtr<Inspector::Protocol::CSS::CSSStyle> buildObjectForAttributesStyle(Element*);
+    RefPtr<Inspector::Protocol::CSS::CSSStyle> buildObjectForAttributesStyle(Element&);
     RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::Region>> buildArrayForRegions(ErrorString&, RefPtr<NodeList>&&, int documentNodeId);
     RefPtr<Inspector::Protocol::CSS::NamedFlow> buildObjectForNamedFlow(ErrorString&, WebKitNamedFlow*, int documentNodeId);
 
     // InspectorDOMAgent::DOMListener implementation
     virtual void didRemoveDocument(Document*) override;
     virtual void didRemoveDOMNode(Node*) override;
     virtual void didModifyDOMAttr(Element*) override;
 
     // InspectorCSSAgent::Listener implementation
-    virtual void styleSheetChanged(InspectorStyleSheet&) override;
+    virtual void styleSheetChanged(Inspector::StylesheetRuleSet&) override;
 
     void resetPseudoStates();
 
     std::unique_ptr<Inspector::CSSFrontendDispatcher> m_frontendDispatcher;
     RefPtr<Inspector::CSSBackendDispatcher> m_backendDispatcher;
     InspectorDOMAgent* m_domAgent;
 
-    IdToInspectorStyleSheet m_idToInspectorStyleSheet;
-    CSSStyleSheetToInspectorStyleSheet m_cssStyleSheetToInspectorStyleSheet;
-    NodeToInspectorStyleSheet m_nodeToInspectorStyleSheet;
-    DocumentToViaInspectorStyleSheet m_documentToInspectorStyleSheet;
+    IdentifierToRuleSetMap m_identifierToRuleSetMap;
+    CSSStyleSheetToRuleSetMap m_cssStyleSheetToRuleSetMap;
+    NodeToInlineRuleSetMap m_nodeToInlineRuleSetMap;
+    DocumentToInspectorRuleSetMap m_documentToInspectorRuleSetMap;
+
     NodeIdToForcedPseudoState m_nodeIdToForcedPseudoState;
     HashSet<int> m_namedFlowCollectionsRequested;
     std::unique_ptr<ChangeRegionOversetTask> m_changeRegionOversetTask;
-
-    int m_lastStyleSheetId;
 };
 
+// TODO: remove these declarations when their uses are removed from InspectorStyleSheet.cpp.
+class MediaList;
+
+Inspector::Protocol::CSS::StyleSheetOrigin stylesheetOriginToProtocolEnum(Inspector::StyleSheetOrigin origin);
+Inspector::Protocol::CSS::CSSMedia::Source mediaListSourceToProtocolEnum(Inspector::MediaListSource source);
+RefPtr<Inspector::Protocol::CSS::SourceRange> buildSourceRangeObject(const SourceRange& range, Vector<size_t>& lineEndings);
+Ref<Inspector::Protocol::CSS::CSSMedia> buildMediaObject(const MediaList& media, Inspector::MediaListSource mediaListSource, const String& sourceURL);
+void fillMediaListChain(CSSRule& rule, Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSMedia>& mediaArray);
+Ref<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSRule>> buildArrayForRuleList(StyleRuleList& ruleList, Inspector::StylesheetRuleSet&);
+RefPtr<Inspector::Protocol::CSS::CSSRule> buildObjectForStyleRule(CSSStyleRule& rule, Inspector::StylesheetRuleSet& stylesheet, Element* element);
+
 } // namespace WebCore
 
 #endif // !defined(InspectorCSSAgent_h)
diff --git a/Source/WebCore/inspector/InspectorCSSId.h b/Source/WebCore/inspector/InspectorCSSId.h
new file mode 100644
index 0000000..4a74bbb
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorCSSId.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef InspectorCSSId_h
+#define InspectorCSSId_h
+
+#include <inspector/InspectorProtocolTypes.h>
+#include <wtf/RefPtr.h>
+#include <wtf/text/WTFString.h>
+
+namespace Inspector {
+
+class CSSId {
+public:
+    CSSId() { }
+
+    explicit CSSId(const RefPtr<InspectorObject>&& value)
+    {
+        if (!value->getInteger(ASCIILiteral("styleSheetId"), m_stylesheetId))
+            return;
+
+        if (!value->getInteger(ASCIILiteral("ordinal"), m_ruleOrdinal))
+            return;
+    }
+
+    CSSId(uint64_t stylesheetId, uint64_t ruleOrdinal)
+        : m_stylesheetId(stylesheetId)
+        , m_ruleOrdinal(ruleOrdinal)
+    {
+    }
+
+    bool isEmpty() const { return !m_stylesheetId; }
+
+    uint64_t stylesheetId() const { return m_stylesheetId; }
+    uint64_t ruleOrdinal() const { return m_ruleOrdinal; }
+
+    // ProtocolType is either Inspector::Protocol::CSS::CSSStyleId or Inspector::Protocol::CSS::CSSRuleId.
+    template<typename ProtocolType>
+    RefPtr<ProtocolType> asProtocolValue() const
+    {
+        if (isEmpty())
+            return nullptr;
+
+        return ProtocolType::create()
+            .setStyleSheetId(m_stylesheetId)
+            .setOrdinal(m_ruleOrdinal)
+            .release();
+    }
+
+private:
+    uint64_t m_stylesheetId {0};
+    uint64_t m_ruleOrdinal {0};
+};
+
+} // namespace Inspector
+
+#endif // InspectorCSSId_h
diff --git a/Source/WebCore/inspector/InspectorInlineStyleRuleSet.cpp b/Source/WebCore/inspector/InspectorInlineStyleRuleSet.cpp
new file mode 100644
index 0000000..7579a26
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorInlineStyleRuleSet.cpp
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "InspectorInlineStyleRuleSet.h"
+
+#include "CSSStyleRule.h"
+#include "Element.h"
+#include "InspectorCSSAgent.h"
+#include "InspectorStyleRule.h"
+#include "Node.h"
+
+using namespace WebCore;
+
+namespace Inspector {
+
+Ref<InlineStyleRuleSet> InlineStyleRuleSet::create(Ref<Element>&& element)
+{
+    return adoptRef(*new InlineStyleRuleSet(WTF::move(element)));
+}
+
+InlineStyleRuleSet::InlineStyleRuleSet(Ref<Element>&& element)
+    : StyleRuleSet()
+    , m_element(WTF::move(element))
+{
+}
+
+InlineStyleRuleSet::~InlineStyleRuleSet() { }
+    
+void InlineStyleRuleSet::replaceText(const String& text)
+{
+    {
+        InspectorCSSAgent::InlineStyleOverrideScope overrideScope(&m_element->document());
+        ExceptionCode ec;
+        m_element->setAttribute("style", text, ec);
+    }
+
+    commitRuleSetChange(ParsedRuleSetData::create(m_element));
+}
+
+bool InlineStyleRuleSet::setTextForStyle(CSSStyleDeclaration& style, const String& styleText)
+{
+    ASSERT_UNUSED(style, &style == inlineStyle());
+
+    replaceText(styleText);
+    return true;
+}
+
+bool InlineStyleRuleSet::setTextForStyle(const CSSId& identifier, const String& styleText, String& oldStyleText)
+{
+    ASSERT_UNUSED(identifier, !identifier.ruleOrdinal());
+
+    oldStyleText = getText();
+    replaceText(styleText);
+    return true;
+}
+    
+void InlineStyleRuleSet::didModifyElementAttribute()
+{
+    // Drop stale parsed data since it can be regenerated when needed.
+    commitRuleSetChange(nullptr);
+}
+
+Document* InlineStyleRuleSet::ownerDocument() const
+{
+    return &m_element->document();
+}
+
+std::unique_ptr<ParsedRuleSetData> InlineStyleRuleSet::originalSourceData()
+{
+    return ParsedRuleSetData::create(m_element.get());
+}
+
+RefPtr<StyleRule> InlineStyleRuleSet::inspectorStyleForId(const CSSId& identifier)
+{
+    ASSERT_UNUSED(identifier, !identifier.ruleOrdinal());
+
+    if (CSSStyleDeclaration* style = inlineStyle())
+        return StyleRule::create(identifier, *style, this);
+
+    return nullptr;
+}
+
+CSSStyleDeclaration* InlineStyleRuleSet::inlineStyle()
+{
+    return m_element->style();
+}
+
+} // namespace WebCore
diff --git a/Source/WebCore/inspector/InspectorInlineStyleRuleSet.h b/Source/WebCore/inspector/InspectorInlineStyleRuleSet.h
new file mode 100644
index 0000000..710752a
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorInlineStyleRuleSet.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef InlineStyleRuleSet_h
+#define InlineStyleRuleSet_h
+
+#include "InspectorCSSId.h"
+#include "InspectorStyleRuleSet.h"
+#include <wtf/TypeCasts.h>
+
+namespace WebCore {
+class CSSStyleDeclaration;
+class Element;
+struct CSSRuleSourceData;
+}
+
+namespace Inspector {
+
+class InlineStyleRuleSet final : public StyleRuleSet {
+public:
+    static Ref<InlineStyleRuleSet> create(Ref<WebCore::Element>&&);
+    virtual ~InlineStyleRuleSet();
+
+    // StyleRuleSet API
+    virtual bool isInlineStyle() const override { return true; }
+    virtual void replaceText(const String&) override;
+
+    virtual std::unique_ptr<ParsedRuleSetData> originalSourceData() override;
+    virtual RefPtr<StyleRule> inspectorStyleForId(const CSSId&) override;
+    virtual WebCore::CSSStyleDeclaration* styleForId(const CSSId& identifier) override
+    {
+        ASSERT_UNUSED(identifier, !identifier.ruleOrdinal());
+        return inlineStyle();
+    }
+    virtual WebCore::Document* ownerDocument() const override;
+
+    // InlineStyleRuleSet API
+    WebCore::CSSStyleDeclaration* inlineStyle();
+    
+    // Called from CSSAgent through InspectorInstrumentation.
+    void didModifyElementAttribute();
+
+private:
+    InlineStyleRuleSet(Ref<WebCore::Element>&&);
+
+    // Also accessed by friend class InspectorStyle.
+    virtual bool setTextForStyle(WebCore::CSSStyleDeclaration&, const String&) override;
+    virtual bool setTextForStyle(const CSSId&, const String& text, String& oldText) override;
+
+private:
+
+    Ref<WebCore::Element> m_element;
+};
+
+} // namespace Inspector
+
+SPECIALIZE_TYPE_TRAITS_BEGIN(Inspector::InlineStyleRuleSet)
+static bool isType(const Inspector::StyleRuleSet& ruleSet) { return ruleSet.isInlineStyle(); }
+SPECIALIZE_TYPE_TRAITS_END()
+
+#endif // InlineStyleRuleSet_h
diff --git a/Source/WebCore/inspector/InspectorStyleProperty.h b/Source/WebCore/inspector/InspectorStyleProperty.h
new file mode 100644
index 0000000..2e8a510
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStyleProperty.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef InspectorStyleProperty_h
+#define InspectorStyleProperty_h
+
+#include "CSSPropertySourceData.h"
+
+namespace Inspector {
+
+struct StyleProperty {
+    StyleProperty() { }
+
+    StyleProperty(WebCore::CSSPropertySourceData sourceData, bool hasSource, bool disabled)
+        : sourceData(sourceData)
+        , hasSource(hasSource)
+        , disabled(disabled)
+    {
+    }
+
+    void setRawTextFromStyleDeclaration(const String& styleDeclaration)
+    {
+        unsigned start = sourceData.range.start;
+        unsigned end = sourceData.range.end;
+        ASSERT_WITH_SECURITY_IMPLICATION(start < end);
+        ASSERT(end <= styleDeclaration.length());
+        rawText = styleDeclaration.substring(start, end - start);
+    }
+
+    bool hasRawText() const { return !rawText.isEmpty(); }
+
+    WebCore::CSSPropertySourceData sourceData;
+    bool hasSource {false};
+    bool disabled {false};
+    String rawText;
+};
+
+} // namespace Inspector
+
+#endif // InspectorStyleProperty_h
diff --git a/Source/WebCore/inspector/InspectorStyleRule.cpp b/Source/WebCore/inspector/InspectorStyleRule.cpp
new file mode 100644
index 0000000..66fa245
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStyleRule.cpp
@@ -0,0 +1,331 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "InspectorStyleRule.h"
+
+#include "CSSParser.h"
+#include "CSSPropertySourceData.h"
+#include "CSSStyleDeclaration.h"
+#include "InspectorCSSAgent.h"
+#include "InspectorStyleProperty.h"
+#include "InspectorStyleRuleSet.h"
+#include "Node.h"
+#include <inspector/ContentSearchUtilities.h>
+
+using namespace WebCore;
+
+namespace Inspector {
+
+Ref<StyleRule> StyleRule::create(const CSSId& styleId, Ref<CSSStyleDeclaration>&& style, StyleRuleSet* ruleSet)
+{
+    return adoptRef(*new StyleRule(styleId, WTF::move(style), ruleSet));
+}
+
+StyleRule::StyleRule(const CSSId& styleId, Ref<CSSStyleDeclaration>&& style, StyleRuleSet* ruleSet)
+    : m_styleId(styleId)
+    , m_style(WTF::move(style))
+    , m_ruleSet(ruleSet)
+{
+}
+
+StyleRule::~StyleRule()
+{
+}
+
+RefPtr<Inspector::Protocol::CSS::CSSStyle> StyleRule::buildObjectForStyle()
+{
+    Ref<Inspector::Protocol::CSS::CSSStyle> result = buildObjectForStyleWithProperties();
+    if (!styleId().isEmpty())
+        result->setStyleId(styleId().asProtocolValue<Inspector::Protocol::CSS::CSSStyleId>());
+
+    result->setWidth(cssStyle().getPropertyValue("width"));
+    result->setHeight(cssStyle().getPropertyValue("height"));
+
+    if (RefPtr<CSSRuleSourceData> sourceData = ruleSourceData()) {
+        auto lineEndings = ContentSearchUtilities::lineEndings(m_ruleSet->getText());
+        result->setRange(buildSourceRangeObject(sourceData->ruleBodyRange, *lineEndings));
+    }
+
+    return WTF::move(result);
+}
+
+Ref<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>> StyleRule::buildArrayForComputedStyle()
+{
+    auto result = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>::create();
+    Vector<StyleProperty> properties;
+    populateAllProperties(properties);
+
+    for (auto& property : properties) {
+        const CSSPropertySourceData& sourceData = property.sourceData;
+        auto entry = Inspector::Protocol::CSS::CSSComputedStyleProperty::create()
+            .setName(sourceData.name)
+            .setValue(sourceData.value)
+            .release();
+        result->addItem(WTF::move(entry));
+    }
+
+    return WTF::move(result);
+}
+
+bool StyleRule::getStyleText(String& result)
+{
+    RefPtr<CSSRuleSourceData> sourceData = ruleSourceData();
+    if (!sourceData)
+        return false;
+
+    String stylesheetText = m_ruleSet->getText();
+    SourceRange& bodyRange = sourceData->ruleBodyRange;
+    result = stylesheetText.substring(bodyRange.start, bodyRange.end - bodyRange.start);
+    return true;
+}
+
+RefPtr<CSSRuleSourceData> StyleRule::ruleSourceData()
+{
+    return m_ruleSet ? m_ruleSet->sourceDataForStyle(m_style.get()) : nullptr;
+}
+
+RefPtr<CSSStyleSourceData> StyleRule::styleSourceData()
+{
+    if (!m_ruleSet)
+        return nullptr;
+
+    if (RefPtr<CSSRuleSourceData> sourceData = m_ruleSet->sourceDataForStyle(m_style.get()))
+        return sourceData->styleSourceData;
+
+    return nullptr;
+}
+
+bool StyleRule::populateAllProperties(Vector<StyleProperty>& result)
+{
+    HashSet<String> sourcePropertyNames;
+
+    RefPtr<CSSRuleSourceData> sourceData = ruleSourceData();
+    if (sourceData) {
+        Vector<CSSPropertySourceData>& sourcePropertyData = sourceData->styleSourceData->propertyData;
+
+        String styleDeclaration;
+        bool isStyleTextKnown = getStyleText(styleDeclaration);
+        ASSERT_UNUSED(isStyleTextKnown, isStyleTextKnown);
+        for (auto& data : sourcePropertyData) {
+            StyleProperty property(data, true, false);
+            property.setRawTextFromStyleDeclaration(styleDeclaration);
+            result.append(property);
+            sourcePropertyNames.add(data.name.lower());
+        }
+    }
+
+    for (int i = 0, size = m_style->length(); i < size; ++i) {
+        String name = m_style->item(i);
+        if (sourcePropertyNames.contains(name.lower()))
+            continue;
+
+        sourcePropertyNames.add(name.lower());
+        result.append(StyleProperty(CSSPropertySourceData(name, m_style->getPropertyValue(name), !m_style->getPropertyPriority(name).isEmpty(), true, SourceRange()), false, false));
+    }
+
+    return true;
+}
+
+Ref<Inspector::Protocol::CSS::CSSStyle> StyleRule::buildObjectForStyleWithProperties()
+{
+    Vector<StyleProperty> properties;
+    populateAllProperties(properties);
+
+    auto propertiesArray = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSProperty>::create();
+    auto shorthandEntries = Inspector::Protocol::Array<Inspector::Protocol::CSS::ShorthandEntry>::create();
+    HashMap<String, RefPtr<Inspector::Protocol::CSS::CSSProperty>> propertyNameToPreviousActiveProperty;
+    HashSet<String> foundShorthands;
+    String previousPriority;
+    String previousStatus;
+    auto lineEndings = ContentSearchUtilities::lineEndings(m_ruleSet->getText());
+    RefPtr<CSSRuleSourceData> sourceData = ruleSourceData();
+    unsigned ruleBodyRangeStart = sourceData ? sourceData->ruleBodyRange.start : 0;
+
+    for (auto& property : properties) {
+        const CSSPropertySourceData& propertyEntry = property.sourceData;
+        const String& name = propertyEntry.name;
+
+        // Visual Studio disagrees with other compilers as to whether 'class' is needed here.
+#if COMPILER(MSVC)
+        enum class Protocol::CSS::CSSPropertyStatus status;
+#else
+        enum Inspector::Protocol::CSS::CSSPropertyStatus status;
+#endif
+        status = property.disabled ? Inspector::Protocol::CSS::CSSPropertyStatus::Disabled : Inspector::Protocol::CSS::CSSPropertyStatus::Active;
+
+        RefPtr<Inspector::Protocol::CSS::CSSProperty> propertyObject = Inspector::Protocol::CSS::CSSProperty::create()
+            .setName(name.lower())
+            .setValue(propertyEntry.value)
+            .release();
+
+        // Default "parsedOk" == true.
+        if (!propertyEntry.parsedOk)
+            propertyObject->setParsedOk(false);
+        if (property.hasRawText())
+            propertyObject->setText(property.rawText);
+
+        // Default "priority" == "".
+        if (propertyEntry.important)
+            propertyObject->setPriority("important");
+        if (!property.disabled) {
+            if (property.hasSource) {
+                ASSERT(sourceData);
+                propertyObject->setImplicit(false);
+                // The property range is relative to the style body start.
+                // Should be converted into an absolute range (relative to the stylesheet start)
+                // for the proper conversion into line:column.
+                SourceRange absolutePropertyRange = propertyEntry.range;
+                absolutePropertyRange.start += ruleBodyRangeStart;
+                absolutePropertyRange.end += ruleBodyRangeStart;
+                propertyObject->setRange(buildSourceRangeObject(absolutePropertyRange, *lineEndings));
+
+                // Parsed property overrides any property with the same name. Non-parsed property overrides
+                // previous non-parsed property with the same name (if any).
+                bool shouldInactivate = false;
+                CSSPropertyID propertyId = cssPropertyID(name);
+                // Canonicalize property names to treat non-prefixed and vendor-prefixed property names the same (opacity vs. -webkit-opacity).
+                String canonicalPropertyName = propertyId ? getPropertyNameString(propertyId) : name;
+                HashMap<String, RefPtr<Inspector::Protocol::CSS::CSSProperty>>::iterator activeIt = propertyNameToPreviousActiveProperty.find(canonicalPropertyName);
+                if (activeIt != propertyNameToPreviousActiveProperty.end()) {
+                    if (propertyEntry.parsedOk) {
+                        bool successPriority = activeIt->value->getString(Inspector::Protocol::CSS::CSSProperty::Priority, previousPriority);
+                        bool successStatus = activeIt->value->getString(Inspector::Protocol::CSS::CSSProperty::Status, previousStatus);
+                        if (successStatus && previousStatus != "inactive") {
+                            if (propertyEntry.important || !successPriority) // Priority not set == "not important".
+                                shouldInactivate = true;
+                            else if (status == Inspector::Protocol::CSS::CSSPropertyStatus::Active) {
+                                // Inactivate a non-important property following the same-named important property.
+                                status = Inspector::Protocol::CSS::CSSPropertyStatus::Inactive;
+                            }
+                        }
+                    } else {
+                        bool previousParsedOk;
+                        bool success = activeIt->value->getBoolean(Inspector::Protocol::CSS::CSSProperty::ParsedOk, previousParsedOk);
+                        if (success && !previousParsedOk)
+                            shouldInactivate = true;
+                    }
+                } else
+                    propertyNameToPreviousActiveProperty.set(canonicalPropertyName, propertyObject);
+
+                if (shouldInactivate) {
+                    activeIt->value->setStatus(Inspector::Protocol::CSS::CSSPropertyStatus::Inactive);
+                    propertyNameToPreviousActiveProperty.set(canonicalPropertyName, propertyObject);
+                }
+            } else {
+                bool implicit = m_style->isPropertyImplicit(name);
+                // Default "implicit" == false.
+                if (implicit)
+                    propertyObject->setImplicit(true);
+                status = Inspector::Protocol::CSS::CSSPropertyStatus::Style;
+
+                String shorthand = m_style->getPropertyShorthand(name);
+                if (!shorthand.isEmpty()) {
+                    if (!foundShorthands.contains(shorthand)) {
+                        foundShorthands.add(shorthand);
+                        auto entry = Inspector::Protocol::CSS::ShorthandEntry::create()
+                            .setName(shorthand)
+                            .setValue(shorthandValue(shorthand))
+                            .release();
+                        shorthandEntries->addItem(WTF::move(entry));
+                    }
+                }
+            }
+        }
+
+        // Default "status" == "style".
+        if (status != Inspector::Protocol::CSS::CSSPropertyStatus::Style)
+            propertyObject->setStatus(status);
+
+        propertiesArray->addItem(WTF::move(propertyObject));
+    }
+
+    return Inspector::Protocol::CSS::CSSStyle::create()
+        .setCssProperties(WTF::move(propertiesArray))
+        .setShorthandEntries(WTF::move(shorthandEntries))
+        .release();
+}
+
+bool StyleRule::setStyleText(const String& styleText)
+{
+    if (!m_ruleSet)
+        return false;
+
+    return m_ruleSet->setTextForStyle(m_style.get(), styleText);
+}
+
+String StyleRule::shorthandValue(const String& shorthandProperty)
+{
+    String value = m_style->getPropertyValue(shorthandProperty);
+    if (!value.isEmpty())
+        return value;
+    StringBuilder builder;
+    for (unsigned i = 0; i < m_style->length(); ++i) {
+        String individualProperty = m_style->item(i);
+        if (m_style->getPropertyShorthand(individualProperty) != shorthandProperty)
+            continue;
+        if (m_style->isPropertyImplicit(individualProperty))
+            continue;
+        String individualValue = m_style->getPropertyValue(individualProperty);
+        if (individualValue == "initial")
+            continue;
+        if (!builder.isEmpty())
+            builder.append(' ');
+        builder.append(individualValue);
+    }
+    return builder.toString();
+}
+
+String StyleRule::shorthandPriority(const String& shorthandProperty)
+{
+    String priority = m_style->getPropertyPriority(shorthandProperty);
+    if (priority.isEmpty()) {
+        for (unsigned i = 0; i < m_style->length(); ++i) {
+            String individualProperty = m_style->item(i);
+            if (m_style->getPropertyShorthand(individualProperty) != shorthandProperty)
+                continue;
+            priority = m_style->getPropertyPriority(individualProperty);
+            break;
+        }
+    }
+    return priority;
+}
+
+Vector<String> StyleRule::longhandProperties(const String& shorthandProperty)
+{
+    Vector<String> properties;
+    HashSet<String> foundProperties;
+    for (unsigned i = 0; i < m_style->length(); ++i) {
+        String individualProperty = m_style->item(i);
+        if (foundProperties.contains(individualProperty) || m_style->getPropertyShorthand(individualProperty) != shorthandProperty)
+            continue;
+
+        foundProperties.add(individualProperty);
+        properties.append(individualProperty);
+    }
+    return properties;
+}
+
+} // namespace WebCore
diff --git a/Source/WebCore/inspector/InspectorStyleRule.h b/Source/WebCore/inspector/InspectorStyleRule.h
new file mode 100644
index 0000000..fef9420
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStyleRule.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef InspectorStyleRule_h
+#define InspectorStyleRule_h
+
+#include "InspectorCSSId.h"
+#include <inspector/InspectorProtocolObjects.h>
+
+namespace WebCore {
+class CSSStyleDeclaration;
+struct CSSRuleSourceData;
+struct CSSStyleSourceData;
+};
+
+namespace Inspector {
+
+class StyleRuleSet;
+struct StyleProperty;
+
+class StyleRule final : public RefCounted<StyleRule> {
+public:
+    static Ref<StyleRule> create(const CSSId& styleId, Ref<WebCore::CSSStyleDeclaration>&&, StyleRuleSet* ruleSet);
+    ~StyleRule();
+
+    WebCore::CSSStyleDeclaration& cssStyle() { return m_style.get(); }
+    RefPtr<WebCore::CSSRuleSourceData> ruleSourceData();
+    RefPtr<WebCore::CSSStyleSourceData> styleSourceData();
+    CSSId styleId() const { return m_styleId; }
+    StyleRuleSet* styleRuleSet() const { return m_ruleSet; }
+
+    bool getStyleText(String& result);
+    bool setStyleText(const String&);
+
+    // TODO: move me somewhere else.
+    RefPtr<Inspector::Protocol::CSS::CSSStyle> buildObjectForStyle();
+    Ref<Inspector::Protocol::CSS::CSSStyle> buildObjectForStyleWithProperties();
+    Ref<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>> buildArrayForComputedStyle();
+private:
+    StyleRule(const CSSId& styleId, Ref<WebCore::CSSStyleDeclaration>&&, StyleRuleSet* ruleSet);
+
+    bool populateAllProperties(Vector<StyleProperty>& result);
+    String shorthandValue(const String& shorthandProperty);
+    String shorthandPriority(const String& shorthandProperty);
+    Vector<String> longhandProperties(const String& shorthandProperty);
+
+    CSSId m_styleId;
+    Ref<WebCore::CSSStyleDeclaration> m_style;
+    StyleRuleSet* m_ruleSet;
+};
+
+} // namespace Inspector
+
+#endif // InspectorStyleRule_h
diff --git a/Source/WebCore/inspector/InspectorStyleRuleSet.cpp b/Source/WebCore/inspector/InspectorStyleRuleSet.cpp
new file mode 100644
index 0000000..47b06a4
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStyleRuleSet.cpp
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "InspectorStyleRuleSet.h"
+
+#include "CSSImportRule.h"
+#include "CSSKeyframesRule.h"
+#include "CSSMediaRule.h"
+#include "CSSParser.h"
+#include "CSSRule.h"
+#include "CSSRuleList.h"
+#include "CSSSupportsRule.h"
+#include "CSSStyleSheet.h"
+#include "CSSStyleRule.h"
+#include "Element.h"
+#include "InspectorStyleRule.h"
+#include "InspectorStylesheetRuleSet.h" // For ParsedRuleSetData::create().
+#include "StyleSheetContents.h"
+
+using namespace WebCore;
+
+namespace Inspector {
+
+ParsedRuleSetData::ParsedRuleSetData(String sourceText, std::unique_ptr<RuleSourceDataList> sourceData, std::unique_ptr<StyleRuleList> styleRules)
+    : m_sourceText(sourceText)
+    , m_flattenedSourceData(WTF::move(sourceData))
+    , m_flattenedStyleRules(WTF::move(styleRules))
+{
+}
+
+static CSSParserContext parserContextForDocument(Document* document)
+{
+    return document ? CSSParserContext(*document) : strictCSSParserContext();
+}
+
+static void flattenSourceData(RuleSourceDataList& sourceDataList, RuleSourceDataList& flattenedDataList)
+{
+    for (auto& sourceData : sourceDataList) {
+        if (sourceData->type == CSSRuleSourceData::STYLE_RULE)
+            flattenedDataList.append(sourceData);
+        else if (sourceData->type == CSSRuleSourceData::MEDIA_RULE)
+            flattenSourceData(sourceData->childRules, flattenedDataList);
+        else if (sourceData->type == CSSRuleSourceData::SUPPORTS_RULE)
+            flattenSourceData(sourceData->childRules, flattenedDataList);
+    }
+}
+
+static void flattenStyleRules(CSSRuleList& ruleList, StyleRuleList& result);
+
+static void flattenStyleRules(RefPtr<CSSRule>&& rule, StyleRuleList& result)
+{
+    if (!rule)
+        return;
+
+    if (is<CSSStyleRule>(*rule)) {
+        result.append(&downcast<CSSStyleRule>(*rule));
+        return;
+    }
+
+    if (is<CSSMediaRule>(*rule))
+        flattenStyleRules(downcast<CSSMediaRule>(*rule).cssRules(), result);
+
+    if (is<CSSKeyframesRule>(*rule))
+        flattenStyleRules(downcast<CSSKeyframesRule>(*rule).cssRules(), result);
+
+    if (is<CSSSupportsRule>(*rule))
+        flattenStyleRules(downcast<CSSSupportsRule>(*rule).cssRules(), result);
+}
+
+static void flattenStyleRules(CSSRuleList& ruleList, StyleRuleList& result)
+{
+    for (unsigned i = 0; i < ruleList.length(); ++i)
+        flattenStyleRules(ruleList.item(i), result);
+}
+
+std::unique_ptr<ParsedRuleSetData> ParsedRuleSetData::create(StylesheetRuleSet& stylesheet)
+{
+    String originalStylesheetText;
+    if (!stylesheet.originalSourceText(originalStylesheetText))
+        return nullptr;
+
+    return ParsedRuleSetData::createWithText(stylesheet, originalStylesheetText);
+}
+
+std::unique_ptr<ParsedRuleSetData> ParsedRuleSetData::createEmpty()
+    {
+        return std::make_unique<ParsedRuleSetData>(emptyString(), std::make_unique<RuleSourceDataList>(), std::make_unique<StyleRuleList>());
+    }
+    
+std::unique_ptr<ParsedRuleSetData> ParsedRuleSetData::createWithText(StylesheetRuleSet& stylesheet, const String& stylesheetText)
+{
+    CSSParser parser(parserContextForDocument(stylesheet.ownerDocument()));
+
+    RefPtr<StyleSheetContents> contents = StyleSheetContents::create();
+    int startLine = 0;
+    auto sourceData = std::make_unique<RuleSourceDataList>();
+    parser.parseSheet(contents.get(), stylesheetText, startLine, sourceData.get());
+
+    // FIXME: This is a temporary solution to retain the original flat sourceData structure
+    // containing only style rules, even though CSSParser now provides the full rule source data tree.
+    auto flattenedSourceData = std::make_unique<RuleSourceDataList>();
+    flattenSourceData(*sourceData, *flattenedSourceData);
+
+    auto flattenedRules = std::make_unique<StyleRuleList>();
+    auto ruleTree = stylesheet.pageStyleSheet().cssRules();
+    flattenStyleRules(*ruleTree, *flattenedRules);
+
+    return std::make_unique<ParsedRuleSetData>(stylesheetText, WTF::move(flattenedSourceData), WTF::move(flattenedRules));
+}
+
+std::unique_ptr<ParsedRuleSetData> ParsedRuleSetData::create(Element& element)
+{
+    String sourceText = element.isStyledElement() ? element.getAttribute("style").string() : String();
+    auto sourceData = CSSRuleSourceData::create(CSSRuleSourceData::STYLE_RULE);
+
+    if (sourceText.isEmpty()) {
+        sourceData->ruleBodyRange.start = 0;
+        sourceData->ruleBodyRange.end = 0;
+    } else {
+        RefPtr<MutableStyleProperties> dummyDeclaration = MutableStyleProperties::create();
+        CSSParser parser(parserContextForDocument(&element.document()));
+        parser.parseDeclaration(dummyDeclaration.get(), sourceText, sourceData.get(), &element.document().elementSheet().contents());
+    }
+
+    auto sourceDataList = std::make_unique<RuleSourceDataList>(1);
+    sourceDataList->append(WTF::move(sourceData));
+
+    auto flattenedRules = std::make_unique<StyleRuleList>();
+    return std::make_unique<ParsedRuleSetData>(sourceText, WTF::move(sourceDataList), WTF::move(flattenedRules));
+}
+
+uint64_t StyleRuleSet::s_nextRuleSetId = 1;
+    
+StyleRuleSet::StyleRuleSet()
+    : m_identifier(s_nextRuleSetId++)
+{
+}
+
+StyleRuleSet::~StyleRuleSet() { }
+
+void StyleRuleSet::commitRuleSetChange(std::unique_ptr<ParsedRuleSetData> parsedData)
+{
+    m_parsedRuleSetData = WTF::move(parsedData);
+    if (m_parsedRuleSetData) // If nullptr, we can invalidate without eagerly reparsing.
+        notifyRuleSetChanged();
+}
+
+ParsedRuleSetData& StyleRuleSet::parsedRuleSetData()
+{
+    if (!m_parsedRuleSetData)
+        m_parsedRuleSetData = originalSourceData();
+
+    if (!m_parsedRuleSetData)
+        m_parsedRuleSetData = ParsedRuleSetData::createEmpty();
+
+    ASSERT(m_parsedRuleSetData);
+    return *m_parsedRuleSetData;
+}
+  
+const String& StyleRuleSet::getText()
+{
+    return parsedRuleSetData().sourceText();
+}
+
+static size_t sourceDataOrdinalForStyle(CSSStyleDeclaration& style, StyleRuleList& flattenedRules)
+{
+    for (size_t ruleOrdinal = 0; ruleOrdinal < flattenedRules.size(); ++ruleOrdinal)
+        if (&flattenedRules.at(ruleOrdinal)->style() == &style)
+            return ruleOrdinal;
+    
+    return notFound;
+}
+
+CSSId StyleRuleSet::ruleOrStyleId(CSSStyleDeclaration& style)
+{
+    auto ruleOrdinal = sourceDataOrdinalForStyle(style, parsedRuleSetData().flattenedStyleRules());
+    return (ruleOrdinal != notFound) ? CSSId(identifier(), ruleOrdinal) : CSSId();
+}
+
+RefPtr<CSSRuleSourceData> StyleRuleSet::sourceDataForRule(CSSStyleRule& rule)
+{
+    auto& rules = parsedRuleSetData().flattenedStyleRules();
+    size_t ruleOrdinal = rules.find(&rule);
+    if (ruleOrdinal == notFound)
+        return nullptr;
+    
+    auto& sourceData = parsedRuleSetData().flattenedSourceData();
+    return sourceData.at(ruleOrdinal);
+}
+
+RefPtr<CSSRuleSourceData> StyleRuleSet::sourceDataForStyle(CSSStyleDeclaration& style)
+{
+    size_t ruleOrdinal = sourceDataOrdinalForStyle(style, parsedRuleSetData().flattenedStyleRules());
+    return (ruleOrdinal != notFound) ? parsedRuleSetData().flattenedSourceData().at(ruleOrdinal) : nullptr;
+}
+    
+// FIXME: move to InspectorCSSAgent.cpp
+RefPtr<Inspector::Protocol::CSS::CSSStyle> StyleRuleSet::buildObjectForStyle(CSSStyleDeclaration& style)
+{
+    CSSId id = ruleOrStyleId(style);
+    if (id.isEmpty()) {
+        return Inspector::Protocol::CSS::CSSStyle::create()
+        .setCssProperties(Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSProperty>::create())
+        .setShorthandEntries(Inspector::Protocol::Array<Inspector::Protocol::CSS::ShorthandEntry>::create())
+        .release();
+    }
+    RefPtr<StyleRule> styleRule = inspectorStyleForId(id);
+    RefPtr<Inspector::Protocol::CSS::CSSStyle> result = styleRule->buildObjectForStyle();
+    
+    // FIXME: this should use StyleRule since it already does these computations.
+    // Style text cannot be retrieved without stylesheet, so set cssText here.
+    if (RefPtr<CSSRuleSourceData> sourceData = sourceDataForStyle(style)) {
+        String stylesheetText = getText();
+        const SourceRange& bodyRange = sourceData->ruleBodyRange;
+        result->setCssText(stylesheetText.substring(bodyRange.start, bodyRange.end - bodyRange.start));
+    }
+    
+    return WTF::move(result);
+}
+
+} // namespace Inspector
diff --git a/Source/WebCore/inspector/InspectorStyleRuleSet.h b/Source/WebCore/inspector/InspectorStyleRuleSet.h
new file mode 100644
index 0000000..3a83b34
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStyleRuleSet.h
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef InspectorStyleRuleSet_h
+#define InspectorStyleRuleSet_h
+
+#include "CSSPropertySourceData.h"
+#include <wtf/RefCounted.h>
+#include <wtf/Vector.h>
+#include <wtf/text/WTFString.h>
+
+// FIXME: remove
+#include <inspector/InspectorProtocolObjects.h>
+
+namespace WebCore {
+class CSSStyleDeclaration;
+class CSSStyleRule;
+class Document;
+class Element;
+
+typedef Vector<RefPtr<CSSStyleRule>> StyleRuleList;
+}
+
+namespace Inspector {
+
+class CSSId;
+class StyleRule;
+class StylesheetRuleSet;
+
+struct ParsedRuleSetData {
+    WTF_MAKE_NONCOPYABLE(ParsedRuleSetData);
+public:
+    ParsedRuleSetData(String, std::unique_ptr<WebCore::RuleSourceDataList>, std::unique_ptr<WebCore::StyleRuleList>);
+    static std::unique_ptr<ParsedRuleSetData> create(StylesheetRuleSet&);
+    static std::unique_ptr<ParsedRuleSetData> create(WebCore::Element&);
+    // This is used to parse modified stylesheet text. The original StyleSheetContents is
+    // immutable and will no longer match the stylesheet's text, rules and declarations.
+    static std::unique_ptr<ParsedRuleSetData> createWithText(StylesheetRuleSet&, const String& sourceText);
+    // For user and user agent stylesheets.
+    static std::unique_ptr<ParsedRuleSetData> createEmpty();
+    
+    const String& sourceText() const { return m_sourceText; }
+    WebCore::RuleSourceDataList& flattenedSourceData() const
+    {
+        ASSERT(m_flattenedSourceData);
+        return *m_flattenedSourceData;
+    }
+    WebCore::StyleRuleList& flattenedStyleRules() const
+    {
+        ASSERT(m_flattenedStyleRules);
+        return *m_flattenedStyleRules;
+    }
+
+private:
+    String m_sourceText;
+    std::unique_ptr<WebCore::RuleSourceDataList> m_flattenedSourceData;
+    std::unique_ptr<WebCore::StyleRuleList> m_flattenedStyleRules;
+};
+
+class StyleRuleSet : public RefCounted<StyleRuleSet> {
+public:
+    StyleRuleSet();
+    virtual ~StyleRuleSet();
+
+    uint64_t identifier() const { return m_identifier; }
+    virtual bool isStylesheet() const { return false; }
+    virtual bool isInlineStyle() const { return false; }
+    
+    const String& getText();
+    virtual void replaceText(const String&) = 0;
+
+    virtual std::unique_ptr<ParsedRuleSetData> originalSourceData() = 0;
+    virtual RefPtr<StyleRule> inspectorStyleForId(const CSSId&) = 0;
+
+    virtual void notifyRuleSetChanged() { }
+    virtual WebCore::CSSStyleDeclaration* styleForId(const CSSId&) = 0;
+    // FIXME: remove.
+    virtual WebCore::Document* ownerDocument() const = 0;
+    virtual bool setTextForStyle(const CSSId&, const String& text, String& oldText) = 0;
+    virtual bool setTextForStyle(WebCore::CSSStyleDeclaration&, const String&) = 0;
+    
+    RefPtr<WebCore::CSSRuleSourceData> sourceDataForStyle(WebCore::CSSStyleDeclaration& style);
+    RefPtr<WebCore::CSSRuleSourceData> sourceDataForRule(WebCore::CSSStyleRule& rule);
+
+    CSSId ruleOrStyleId(WebCore::CSSStyleDeclaration&);
+
+    // FIXME: move to InspectorCSSAgent.cpp
+    RefPtr<Inspector::Protocol::CSS::CSSRule> buildObjectForRule(WebCore::CSSStyleRule&, WebCore::Element*);
+    RefPtr<Inspector::Protocol::CSS::CSSStyle> buildObjectForStyle(WebCore::CSSStyleDeclaration&);
+protected:
+    ParsedRuleSetData& parsedRuleSetData();
+    void commitRuleSetChange(std::unique_ptr<ParsedRuleSetData>);
+
+private:
+    std::unique_ptr<ParsedRuleSetData> m_parsedRuleSetData;
+    uint64_t m_identifier;
+
+    static uint64_t s_nextRuleSetId;
+};
+   
+} // namespace Inspector
+
+#endif // InspectorStyleRuleSet_h
diff --git a/Source/WebCore/inspector/InspectorStyleSheet.cpp b/Source/WebCore/inspector/InspectorStyleSheet.cpp
deleted file mode 100644
index 2c63044..0000000
--- a/Source/WebCore/inspector/InspectorStyleSheet.cpp
+++ /dev/null
@@ -1,1363 +0,0 @@
-/*
- * Copyright (C) 2010, Google Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- * 2.  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-#include "InspectorStyleSheet.h"
-
-#include "CSSImportRule.h"
-#include "CSSKeyframesRule.h"
-#include "CSSMediaRule.h"
-#include "CSSParser.h"
-#include "CSSPropertyNames.h"
-#include "CSSPropertySourceData.h"
-#include "CSSRule.h"
-#include "CSSRuleList.h"
-#include "CSSStyleRule.h"
-#include "CSSStyleSheet.h"
-#include "CSSSupportsRule.h"
-#include "ContentSecurityPolicy.h"
-#include "Document.h"
-#include "Element.h"
-#include "HTMLHeadElement.h"
-#include "HTMLNames.h"
-#include "HTMLParserIdioms.h"
-#include "HTMLStyleElement.h"
-#include "InspectorCSSAgent.h"
-#include "InspectorPageAgent.h"
-#include "Node.h"
-#include "SVGElement.h"
-#include "SVGNames.h"
-#include "StyleProperties.h"
-#include "StyleResolver.h"
-#include "StyleRule.h"
-#include "StyleRuleImport.h"
-#include "StyleSheetContents.h"
-#include "StyleSheetList.h"
-#include <inspector/ContentSearchUtilities.h>
-#include <wtf/Noncopyable.h>
-#include <wtf/text/StringBuilder.h>
-#include <yarr/RegularExpression.h>
-
-using Inspector::Protocol::Array;
-using WebCore::RuleSourceDataList;
-using WebCore::CSSRuleSourceData;
-
-class ParsedStyleSheet {
-    WTF_MAKE_NONCOPYABLE(ParsedStyleSheet);
-    WTF_MAKE_FAST_ALLOCATED;
-public:
-    ParsedStyleSheet() { }
-
-    const String& text() const { ASSERT(m_hasText); return m_text; }
-    void setText(const String& text);
-    bool hasText() const { return m_hasText; }
-    RuleSourceDataList* sourceData() const { return m_sourceData.get(); }
-    void setSourceData(std::unique_ptr<RuleSourceDataList>);
-    bool hasSourceData() const { return m_sourceData != nullptr; }
-    RefPtr<WebCore::CSSRuleSourceData> ruleSourceDataAt(unsigned) const;
-
-private:
-    String m_text;
-    bool m_hasText {false};
-    std::unique_ptr<RuleSourceDataList> m_sourceData;
-};
-
-void ParsedStyleSheet::setText(const String& text)
-{
-    m_hasText = true;
-    m_text = text;
-    setSourceData(nullptr);
-}
-
-static void flattenSourceData(RuleSourceDataList* dataList, RuleSourceDataList* target)
-{
-    for (size_t i = 0; i < dataList->size(); ++i) {
-        RefPtr<CSSRuleSourceData>& data = dataList->at(i);
-        if (data->type == CSSRuleSourceData::STYLE_RULE)
-            target->append(data);
-        else if (data->type == CSSRuleSourceData::MEDIA_RULE)
-            flattenSourceData(&data->childRules, target);
-        else if (data->type == CSSRuleSourceData::SUPPORTS_RULE)
-            flattenSourceData(&data->childRules, target);
-    }
-}
-
-void ParsedStyleSheet::setSourceData(std::unique_ptr<RuleSourceDataList> sourceData)
-{
-    if (!sourceData) {
-        m_sourceData.reset();
-        return;
-    }
-
-    m_sourceData = std::make_unique<RuleSourceDataList>();
-
-    // FIXME: This is a temporary solution to retain the original flat sourceData structure
-    // containing only style rules, even though CSSParser now provides the full rule source data tree.
-    // Normally, we should just assign m_sourceData = sourceData;
-    flattenSourceData(sourceData.get(), m_sourceData.get());
-}
-
-RefPtr<WebCore::CSSRuleSourceData> ParsedStyleSheet::ruleSourceDataAt(unsigned index) const
-{
-    if (!hasSourceData() || index >= m_sourceData->size())
-        return nullptr;
-
-    return m_sourceData->at(index);
-}
-
-using namespace Inspector;
-
-namespace WebCore {
-
-enum class MediaListSource {
-    LinkedSheet,
-    InlineSheet,
-    MediaRule,
-    ImportRule
-};
-
-Inspector::Protocol::CSS::StyleSheetOrigin stylesheetOriginToProtocolEnum(StyleSheetOrigin origin)
-{
-    switch (origin) {
-    case StyleSheetOrigin::Inspector:
-        return Inspector::Protocol::CSS::StyleSheetOrigin::Inspector;
-    case StyleSheetOrigin::UserAgent:
-        return Inspector::Protocol::CSS::StyleSheetOrigin::UserAgent;
-    case StyleSheetOrigin::User:
-        return Inspector::Protocol::CSS::StyleSheetOrigin::User;
-    case StyleSheetOrigin::Author:
-        return Inspector::Protocol::CSS::StyleSheetOrigin::Regular;
-    default:
-        ASSERT_NOT_REACHED();
-        return Inspector::Protocol::CSS::StyleSheetOrigin::Regular;
-    }
-}
-
-static RefPtr<Inspector::Protocol::CSS::SourceRange> buildSourceRangeObject(const SourceRange& range, Vector<size_t>* lineEndings)
-{
-    if (!lineEndings)
-        return nullptr;
-    TextPosition start = ContentSearchUtilities::textPositionFromOffset(range.start, *lineEndings);
-    TextPosition end = ContentSearchUtilities::textPositionFromOffset(range.end, *lineEndings);
-
-    return Inspector::Protocol::CSS::SourceRange::create()
-        .setStartLine(start.m_line.zeroBasedInt())
-        .setStartColumn(start.m_column.zeroBasedInt())
-        .setEndLine(end.m_line.zeroBasedInt())
-        .setEndColumn(end.m_column.zeroBasedInt())
-        .release();
-}
-
-static Ref<Inspector::Protocol::CSS::CSSMedia> buildMediaObject(const MediaList* media, MediaListSource mediaListSource, const String& sourceURL)
-{
-    // Make certain compilers happy by initializing |source| up-front.
-    Inspector::Protocol::CSS::CSSMedia::Source source = Inspector::Protocol::CSS::CSSMedia::Source::InlineSheet;
-    switch (mediaListSource) {
-    case MediaListSource::MediaRule:
-        source = Inspector::Protocol::CSS::CSSMedia::Source::MediaRule;
-        break;
-    case MediaListSource::ImportRule:
-        source = Inspector::Protocol::CSS::CSSMedia::Source::ImportRule;
-        break;
-    case MediaListSource::LinkedSheet:
-        source = Inspector::Protocol::CSS::CSSMedia::Source::LinkedSheet;
-        break;
-    case MediaListSource::InlineSheet:
-        source = Inspector::Protocol::CSS::CSSMedia::Source::InlineSheet;
-        break;
-    }
-
-    auto mediaObject = Inspector::Protocol::CSS::CSSMedia::create()
-        .setText(media->mediaText())
-        .setSource(source)
-        .release();
-
-    if (!sourceURL.isEmpty()) {
-        mediaObject->setSourceURL(sourceURL);
-        mediaObject->setSourceLine(media->queries()->lastLine());
-    }
-    return WTF::move(mediaObject);
-}
-
-static RefPtr<CSSRuleList> asCSSRuleList(CSSStyleSheet* styleSheet)
-{
-    if (!styleSheet)
-        return nullptr;
-
-    RefPtr<StaticCSSRuleList> list = StaticCSSRuleList::create();
-    Vector<RefPtr<CSSRule>>& listRules = list->rules();
-    for (unsigned i = 0, size = styleSheet->length(); i < size; ++i) {
-        CSSRule* item = styleSheet->item(i);
-        if (item->type() == CSSRule::CHARSET_RULE)
-            continue;
-        listRules.append(item);
-    }
-    return WTF::move(list);
-}
-
-static RefPtr<CSSRuleList> asCSSRuleList(CSSRule* rule)
-{
-    if (!rule)
-        return nullptr;
-
-    if (is<CSSMediaRule>(*rule))
-        return &downcast<CSSMediaRule>(*rule).cssRules();
-
-    if (is<CSSKeyframesRule>(*rule))
-        return &downcast<CSSKeyframesRule>(*rule).cssRules();
-
-    if (is<CSSSupportsRule>(*rule))
-        return &downcast<CSSSupportsRule>(*rule).cssRules();
-
-    return nullptr;
-}
-
-static void fillMediaListChain(CSSRule* rule, Array<Inspector::Protocol::CSS::CSSMedia>& mediaArray)
-{
-    MediaList* mediaList;
-    CSSRule* parentRule = rule;
-    String sourceURL;
-    while (parentRule) {
-        CSSStyleSheet* parentStyleSheet = nullptr;
-        bool isMediaRule = true;
-        if (is<CSSMediaRule>(*parentRule)) {
-            CSSMediaRule& mediaRule = downcast<CSSMediaRule>(*parentRule);
-            mediaList = mediaRule.media();
-            parentStyleSheet = mediaRule.parentStyleSheet();
-        } else if (is<CSSImportRule>(*parentRule)) {
-            CSSImportRule& importRule = downcast<CSSImportRule>(*parentRule);
-            mediaList = &importRule.media();
-            parentStyleSheet = importRule.parentStyleSheet();
-            isMediaRule = false;
-        } else
-            mediaList = nullptr;
-
-        if (parentStyleSheet) {
-            sourceURL = parentStyleSheet->contents().baseURL();
-            if (sourceURL.isEmpty())
-                sourceURL = InspectorDOMAgent::documentURLString(parentStyleSheet->ownerDocument());
-        } else
-            sourceURL = "";
-
-        if (mediaList && mediaList->length())
-            mediaArray.addItem(buildMediaObject(mediaList, isMediaRule ? MediaListSource::MediaRule : MediaListSource::ImportRule, sourceURL));
-
-        if (parentRule->parentRule())
-            parentRule = parentRule->parentRule();
-        else {
-            CSSStyleSheet* styleSheet = parentRule->parentStyleSheet();
-            while (styleSheet) {
-                mediaList = styleSheet->media();
-                if (mediaList && mediaList->length()) {
-                    Document* doc = styleSheet->ownerDocument();
-                    if (doc)
-                        sourceURL = doc->url();
-                    else if (!styleSheet->contents().baseURL().isEmpty())
-                        sourceURL = styleSheet->contents().baseURL();
-                    else
-                        sourceURL = "";
-                    mediaArray.addItem(buildMediaObject(mediaList, styleSheet->ownerNode() ? MediaListSource::LinkedSheet : MediaListSource::InlineSheet, sourceURL));
-                }
-                parentRule = styleSheet->ownerRule();
-                if (parentRule)
-                    break;
-                styleSheet = styleSheet->parentStyleSheet();
-            }
-        }
-    }
-}
-
-static std::unique_ptr<CSSParser> createCSSParser(Document* document)
-{
-    return std::make_unique<CSSParser>(document ? CSSParserContext(*document) : strictCSSParserContext());
-}
-
-Ref<InspectorStyle> InspectorStyle::create(const InspectorCSSId& styleId, RefPtr<CSSStyleDeclaration>&& style, InspectorStyleSheet* parentStyleSheet)
-{
-    return adoptRef(*new InspectorStyle(styleId, WTF::move(style), parentStyleSheet));
-}
-
-InspectorStyle::InspectorStyle(const InspectorCSSId& styleId, RefPtr<CSSStyleDeclaration>&& style, InspectorStyleSheet* parentStyleSheet)
-    : m_styleId(styleId)
-    , m_style(style)
-    , m_parentStyleSheet(parentStyleSheet)
-{
-    ASSERT(m_style);
-}
-
-InspectorStyle::~InspectorStyle()
-{
-}
-
-RefPtr<Inspector::Protocol::CSS::CSSStyle> InspectorStyle::buildObjectForStyle() const
-{
-    Ref<Inspector::Protocol::CSS::CSSStyle> result = styleWithProperties();
-    if (!m_styleId.isEmpty())
-        result->setStyleId(m_styleId.asProtocolValue<Inspector::Protocol::CSS::CSSStyleId>());
-
-    result->setWidth(m_style->getPropertyValue("width"));
-    result->setHeight(m_style->getPropertyValue("height"));
-
-    RefPtr<CSSRuleSourceData> sourceData = extractSourceData();
-    if (sourceData)
-        result->setRange(buildSourceRangeObject(sourceData->ruleBodyRange, m_parentStyleSheet->lineEndings().get()));
-
-    return WTF::move(result);
-}
-
-Ref<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>> InspectorStyle::buildArrayForComputedStyle() const
-{
-    auto result = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>::create();
-    Vector<InspectorStyleProperty> properties;
-    populateAllProperties(&properties);
-
-    for (Vector<InspectorStyleProperty>::iterator it = properties.begin(), itEnd = properties.end(); it != itEnd; ++it) {
-        const CSSPropertySourceData& propertyEntry = it->sourceData;
-        auto entry = Inspector::Protocol::CSS::CSSComputedStyleProperty::create()
-            .setName(propertyEntry.name)
-            .setValue(propertyEntry.value)
-            .release();
-        result->addItem(WTF::move(entry));
-    }
-
-    return WTF::move(result);
-}
-
-bool InspectorStyle::getText(String* result) const
-{
-    // Precondition: m_parentStyleSheet->ensureParsedDataReady() has been called successfully.
-    RefPtr<CSSRuleSourceData> sourceData = extractSourceData();
-    if (!sourceData)
-        return false;
-
-    String styleSheetText;
-    bool success = m_parentStyleSheet->getText(&styleSheetText);
-    if (!success)
-        return false;
-
-    SourceRange& bodyRange = sourceData->ruleBodyRange;
-    *result = styleSheetText.substring(bodyRange.start, bodyRange.end - bodyRange.start);
-    return true;
-}
-
-bool InspectorStyle::populateAllProperties(Vector<InspectorStyleProperty>* result) const
-{
-    HashSet<String> sourcePropertyNames;
-
-    RefPtr<CSSRuleSourceData> sourceData = extractSourceData();
-    Vector<CSSPropertySourceData>* sourcePropertyData = sourceData ? &(sourceData->styleSourceData->propertyData) : nullptr;
-    if (sourcePropertyData) {
-        String styleDeclaration;
-        bool isStyleTextKnown = styleText(&styleDeclaration);
-        ASSERT_UNUSED(isStyleTextKnown, isStyleTextKnown);
-        for (Vector<CSSPropertySourceData>::const_iterator it = sourcePropertyData->begin(); it != sourcePropertyData->end(); ++it) {
-            InspectorStyleProperty p(*it, true, false);
-            p.setRawTextFromStyleDeclaration(styleDeclaration);
-            result->append(p);
-            sourcePropertyNames.add(it->name.lower());
-        }
-    }
-
-    for (int i = 0, size = m_style->length(); i < size; ++i) {
-        String name = m_style->item(i);
-        if (sourcePropertyNames.contains(name.lower()))
-            continue;
-
-        sourcePropertyNames.add(name.lower());
-        result->append(InspectorStyleProperty(CSSPropertySourceData(name, m_style->getPropertyValue(name), !m_style->getPropertyPriority(name).isEmpty(), true, SourceRange()), false, false));
-    }
-
-    return true;
-}
-
-Ref<Inspector::Protocol::CSS::CSSStyle> InspectorStyle::styleWithProperties() const
-{
-    Vector<InspectorStyleProperty> properties;
-    populateAllProperties(&properties);
-
-    auto propertiesObject = Array<Inspector::Protocol::CSS::CSSProperty>::create();
-    auto shorthandEntries = Array<Inspector::Protocol::CSS::ShorthandEntry>::create();
-    HashMap<String, RefPtr<Inspector::Protocol::CSS::CSSProperty>> propertyNameToPreviousActiveProperty;
-    HashSet<String> foundShorthands;
-    String previousPriority;
-    String previousStatus;
-    std::unique_ptr<Vector<size_t>> lineEndings(m_parentStyleSheet ? m_parentStyleSheet->lineEndings() : nullptr);
-    RefPtr<CSSRuleSourceData> sourceData = extractSourceData();
-    unsigned ruleBodyRangeStart = sourceData ? sourceData->ruleBodyRange.start : 0;
-
-    for (Vector<InspectorStyleProperty>::iterator it = properties.begin(), itEnd = properties.end(); it != itEnd; ++it) {
-        const CSSPropertySourceData& propertyEntry = it->sourceData;
-        const String& name = propertyEntry.name;
-
-        // Visual Studio disagrees with other compilers as to whether 'class' is needed here.
-#if COMPILER(MSVC)
-        enum class Protocol::CSS::CSSPropertyStatus status;
-#else
-        enum Inspector::Protocol::CSS::CSSPropertyStatus status;
-#endif
-        status = it->disabled ? Inspector::Protocol::CSS::CSSPropertyStatus::Disabled : Inspector::Protocol::CSS::CSSPropertyStatus::Active;
-
-        RefPtr<Inspector::Protocol::CSS::CSSProperty> property = Inspector::Protocol::CSS::CSSProperty::create()
-            .setName(name.lower())
-            .setValue(propertyEntry.value)
-            .release();
-
-        propertiesObject->addItem(property.copyRef());
-
-        // Default "parsedOk" == true.
-        if (!propertyEntry.parsedOk)
-            property->setParsedOk(false);
-        if (it->hasRawText())
-            property->setText(it->rawText);
-
-        // Default "priority" == "".
-        if (propertyEntry.important)
-            property->setPriority("important");
-        if (!it->disabled) {
-            if (it->hasSource) {
-                ASSERT(sourceData);
-                property->setImplicit(false);
-                // The property range is relative to the style body start.
-                // Should be converted into an absolute range (relative to the stylesheet start)
-                // for the proper conversion into line:column.
-                SourceRange absolutePropertyRange = propertyEntry.range;
-                absolutePropertyRange.start += ruleBodyRangeStart;
-                absolutePropertyRange.end += ruleBodyRangeStart;
-                property->setRange(buildSourceRangeObject(absolutePropertyRange, lineEndings.get()));
-
-                // Parsed property overrides any property with the same name. Non-parsed property overrides
-                // previous non-parsed property with the same name (if any).
-                bool shouldInactivate = false;
-                CSSPropertyID propertyId = cssPropertyID(name);
-                // Canonicalize property names to treat non-prefixed and vendor-prefixed property names the same (opacity vs. -webkit-opacity).
-                String canonicalPropertyName = propertyId ? getPropertyNameString(propertyId) : name;
-                HashMap<String, RefPtr<Inspector::Protocol::CSS::CSSProperty>>::iterator activeIt = propertyNameToPreviousActiveProperty.find(canonicalPropertyName);
-                if (activeIt != propertyNameToPreviousActiveProperty.end()) {
-                    if (propertyEntry.parsedOk) {
-                        bool successPriority = activeIt->value->getString(Inspector::Protocol::CSS::CSSProperty::Priority, previousPriority);
-                        bool successStatus = activeIt->value->getString(Inspector::Protocol::CSS::CSSProperty::Status, previousStatus);
-                        if (successStatus && previousStatus != "inactive") {
-                            if (propertyEntry.important || !successPriority) // Priority not set == "not important".
-                                shouldInactivate = true;
-                            else if (status == Inspector::Protocol::CSS::CSSPropertyStatus::Active) {
-                                // Inactivate a non-important property following the same-named important property.
-                                status = Inspector::Protocol::CSS::CSSPropertyStatus::Inactive;
-                            }
-                        }
-                    } else {
-                        bool previousParsedOk;
-                        bool success = activeIt->value->getBoolean(Inspector::Protocol::CSS::CSSProperty::ParsedOk, previousParsedOk);
-                        if (success && !previousParsedOk)
-                            shouldInactivate = true;
-                    }
-                } else
-                    propertyNameToPreviousActiveProperty.set(canonicalPropertyName, property);
-
-                if (shouldInactivate) {
-                    activeIt->value->setStatus(Inspector::Protocol::CSS::CSSPropertyStatus::Inactive);
-                    propertyNameToPreviousActiveProperty.set(canonicalPropertyName, property);
-                }
-            } else {
-                bool implicit = m_style->isPropertyImplicit(name);
-                // Default "implicit" == false.
-                if (implicit)
-                    property->setImplicit(true);
-                status = Inspector::Protocol::CSS::CSSPropertyStatus::Style;
-
-                String shorthand = m_style->getPropertyShorthand(name);
-                if (!shorthand.isEmpty()) {
-                    if (!foundShorthands.contains(shorthand)) {
-                        foundShorthands.add(shorthand);
-                        auto entry = Inspector::Protocol::CSS::ShorthandEntry::create()
-                            .setName(shorthand)
-                            .setValue(shorthandValue(shorthand))
-                            .release();
-                        shorthandEntries->addItem(WTF::move(entry));
-                    }
-                }
-            }
-        }
-
-        // Default "status" == "style".
-        if (status != Inspector::Protocol::CSS::CSSPropertyStatus::Style)
-            property->setStatus(status);
-    }
-
-    return Inspector::Protocol::CSS::CSSStyle::create()
-        .setCssProperties(WTF::move(propertiesObject))
-        .setShorthandEntries(WTF::move(shorthandEntries))
-        .release();
-}
-
-RefPtr<CSSRuleSourceData> InspectorStyle::extractSourceData() const
-{
-    if (!m_parentStyleSheet || !m_parentStyleSheet->ensureParsedDataReady())
-        return nullptr;
-    return m_parentStyleSheet->ruleSourceDataFor(m_style.get());
-}
-
-bool InspectorStyle::setText(const String& text, ExceptionCode& ec)
-{
-    return m_parentStyleSheet->setStyleText(m_style.get(), text, ec);
-}
-
-String InspectorStyle::shorthandValue(const String& shorthandProperty) const
-{
-    String value = m_style->getPropertyValue(shorthandProperty);
-    if (!value.isEmpty())
-        return value;
-    StringBuilder builder;
-    for (unsigned i = 0; i < m_style->length(); ++i) {
-        String individualProperty = m_style->item(i);
-        if (m_style->getPropertyShorthand(individualProperty) != shorthandProperty)
-            continue;
-        if (m_style->isPropertyImplicit(individualProperty))
-            continue;
-        String individualValue = m_style->getPropertyValue(individualProperty);
-        if (individualValue == "initial")
-            continue;
-        if (!builder.isEmpty())
-            builder.append(' ');
-        builder.append(individualValue);
-    }
-    return builder.toString();
-}
-
-String InspectorStyle::shorthandPriority(const String& shorthandProperty) const
-{
-    String priority = m_style->getPropertyPriority(shorthandProperty);
-    if (priority.isEmpty()) {
-        for (unsigned i = 0; i < m_style->length(); ++i) {
-            String individualProperty = m_style->item(i);
-            if (m_style->getPropertyShorthand(individualProperty) != shorthandProperty)
-                continue;
-            priority = m_style->getPropertyPriority(individualProperty);
-            break;
-        }
-    }
-    return priority;
-}
-
-Vector<String> InspectorStyle::longhandProperties(const String& shorthandProperty) const
-{
-    Vector<String> properties;
-    HashSet<String> foundProperties;
-    for (unsigned i = 0; i < m_style->length(); ++i) {
-        String individualProperty = m_style->item(i);
-        if (foundProperties.contains(individualProperty) || m_style->getPropertyShorthand(individualProperty) != shorthandProperty)
-            continue;
-
-        foundProperties.add(individualProperty);
-        properties.append(individualProperty);
-    }
-    return properties;
-}
-
-Ref<InspectorStyleSheet> InspectorStyleSheet::create(const String& id, RefPtr<CSSStyleSheet>&& pageStyleSheet, StyleSheetOrigin origin, const String& documentURL, Listener* listener)
-{
-    return adoptRef(*new InspectorStyleSheet(id, WTF::move(pageStyleSheet), origin, documentURL, listener));
-}
-
-// static
-String InspectorStyleSheet::styleSheetURL(CSSStyleSheet* pageStyleSheet)
-{
-    if (pageStyleSheet && !pageStyleSheet->contents().baseURL().isEmpty())
-        return pageStyleSheet->contents().baseURL().string();
-    return emptyString();
-}
-
-InspectorStyleSheet::InspectorStyleSheet(const String& id, RefPtr<CSSStyleSheet>&& pageStyleSheet, StyleSheetOrigin origin, const String& documentURL, Listener* listener)
-    : m_id(id)
-    , m_pageStyleSheet(WTF::move(pageStyleSheet))
-    , m_origin(origin)
-    , m_documentURL(documentURL)
-    , m_parsedStyleSheet(std::make_unique<ParsedStyleSheet>())
-    , m_listener(listener)
-{
-}
-
-InspectorStyleSheet::~InspectorStyleSheet()
-{
-}
-
-String InspectorStyleSheet::finalURL() const
-{
-    String url = styleSheetURL(m_pageStyleSheet.get());
-    return url.isEmpty() ? m_documentURL : url;
-}
-
-bool InspectorStyleSheet::isEnabled() const
-{
-    return m_pageStyleSheet && !m_pageStyleSheet->disabled();
-}
-
-String InspectorStyleSheet::title() const
-{
-    return m_pageStyleSheet ? m_pageStyleSheet->title() : ASCIILiteral("(Unknown)");
-}
-
-void InspectorStyleSheet::reparseStyleSheet(const String& text)
-{
-    {
-        // Have a separate scope for clearRules() (bug 95324).
-        CSSStyleSheet::RuleMutationScope mutationScope(m_pageStyleSheet.get());
-        m_pageStyleSheet->contents().clearRules();
-    }
-    {
-        CSSStyleSheet::RuleMutationScope mutationScope(m_pageStyleSheet.get());
-        m_pageStyleSheet->contents().parseString(text);
-        m_pageStyleSheet->clearChildRuleCSSOMWrappers();
-        fireStyleSheetChanged();
-    }
-
-    // We just wiped the entire contents of the stylesheet. Clear the mutation flag.
-    m_pageStyleSheet->clearHadRulesMutation();
-}
-
-bool InspectorStyleSheet::setText(const String& text, ExceptionCode& ec)
-{
-    if (!checkPageStyleSheet(ec))
-        return false;
-    if (!m_parsedStyleSheet)
-        return false;
-
-    m_parsedStyleSheet->setText(text);
-    m_flatRules.clear();
-
-    return true;
-}
-
-String InspectorStyleSheet::ruleSelector(const InspectorCSSId& id, ExceptionCode& ec)
-{
-    CSSStyleRule* rule = ruleForId(id);
-    if (!rule) {
-        ec = NOT_FOUND_ERR;
-        return "";
-    }
-    return rule->selectorText();
-}
-
-bool InspectorStyleSheet::setRuleSelector(const InspectorCSSId& id, const String& selector, ExceptionCode& ec)
-{
-    if (!checkPageStyleSheet(ec))
-        return false;
-    CSSStyleRule* rule = ruleForId(id);
-    if (!rule) {
-        ec = NOT_FOUND_ERR;
-        return false;
-    }
-    CSSStyleSheet* styleSheet = rule->parentStyleSheet();
-    if (!styleSheet || !ensureParsedDataReady()) {
-        ec = NOT_FOUND_ERR;
-        return false;
-    }
-
-    rule->setSelectorText(selector);
-    RefPtr<CSSRuleSourceData> sourceData = ruleSourceDataFor(&rule->style());
-    if (!sourceData) {
-        ec = NOT_FOUND_ERR;
-        return false;
-    }
-
-    String sheetText = m_parsedStyleSheet->text();
-    sheetText.replace(sourceData->ruleHeaderRange.start, sourceData->ruleHeaderRange.length(), selector);
-    m_parsedStyleSheet->setText(sheetText);
-    fireStyleSheetChanged();
-    return true;
-}
-
-static bool checkStyleRuleSelector(Document* document, const String& selector)
-{
-    CSSSelectorList selectorList;
-    createCSSParser(document)->parseSelector(selector, selectorList);
-    return selectorList.isValid();
-}
-
-CSSStyleRule* InspectorStyleSheet::addRule(const String& selector, ExceptionCode& ec)
-{
-    if (!checkPageStyleSheet(ec))
-        return nullptr;
-    if (!checkStyleRuleSelector(m_pageStyleSheet->ownerDocument(), selector)) {
-        ec = SYNTAX_ERR;
-        return nullptr;
-    }
-
-    String text;
-    bool success = getText(&text);
-    if (!success) {
-        ec = NOT_FOUND_ERR;
-        return nullptr;
-    }
-    StringBuilder styleSheetText;
-    styleSheetText.append(text);
-
-    m_pageStyleSheet->addRule(selector, "", ec);
-    if (ec)
-        return nullptr;
-    ASSERT(m_pageStyleSheet->length());
-    unsigned lastRuleIndex = m_pageStyleSheet->length() - 1;
-    CSSRule* rule = m_pageStyleSheet->item(lastRuleIndex);
-    ASSERT(rule);
-
-    CSSStyleRule* styleRule = InspectorCSSAgent::asCSSStyleRule(*rule);
-    if (!styleRule) {
-        // What we just added has to be a CSSStyleRule - we cannot handle other types of rules yet.
-        // If it is not a style rule, pretend we never touched the stylesheet.
-        m_pageStyleSheet->deleteRule(lastRuleIndex, ASSERT_NO_EXCEPTION);
-        ec = SYNTAX_ERR;
-        return nullptr;
-    }
-
-    if (!styleSheetText.isEmpty())
-        styleSheetText.append('\n');
-
-    styleSheetText.append(selector);
-    styleSheetText.appendLiteral(" {}");
-    // Using setText() as this operation changes the style sheet rule set.
-    setText(styleSheetText.toString(), ASSERT_NO_EXCEPTION);
-
-    fireStyleSheetChanged();
-
-    return styleRule;
-}
-
-bool InspectorStyleSheet::deleteRule(const InspectorCSSId& id, ExceptionCode& ec)
-{
-    if (!checkPageStyleSheet(ec))
-        return false;
-    RefPtr<CSSStyleRule> rule = ruleForId(id);
-    if (!rule) {
-        ec = NOT_FOUND_ERR;
-        return false;
-    }
-    CSSStyleSheet* styleSheet = rule->parentStyleSheet();
-    if (!styleSheet || !ensureParsedDataReady()) {
-        ec = NOT_FOUND_ERR;
-        return false;
-    }
-
-    RefPtr<CSSRuleSourceData> sourceData = ruleSourceDataFor(&rule->style());
-    if (!sourceData) {
-        ec = NOT_FOUND_ERR;
-        return false;
-    }
-
-    styleSheet->deleteRule(id.ordinal(), ec);
-    // |rule| MAY NOT be addressed after this line!
-
-    if (ec)
-        return false;
-
-    String sheetText = m_parsedStyleSheet->text();
-    sheetText.remove(sourceData->ruleHeaderRange.start, sourceData->ruleBodyRange.end - sourceData->ruleHeaderRange.start + 1);
-    setText(sheetText, ASSERT_NO_EXCEPTION);
-    fireStyleSheetChanged();
-    return true;
-}
-
-CSSStyleRule* InspectorStyleSheet::ruleForId(const InspectorCSSId& id) const
-{
-    if (!m_pageStyleSheet)
-        return nullptr;
-
-    ASSERT(!id.isEmpty());
-    ensureFlatRules();
-    return id.ordinal() >= m_flatRules.size() ? nullptr : m_flatRules.at(id.ordinal()).get();
-}
-
-
-    
-RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody> InspectorStyleSheet::buildObjectForStyleSheet()
-{
-    CSSStyleSheet* styleSheet = pageStyleSheet();
-    if (!styleSheet)
-        return nullptr;
-
-    RefPtr<CSSRuleList> cssRuleList = asCSSRuleList(styleSheet);
-
-    auto result = Inspector::Protocol::CSS::CSSStyleSheetBody::create()
-        .setStyleSheetId(id())
-        .setRules(buildArrayForRuleList(cssRuleList.get()))
-        .release();
-
-    String styleSheetText;
-    bool success = getText(&styleSheetText);
-    if (success)
-        result->setText(styleSheetText);
-
-    return WTF::move(result);
-}
-
-static Ref<Inspector::Protocol::CSS::CSSSelector> buildObjectForSelector(const CSSSelector& selector, Element* element);
-static Ref<Inspector::Protocol::CSS::CSSSelector> buildObjectForSelectorText(const String& selectorText, const CSSSelector& selector, Element* element);
-    
-static bool hasDynamicSpecificity(const CSSSelector& simpleSelector)
-{
-    // It is possible that these can have a static specificity if each selector in the list has
-    // equal specificity, but lets always report that they can be dynamic.
-    for (const CSSSelector* selector = &simpleSelector; selector; selector = selector->tagHistory()) {
-        if (selector->match() == CSSSelector::PseudoClass) {
-            CSSSelector::PseudoClassType pseudoClassType = selector->pseudoClassType();
-            if (pseudoClassType == CSSSelector::PseudoClassMatches)
-                return true;
-            if (pseudoClassType == CSSSelector::PseudoClassNthChild || pseudoClassType == CSSSelector::PseudoClassNthLastChild) {
-                if (selector->selectorList())
-                    return true;
-                return false;
-            }
-        }
-    }
-
-    return false;
-}
-
-static Ref<Inspector::Protocol::CSS::CSSSelector> buildObjectForSelector(const CSSSelector& selector, Element* element)
-{
-    return buildObjectForSelectorText(selector.selectorText(), selector, element);
-}
-
-static Ref<Inspector::Protocol::CSS::CSSSelector> buildObjectForSelectorText(const String& selectorText, const CSSSelector& selector, Element* element)
-{
-    auto inspectorSelector = Inspector::Protocol::CSS::CSSSelector::create()
-        .setText(selectorText)
-        .release();
-
-    if (element) {
-        bool dynamic = hasDynamicSpecificity(selector);
-        if (dynamic)
-            inspectorSelector->setDynamic(true);
-
-        SelectorChecker::CheckingContext context(SelectorChecker::Mode::CollectingRules);
-        SelectorChecker selectorChecker(element->document());
-
-        unsigned specificity;
-        bool okay = selectorChecker.match(&selector, element, context, specificity);
-        if (!okay)
-            specificity = selector.staticSpecificity(okay);
-
-        if (okay) {
-            auto tuple = Inspector::Protocol::Array<int>::create();
-            tuple->addItem(static_cast<int>((specificity & CSSSelector::idMask) >> 16));
-            tuple->addItem(static_cast<int>((specificity & CSSSelector::classMask) >> 8));
-            tuple->addItem(static_cast<int>(specificity & CSSSelector::elementMask));
-            inspectorSelector->setSpecificity(WTF::move(tuple));
-        }
-    }
-
-    return WTF::move(inspectorSelector);
-}
-
-static Ref<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSSelector>> selectorsFromSource(const CSSRuleSourceData* sourceData, const String& sheetText, const CSSSelectorList& selectorList, Element* element)
-{
-    NeverDestroyed<JSC::Yarr::RegularExpression> comment("/\\*[^]*?\\*/", TextCaseSensitive, JSC::Yarr::MultilineEnabled);
-
-    auto result = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSSelector>::create();
-    const SelectorRangeList& ranges = sourceData->selectorRanges;
-    const CSSSelector* selector = selectorList.first();
-    for (size_t i = 0, size = ranges.size(); i < size; ++i) {
-        // If we don't have a selector, that means the SourceData for this CSSStyleSheet
-        // no longer matches up with the actual rules in the CSSStyleSheet.
-        ASSERT(selector);
-        if (!selector)
-            break;
-
-        const SourceRange& range = ranges.at(i);
-        String selectorText = sheetText.substring(range.start, range.length());
-
-        // We don't want to see any comments in the selector components, only the meaningful parts.
-        replace(selectorText, comment, String());
-        result->addItem(buildObjectForSelectorText(selectorText.stripWhiteSpace(), *selector, element));
-
-        selector = CSSSelectorList::next(selector);
-    }
-    return WTF::move(result);
-}
-
-Ref<Inspector::Protocol::CSS::SelectorList> InspectorStyleSheet::buildObjectForSelectorList(CSSStyleRule* rule, Element* element)
-{
-    RefPtr<CSSRuleSourceData> sourceData;
-    if (ensureParsedDataReady())
-        sourceData = ruleSourceDataFor(&rule->style());
-    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSSelector>> selectors;
-
-    // This intentionally does not rely on the source data to avoid catching the trailing comments (before the declaration starting '{').
-    String selectorText = rule->selectorText();
-
-    if (sourceData)
-        selectors = selectorsFromSource(sourceData.get(), m_parsedStyleSheet->text(), rule->styleRule().selectorList(), element);
-    else {
-        selectors = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSSelector>::create();
-        const CSSSelectorList& selectorList = rule->styleRule().selectorList();
-        for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
-            if (selector)
-                selectors->addItem(buildObjectForSelector(*selector, element));
-    }
-    auto result = Inspector::Protocol::CSS::SelectorList::create()
-        .setSelectors(selectors.release())
-        .setText(selectorText)
-        .release();
-    if (sourceData)
-        result->setRange(buildSourceRangeObject(sourceData->ruleHeaderRange, lineEndings().get()));
-    return WTF::move(result);
-}
-
-RefPtr<Inspector::Protocol::CSS::CSSRule> InspectorStyleSheet::buildObjectForRule(CSSStyleRule* rule, Element* element)
-{
-    CSSStyleSheet* styleSheet = pageStyleSheet();
-    if (!styleSheet)
-        return nullptr;
-
-    auto result = Inspector::Protocol::CSS::CSSRule::create()
-        .setSelectorList(buildObjectForSelectorList(rule, element))
-        .setSourceLine(rule->styleRule().sourceLine())
-        .setOrigin(stylesheetOriginToProtocolEnum(m_origin))
-        .setStyle(buildObjectForStyle(&rule->style()))
-        .release();
-
-    // "sourceURL" is present only for regular rules, otherwise "origin" should be used in the frontend.
-    if (m_origin == StyleSheetOrigin::Author)
-        result->setSourceURL(finalURL());
-
-    if (canBind()) {
-        InspectorCSSId id(ruleId(rule));
-        if (!id.isEmpty())
-            result->setRuleId(id.asProtocolValue<Inspector::Protocol::CSS::CSSRuleId>());
-    }
-
-    auto mediaArray = Array<Inspector::Protocol::CSS::CSSMedia>::create();
-
-    fillMediaListChain(rule, mediaArray.get());
-    if (mediaArray->length())
-        result->setMedia(WTF::move(mediaArray));
-
-    return WTF::move(result);
-}
-
-RefPtr<Inspector::Protocol::CSS::CSSStyle> InspectorStyleSheet::buildObjectForStyle(CSSStyleDeclaration* style)
-{
-    RefPtr<CSSRuleSourceData> sourceData;
-    if (ensureParsedDataReady())
-        sourceData = ruleSourceDataFor(style);
-
-    InspectorCSSId id = ruleOrStyleId(style);
-    if (id.isEmpty()) {
-        return Inspector::Protocol::CSS::CSSStyle::create()
-            .setCssProperties(Array<Inspector::Protocol::CSS::CSSProperty>::create())
-            .setShorthandEntries(Array<Inspector::Protocol::CSS::ShorthandEntry>::create())
-            .release();
-    }
-    RefPtr<InspectorStyle> inspectorStyle = inspectorStyleForId(id);
-    RefPtr<Inspector::Protocol::CSS::CSSStyle> result = inspectorStyle->buildObjectForStyle();
-
-    // Style text cannot be retrieved without stylesheet, so set cssText here.
-    if (sourceData) {
-        String sheetText;
-        bool success = getText(&sheetText);
-        if (success) {
-            const SourceRange& bodyRange = sourceData->ruleBodyRange;
-            result->setCssText(sheetText.substring(bodyRange.start, bodyRange.end - bodyRange.start));
-        }
-    }
-
-    return WTF::move(result);
-}
-
-bool InspectorStyleSheet::setStyleText(const InspectorCSSId& id, const String& text, String* oldText, ExceptionCode& ec)
-{
-    RefPtr<InspectorStyle> inspectorStyle = inspectorStyleForId(id);
-    if (!inspectorStyle) {
-        ec = NOT_FOUND_ERR;
-        return false;
-    }
-
-    if (oldText && !inspectorStyle->getText(oldText))
-        return false;
-
-    bool success = inspectorStyle->setText(text, ec);
-    if (success)
-        fireStyleSheetChanged();
-    return success;
-}
-
-bool InspectorStyleSheet::getText(String* result) const
-{
-    if (!ensureText())
-        return false;
-    *result = m_parsedStyleSheet->text();
-    return true;
-}
-
-CSSStyleDeclaration* InspectorStyleSheet::styleForId(const InspectorCSSId& id) const
-{
-    CSSStyleRule* rule = ruleForId(id);
-    if (!rule)
-        return nullptr;
-
-    return &rule->style();
-}
-
-void InspectorStyleSheet::fireStyleSheetChanged()
-{
-    if (m_listener)
-        m_listener->styleSheetChanged(*this);
-}
-
-RefPtr<InspectorStyle> InspectorStyleSheet::inspectorStyleForId(const InspectorCSSId& id)
-{
-    CSSStyleDeclaration* style = styleForId(id);
-    if (!style)
-        return nullptr;
-
-    return InspectorStyle::create(id, style, this);
-}
-
-InspectorCSSId InspectorStyleSheet::ruleOrStyleId(CSSStyleDeclaration* style) const
-{
-    unsigned index = ruleIndexByStyle(style);
-    if (index != UINT_MAX)
-        return InspectorCSSId(id(), index);
-    return InspectorCSSId();
-}
-
-Document* InspectorStyleSheet::ownerDocument() const
-{
-    return m_pageStyleSheet->ownerDocument();
-}
-
-RefPtr<CSSRuleSourceData> InspectorStyleSheet::ruleSourceDataFor(CSSStyleDeclaration* style) const
-{
-    return m_parsedStyleSheet->ruleSourceDataAt(ruleIndexByStyle(style));
-}
-
-std::unique_ptr<Vector<size_t>> InspectorStyleSheet::lineEndings() const
-{
-    if (!m_parsedStyleSheet->hasText())
-        return nullptr;
-    return ContentSearchUtilities::lineEndings(m_parsedStyleSheet->text());
-}
-
-unsigned InspectorStyleSheet::ruleIndexByStyle(CSSStyleDeclaration* pageStyle) const
-{
-    ensureFlatRules();
-    unsigned index = 0;
-    for (unsigned i = 0, size = m_flatRules.size(); i < size; ++i) {
-        if (&m_flatRules.at(i)->style() == pageStyle)
-            return index;
-
-        ++index;
-    }
-    return UINT_MAX;
-}
-
-bool InspectorStyleSheet::checkPageStyleSheet(ExceptionCode& ec) const
-{
-    if (!m_pageStyleSheet) {
-        ec = NOT_SUPPORTED_ERR;
-        return false;
-    }
-    return true;
-}
-
-bool InspectorStyleSheet::styleSheetMutated() const
-{
-    return m_pageStyleSheet && m_pageStyleSheet->hadRulesMutation();
-}
-
-bool InspectorStyleSheet::ensureParsedDataReady()
-{
-    return !styleSheetMutated() && ensureText() && ensureSourceData();
-}
-
-bool InspectorStyleSheet::ensureText() const
-{
-    if (!m_parsedStyleSheet)
-        return false;
-    if (m_parsedStyleSheet->hasText())
-        return true;
-
-    String text;
-    bool success = originalStyleSheetText(&text);
-    if (success)
-        m_parsedStyleSheet->setText(text);
-    // No need to clear m_flatRules here - it's empty.
-
-    return success;
-}
-
-bool InspectorStyleSheet::ensureSourceData()
-{
-    if (m_parsedStyleSheet->hasSourceData())
-        return true;
-
-    if (!m_parsedStyleSheet->hasText())
-        return false;
-
-    RefPtr<StyleSheetContents> newStyleSheet = StyleSheetContents::create();
-    auto ruleSourceDataResult = std::make_unique<RuleSourceDataList>();
-    createCSSParser(m_pageStyleSheet->ownerDocument())->parseSheet(newStyleSheet.get(), m_parsedStyleSheet->text(), 0, ruleSourceDataResult.get());
-    m_parsedStyleSheet->setSourceData(WTF::move(ruleSourceDataResult));
-    return m_parsedStyleSheet->hasSourceData();
-}
-
-void InspectorStyleSheet::ensureFlatRules() const
-{
-    // We are fine with redoing this for empty stylesheets as this will run fast.
-    if (m_flatRules.isEmpty())
-        collectFlatRules(asCSSRuleList(pageStyleSheet()), &m_flatRules);
-}
-
-bool InspectorStyleSheet::setStyleText(CSSStyleDeclaration* style, const String& text, ExceptionCode& ec)
-{
-    if (!m_pageStyleSheet)
-        return false;
-    if (!ensureParsedDataReady())
-        return false;
-
-    String patchedStyleSheetText;
-    bool success = styleSheetTextWithChangedStyle(style, text, &patchedStyleSheetText);
-    if (!success)
-        return false;
-
-    InspectorCSSId id = ruleOrStyleId(style);
-    if (id.isEmpty())
-        return false;
-
-    style->setCssText(text, ec);
-    if (!ec)
-        m_parsedStyleSheet->setText(patchedStyleSheetText);
-
-    return !ec;
-}
-
-bool InspectorStyleSheet::styleSheetTextWithChangedStyle(CSSStyleDeclaration* style, const String& newStyleText, String* result)
-{
-    if (!style)
-        return false;
-
-    if (!ensureParsedDataReady())
-        return false;
-
-    RefPtr<CSSRuleSourceData> sourceData = ruleSourceDataFor(style);
-    unsigned bodyStart = sourceData->ruleBodyRange.start;
-    unsigned bodyEnd = sourceData->ruleBodyRange.end;
-    ASSERT(bodyStart <= bodyEnd);
-
-    String text = m_parsedStyleSheet->text();
-    ASSERT_WITH_SECURITY_IMPLICATION(bodyEnd <= text.length()); // bodyEnd is exclusive
-
-    text.replace(bodyStart, bodyEnd - bodyStart, newStyleText);
-    *result = text;
-    return true;
-}
-
-InspectorCSSId InspectorStyleSheet::ruleId(CSSStyleRule* rule) const
-{
-    return ruleOrStyleId(&rule->style());
-}
-
-bool InspectorStyleSheet::originalStyleSheetText(String* result) const
-{
-    bool success = inlineStyleSheetText(result);
-    if (!success)
-        success = resourceStyleSheetText(result);
-    return success;
-}
-
-bool InspectorStyleSheet::resourceStyleSheetText(String* result) const
-{
-    if (m_origin == StyleSheetOrigin::User || m_origin == StyleSheetOrigin::UserAgent)
-        return false;
-
-    if (!m_pageStyleSheet || !ownerDocument() || !ownerDocument()->frame())
-        return false;
-
-    String error;
-    bool base64Encoded;
-    InspectorPageAgent::resourceContent(error, ownerDocument()->frame(), URL(ParsedURLString, m_pageStyleSheet->href()), result, &base64Encoded);
-    return error.isEmpty() && !base64Encoded;
-}
-
-bool InspectorStyleSheet::inlineStyleSheetText(String* result) const
-{
-    if (!m_pageStyleSheet)
-        return false;
-
-    Node* ownerNode = m_pageStyleSheet->ownerNode();
-    if (!is<Element>(ownerNode))
-        return false;
-    Element& ownerElement = downcast<Element>(*ownerNode);
-
-    if (!is<HTMLStyleElement>(ownerElement) && !is<SVGStyleElement>(ownerElement))
-        return false;
-    *result = ownerElement.textContent();
-    return true;
-}
-
-Ref<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSRule>> InspectorStyleSheet::buildArrayForRuleList(CSSRuleList* ruleList)
-{
-    auto result = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSRule>::create();
-    if (!ruleList)
-        return WTF::move(result);
-
-    RefPtr<CSSRuleList> refRuleList = ruleList;
-    CSSStyleRuleVector rules;
-    collectFlatRules(WTF::move(refRuleList), &rules);
-
-    for (unsigned i = 0, size = rules.size(); i < size; ++i)
-        result->addItem(buildObjectForRule(rules.at(i).get(), nullptr));
-
-    return WTF::move(result);
-}
-
-void InspectorStyleSheet::collectFlatRules(RefPtr<CSSRuleList>&& ruleList, CSSStyleRuleVector* result)
-{
-    if (!ruleList)
-        return;
-
-    for (unsigned i = 0, size = ruleList->length(); i < size; ++i) {
-        CSSRule* rule = ruleList->item(i);
-        CSSStyleRule* styleRule = InspectorCSSAgent::asCSSStyleRule(*rule);
-        if (styleRule)
-            result->append(styleRule);
-        else {
-            RefPtr<CSSRuleList> childRuleList = asCSSRuleList(rule);
-            if (childRuleList)
-                collectFlatRules(WTF::move(childRuleList), result);
-        }
-    }
-}
-
-Ref<InspectorStyleSheetForInlineStyle> InspectorStyleSheetForInlineStyle::create(const String& id, RefPtr<Element>&& element, StyleSheetOrigin origin, Listener* listener)
-{
-    return adoptRef(*new InspectorStyleSheetForInlineStyle(id, WTF::move(element), origin, listener));
-}
-
-InspectorStyleSheetForInlineStyle::InspectorStyleSheetForInlineStyle(const String& id, RefPtr<Element>&& element, StyleSheetOrigin origin, Listener* listener)
-    : InspectorStyleSheet(id, nullptr, origin, String(), listener)
-    , m_element(WTF::move(element))
-    , m_ruleSourceData(nullptr)
-    , m_isStyleTextValid(false)
-{
-    ASSERT(m_element);
-    m_inspectorStyle = InspectorStyle::create(InspectorCSSId(id, 0), inlineStyle(), this);
-    m_styleText = m_element->isStyledElement() ? m_element->getAttribute("style").string() : String();
-}
-
-void InspectorStyleSheetForInlineStyle::didModifyElementAttribute()
-{
-    m_isStyleTextValid = false;
-    if (m_element->isStyledElement() && m_element->style() != m_inspectorStyle->cssStyle())
-        m_inspectorStyle = InspectorStyle::create(InspectorCSSId(id(), 0), inlineStyle(), this);
-    m_ruleSourceData.clear();
-}
-
-bool InspectorStyleSheetForInlineStyle::getText(String* result) const
-{
-    if (!m_isStyleTextValid) {
-        m_styleText = elementStyleText();
-        m_isStyleTextValid = true;
-    }
-    *result = m_styleText;
-    return true;
-}
-
-bool InspectorStyleSheetForInlineStyle::setStyleText(CSSStyleDeclaration* style, const String& text, ExceptionCode& ec)
-{
-    ASSERT_UNUSED(style, style == inlineStyle());
-
-    {
-        InspectorCSSAgent::InlineStyleOverrideScope overrideScope(&m_element->document());
-        m_element->setAttribute("style", text, ec);
-    }
-
-    m_styleText = text;
-    m_isStyleTextValid = true;
-    m_ruleSourceData.clear();
-    return !ec;
-}
-
-std::unique_ptr<Vector<size_t>> InspectorStyleSheetForInlineStyle::lineEndings() const
-{
-    return ContentSearchUtilities::lineEndings(elementStyleText());
-}
-
-Document* InspectorStyleSheetForInlineStyle::ownerDocument() const
-{
-    return &m_element->document();
-}
-
-bool InspectorStyleSheetForInlineStyle::ensureParsedDataReady()
-{
-    // The "style" property value can get changed indirectly, e.g. via element.style.borderWidth = "2px".
-    const String& currentStyleText = elementStyleText();
-    if (m_styleText != currentStyleText) {
-        m_ruleSourceData.clear();
-        m_styleText = currentStyleText;
-        m_isStyleTextValid = true;
-    }
-
-    if (m_ruleSourceData)
-        return true;
-
-    m_ruleSourceData = CSSRuleSourceData::create(CSSRuleSourceData::STYLE_RULE);
-    bool success = getStyleAttributeRanges(m_ruleSourceData.get());
-    if (!success)
-        return false;
-
-    return true;
-}
-
-RefPtr<InspectorStyle> InspectorStyleSheetForInlineStyle::inspectorStyleForId(const InspectorCSSId& id)
-{
-    ASSERT_UNUSED(id, !id.ordinal());
-    return m_inspectorStyle.copyRef();
-}
-
-CSSStyleDeclaration* InspectorStyleSheetForInlineStyle::inlineStyle() const
-{
-    return m_element->style();
-}
-
-const String& InspectorStyleSheetForInlineStyle::elementStyleText() const
-{
-    return m_element->getAttribute("style").string();
-}
-
-bool InspectorStyleSheetForInlineStyle::getStyleAttributeRanges(CSSRuleSourceData* result) const
-{
-    if (!m_element->isStyledElement())
-        return false;
-
-    if (m_styleText.isEmpty()) {
-        result->ruleBodyRange.start = 0;
-        result->ruleBodyRange.end = 0;
-        return true;
-    }
-
-    RefPtr<MutableStyleProperties> tempDeclaration = MutableStyleProperties::create();
-    createCSSParser(&m_element->document())->parseDeclaration(tempDeclaration.get(), m_styleText, result, &m_element->document().elementSheet().contents());
-    return true;
-}
-
-} // namespace WebCore
diff --git a/Source/WebCore/inspector/InspectorStyleSheet.h b/Source/WebCore/inspector/InspectorStyleSheet.h
deleted file mode 100644
index 7919dcb..0000000
--- a/Source/WebCore/inspector/InspectorStyleSheet.h
+++ /dev/null
@@ -1,294 +0,0 @@
-/*
- * Copyright (C) 2010, Google Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- * 2.  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef InspectorStyleSheet_h
-#define InspectorStyleSheet_h
-
-#include "CSSPropertySourceData.h"
-#include "CSSStyleDeclaration.h"
-#include "ExceptionCode.h"
-#include <inspector/InspectorProtocolObjects.h>
-#include <inspector/InspectorValues.h>
-#include <wtf/HashMap.h>
-#include <wtf/HashSet.h>
-#include <wtf/RefPtr.h>
-#include <wtf/Vector.h>
-#include <wtf/text/WTFString.h>
-
-class ParsedStyleSheet;
-
-namespace WebCore {
-
-class CSSRuleList;
-class CSSSelector;
-class CSSStyleDeclaration;
-class CSSStyleRule;
-class CSSStyleSheet;
-class Document;
-class Element;
-class InspectorPageAgent;
-class InspectorStyleSheet;
-
-typedef String ErrorString;
-
-class InspectorCSSId {
-public:
-    InspectorCSSId() { }
-
-    explicit InspectorCSSId(const RefPtr<Inspector::InspectorObject>&& value)
-    {
-        if (!value->getString(ASCIILiteral("styleSheetId"), m_styleSheetId))
-            return;
-
-        if (!value->getInteger(ASCIILiteral("ordinal"), m_ordinal))
-            m_styleSheetId = String();
-    }
-
-    InspectorCSSId(const String& styleSheetId, unsigned ordinal)
-        : m_styleSheetId(styleSheetId)
-        , m_ordinal(ordinal)
-    {
-    }
-
-    bool isEmpty() const { return m_styleSheetId.isEmpty(); }
-
-    const String& styleSheetId() const { return m_styleSheetId; }
-    unsigned ordinal() const { return m_ordinal; }
-
-    // ID type is either Inspector::Protocol::CSS::CSSStyleId or Inspector::Protocol::CSS::CSSRuleId.
-    template<typename ID>
-    RefPtr<ID> asProtocolValue() const
-    {
-        if (isEmpty())
-            return nullptr;
-
-        return ID::create()
-            .setStyleSheetId(m_styleSheetId)
-            .setOrdinal(m_ordinal)
-            .release();
-    }
-
-private:
-    String m_styleSheetId;
-    unsigned m_ordinal = {0};
-};
-
-struct InspectorStyleProperty {
-    InspectorStyleProperty()
-        : hasSource(false)
-        , disabled(false)
-    {
-    }
-
-    InspectorStyleProperty(CSSPropertySourceData sourceData, bool hasSource, bool disabled)
-        : sourceData(sourceData)
-        , hasSource(hasSource)
-        , disabled(disabled)
-    {
-    }
-
-    void setRawTextFromStyleDeclaration(const String& styleDeclaration)
-    {
-        unsigned start = sourceData.range.start;
-        unsigned end = sourceData.range.end;
-        ASSERT_WITH_SECURITY_IMPLICATION(start < end);
-        ASSERT(end <= styleDeclaration.length());
-        rawText = styleDeclaration.substring(start, end - start);
-    }
-
-    bool hasRawText() const { return !rawText.isEmpty(); }
-
-    CSSPropertySourceData sourceData;
-    bool hasSource;
-    bool disabled;
-    String rawText;
-};
-
-class InspectorStyle final : public RefCounted<InspectorStyle> {
-public:
-    static Ref<InspectorStyle> create(const InspectorCSSId& styleId, RefPtr<CSSStyleDeclaration>&&, InspectorStyleSheet* parentStyleSheet);
-    ~InspectorStyle();
-
-    CSSStyleDeclaration* cssStyle() const { return m_style.get(); }
-    RefPtr<Inspector::Protocol::CSS::CSSStyle> buildObjectForStyle() const;
-    Ref<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSComputedStyleProperty>> buildArrayForComputedStyle() const;
-
-    bool getText(String* result) const;
-    bool setText(const String&, ExceptionCode&);
-
-private:
-    InspectorStyle(const InspectorCSSId& styleId, RefPtr<CSSStyleDeclaration>&&, InspectorStyleSheet* parentStyleSheet);
-
-    // FIXME: Remove these aliases and update all the current call sites to use the new public methods.
-    bool styleText(String* result) const { return getText(result); }
-    bool applyStyleText(const String& text) { ExceptionCode ec = 0; return setText(text, ec); }
-
-    bool populateAllProperties(Vector<InspectorStyleProperty>* result) const;
-    Ref<Inspector::Protocol::CSS::CSSStyle> styleWithProperties() const;
-    RefPtr<CSSRuleSourceData> extractSourceData() const;
-    String shorthandValue(const String& shorthandProperty) const;
-    String shorthandPriority(const String& shorthandProperty) const;
-    Vector<String> longhandProperties(const String& shorthandProperty) const;
-
-    InspectorCSSId m_styleId;
-    RefPtr<CSSStyleDeclaration> m_style;
-    InspectorStyleSheet* m_parentStyleSheet;
-};
-
-enum class StyleSheetOrigin {
-    Inspector,
-    UserAgent,
-    User,
-    Author
-};
-
-class InspectorStyleSheet : public RefCounted<InspectorStyleSheet> {
-public:
-    class Listener {
-    public:
-        Listener() { }
-        virtual ~Listener() { }
-        virtual void styleSheetChanged(InspectorStyleSheet&) = 0;
-    };
-
-    static Ref<InspectorStyleSheet> create(const String& id, RefPtr<CSSStyleSheet>&& pageStyleSheet, StyleSheetOrigin, const String& documentURL, Listener*);
-    static String styleSheetURL(CSSStyleSheet* pageStyleSheet);
-
-    virtual ~InspectorStyleSheet();
-
-    String id() const { return m_id; }
-    String finalURL() const;
-    String title() const;
-    StyleSheetOrigin origin() const { return m_origin; }
-    bool isEnabled() const;
-
-    CSSStyleSheet* pageStyleSheet() const { return m_pageStyleSheet.get(); }
-    virtual Document* ownerDocument() const;
-
-    String ruleSelector(const InspectorCSSId&, ExceptionCode&);
-    bool setRuleSelector(const InspectorCSSId&, const String& selector, ExceptionCode&);
-
-    virtual bool getText(String* result) const;
-    bool setText(const String&, ExceptionCode&);
-
-    CSSStyleRule* addRule(const String& selector, ExceptionCode&);
-    bool deleteRule(const InspectorCSSId&, ExceptionCode&);
-
-    void reparseStyleSheet(const String&);
-    bool setStyleText(const InspectorCSSId&, const String& text, String* oldText, ExceptionCode&);
-
-    InspectorCSSId ruleId(CSSStyleRule*) const;
-    CSSStyleRule* ruleForId(const InspectorCSSId&) const;
-    InspectorCSSId styleId(CSSStyleDeclaration* style) const { return ruleOrStyleId(style); }
-    virtual CSSStyleDeclaration* styleForId(const InspectorCSSId&) const;
-
-    RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody> buildObjectForStyleSheet();
-    RefPtr<Inspector::Protocol::CSS::CSSRule> buildObjectForRule(CSSStyleRule*, Element*);
-    RefPtr<Inspector::Protocol::CSS::CSSStyle> buildObjectForStyle(CSSStyleDeclaration*);
-
-    void fireStyleSheetChanged();
-
-protected:
-    InspectorStyleSheet(const String& id, RefPtr<CSSStyleSheet>&& pageStyleSheet, StyleSheetOrigin, const String& documentURL, Listener*);
-
-    bool canBind() const { return m_origin != StyleSheetOrigin::UserAgent && m_origin != StyleSheetOrigin::User; }
-    InspectorCSSId ruleOrStyleId(CSSStyleDeclaration*) const;
-    virtual RefPtr<InspectorStyle> inspectorStyleForId(const InspectorCSSId&);
-
-    virtual RefPtr<CSSRuleSourceData> ruleSourceDataFor(CSSStyleDeclaration*) const;
-    virtual unsigned ruleIndexByStyle(CSSStyleDeclaration*) const;
-    virtual bool ensureParsedDataReady();
-
-    // Also accessed by friend class InspectorStyle.
-    virtual bool setStyleText(CSSStyleDeclaration*, const String&, ExceptionCode&);
-    virtual std::unique_ptr<Vector<size_t>> lineEndings() const;
-
-private:
-    typedef Vector<RefPtr<CSSStyleRule>> CSSStyleRuleVector;
-    friend class InspectorStyle;
-
-    static void collectFlatRules(RefPtr<CSSRuleList>&&, CSSStyleRuleVector* result);
-    bool checkPageStyleSheet(ExceptionCode&) const;
-    bool styleSheetMutated() const;
-    bool ensureText() const;
-    bool ensureSourceData();
-    void ensureFlatRules() const;
-    bool styleSheetTextWithChangedStyle(CSSStyleDeclaration*, const String& newStyleText, String* result);
-    bool originalStyleSheetText(String* result) const;
-    bool resourceStyleSheetText(String* result) const;
-    bool inlineStyleSheetText(String* result) const;
-    Ref<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSRule>> buildArrayForRuleList(CSSRuleList*);
-    Ref<Inspector::Protocol::CSS::SelectorList> buildObjectForSelectorList(CSSStyleRule*, Element*);
-
-    String m_id;
-    RefPtr<CSSStyleSheet> m_pageStyleSheet;
-    StyleSheetOrigin m_origin;
-    String m_documentURL;
-    std::unique_ptr<ParsedStyleSheet> m_parsedStyleSheet;
-    mutable CSSStyleRuleVector m_flatRules;
-    Listener* m_listener;
-};
-
-class InspectorStyleSheetForInlineStyle final : public InspectorStyleSheet {
-public:
-    static Ref<InspectorStyleSheetForInlineStyle> create(const String& id, RefPtr<Element>&&, StyleSheetOrigin, Listener*);
-
-    virtual Document* ownerDocument() const override;
-
-    void didModifyElementAttribute();
-    virtual bool getText(String* result) const override;
-    virtual CSSStyleDeclaration* styleForId(const InspectorCSSId& id) const override { ASSERT_UNUSED(id, !id.ordinal()); return inlineStyle(); }
-
-protected:
-    InspectorStyleSheetForInlineStyle(const String& id, RefPtr<Element>&&, StyleSheetOrigin, Listener*);
-
-    virtual RefPtr<CSSRuleSourceData> ruleSourceDataFor(CSSStyleDeclaration* style) const override { ASSERT_UNUSED(style, style == inlineStyle()); return m_ruleSourceData; }
-    virtual unsigned ruleIndexByStyle(CSSStyleDeclaration*) const override { return 0; }
-    virtual bool ensureParsedDataReady() override;
-    virtual RefPtr<InspectorStyle> inspectorStyleForId(const InspectorCSSId&) override;
-
-    // Also accessed by friend class InspectorStyle.
-    virtual bool setStyleText(CSSStyleDeclaration*, const String&, ExceptionCode&) override;
-    virtual std::unique_ptr<Vector<size_t>> lineEndings() const override;
-
-private:
-    CSSStyleDeclaration* inlineStyle() const;
-    const String& elementStyleText() const;
-    bool getStyleAttributeRanges(CSSRuleSourceData* result) const;
-
-    RefPtr<Element> m_element;
-    RefPtr<CSSRuleSourceData> m_ruleSourceData;
-    RefPtr<InspectorStyle> m_inspectorStyle;
-
-    // Contains "style" attribute value.
-    mutable String m_styleText;
-    mutable bool m_isStyleTextValid;
-};
-
-// FIXME: this will eventually belong in InspectorCSSAgent.cpp.
-Inspector::Protocol::CSS::StyleSheetOrigin stylesheetOriginToProtocolEnum(StyleSheetOrigin origin);
-
-} // namespace WebCore
-
-#endif // !defined(InspectorStyleSheet_h)
diff --git a/Source/WebCore/inspector/InspectorStylesheetRuleSet.cpp b/Source/WebCore/inspector/InspectorStylesheetRuleSet.cpp
new file mode 100644
index 0000000..9f5b2d9
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStylesheetRuleSet.cpp
@@ -0,0 +1,484 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ * Copyright (C) 2015 University of Washington.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "InspectorStylesheetRuleSet.h"
+
+#include "CSSParser.h"
+#include "CSSPropertySourceData.h"
+#include "CSSSelectorList.h"
+#include "CSSStyleRule.h"
+#include "CSSStyleSheet.h"
+#include "Element.h"
+#include "HTMLStyleElement.h"
+#include "InspectorCSSAgent.h"
+#include "InspectorPageAgent.h"
+#include "InspectorStyleRule.h"
+#include "SelectorChecker.h"
+#include "StyleRule.h"
+#include "StyleSheetContents.h"
+#include "SVGStyleElement.h"
+#include <inspector/ContentSearchUtilities.h>
+#include <yarr/RegularExpression.h>
+#include <wtf/NeverDestroyed.h>
+
+using namespace WebCore;
+
+namespace Inspector {
+
+Ref<StylesheetRuleSet> StylesheetRuleSet::create(Ref<CSSStyleSheet>&& pageStyleSheet, StyleSheetOrigin origin, const String& documentURL, Listener* listener)
+{
+    return adoptRef(*new StylesheetRuleSet(WTF::move(pageStyleSheet), origin, documentURL, listener));
+}
+
+StylesheetRuleSet::StylesheetRuleSet(Ref<CSSStyleSheet>&& pageStyleSheet, StyleSheetOrigin origin, const String& documentURL, Listener* listener)
+    : StyleRuleSet()
+    , m_pageStyleSheet(WTF::move(pageStyleSheet))
+    , m_origin(origin)
+    , m_documentURL(documentURL)
+    , m_listener(listener)
+{
+}
+
+StylesheetRuleSet::~StylesheetRuleSet()
+{
+}
+
+String StylesheetRuleSet::finalURL() const
+{
+    if (!m_pageStyleSheet->contents().baseURL().isEmpty())
+        return m_pageStyleSheet->contents().baseURL().string();
+
+    return m_documentURL;
+}
+
+bool StylesheetRuleSet::isEnabled() const
+{
+    return !m_pageStyleSheet->disabled();
+}
+
+String StylesheetRuleSet::title() const
+{
+    return m_pageStyleSheet->title();
+}
+
+void StylesheetRuleSet::patchStylesheetText(const String& stylesheetText)
+{
+    commitRuleSetChange(ParsedRuleSetData::createWithText(*this, stylesheetText));
+}
+
+void StylesheetRuleSet::replaceText(const String& stylesheetText)
+{
+    {
+        // Must use a separate scope for clearRules(). https://www.webkit.org/b/95324/
+        CSSStyleSheet::RuleMutationScope mutationScope(&m_pageStyleSheet.get());
+        m_pageStyleSheet->contents().clearRules();
+    }
+    {
+        CSSStyleSheet::RuleMutationScope mutationScope(&m_pageStyleSheet.get());
+        m_pageStyleSheet->contents().parseString(stylesheetText);
+        m_pageStyleSheet->clearChildRuleCSSOMWrappers();
+    }
+
+    // We just wiped the entire contents of the stylesheet. Clear the mutation flag.
+    m_pageStyleSheet->clearHadRulesMutation();
+
+    commitRuleSetChange(ParsedRuleSetData::create(*this));
+}
+
+void StylesheetRuleSet::notifyRuleSetChanged()
+{
+    if (m_listener)
+        m_listener->styleSheetChanged(*this);
+}
+
+bool StylesheetRuleSet::selectorTextForRule(const CSSId& id, String& result)
+{
+    if (CSSStyleRule* rule = ruleForId(id)) {
+        result = rule->selectorText();
+        return true;
+    }
+
+    return false;
+}
+
+bool StylesheetRuleSet::setSelectorTextForRule(const CSSId& id, const String& selectorText)
+{
+    CSSStyleRule* rule = ruleForId(id);
+    if (!rule)
+        return false;
+
+    CSSStyleSheet* styleSheet = rule->parentStyleSheet();
+    if (!styleSheet)
+        return false;
+
+    rule->setSelectorText(selectorText);
+    RefPtr<CSSRuleSourceData> sourceData = sourceDataForRule(*rule);
+    if (!sourceData)
+        return false;
+
+    String stylesheetText = parsedRuleSetData().sourceText();
+    stylesheetText.replace(sourceData->ruleHeaderRange.start, sourceData->ruleHeaderRange.length(), selectorText);
+    patchStylesheetText(stylesheetText);
+    return true;
+}
+  
+static CSSParserContext parserContextForDocument(Document* document)
+{
+    return document ? CSSParserContext(*document) : strictCSSParserContext();
+}
+    
+static bool checkStyleRuleSelector(Document* document, const String& selector)
+{
+    CSSSelectorList selectorList;
+    CSSParser parser(parserContextForDocument(document));
+    parser.parseSelector(selector, selectorList);
+    return selectorList.isValid();
+}
+
+CSSStyleRule* StylesheetRuleSet::addRule(const String& selectorText, ExceptionCode& ec)
+{
+    if (!checkStyleRuleSelector(m_pageStyleSheet->ownerDocument(), selectorText)) {
+        ec = SYNTAX_ERR;
+        return nullptr;
+    }
+
+    String stylesheetText = getText();
+
+    m_pageStyleSheet->addRule(selectorText, "", ec);
+    if (ec)
+        return nullptr;
+    ASSERT(m_pageStyleSheet->length());
+
+    unsigned lastRuleOrdinal = m_pageStyleSheet->length() - 1;
+    CSSRule* rule = m_pageStyleSheet->item(lastRuleOrdinal);
+    if (!is<CSSStyleRule>(rule)) {
+        // What we just added has to be a CSSStyleRule - we cannot handle other types of rules yet.
+        // If it is not a style rule, pretend we never touched the stylesheet.
+        m_pageStyleSheet->deleteRule(lastRuleOrdinal, ASSERT_NO_EXCEPTION);
+        ec = SYNTAX_ERR;
+        return nullptr;
+    }
+
+    StringBuilder patchedStylesheetText;
+    patchedStylesheetText.append(stylesheetText);
+
+    if (!patchedStylesheetText.isEmpty())
+        patchedStylesheetText.append('\n');
+
+    patchedStylesheetText.append(selectorText);
+    patchedStylesheetText.appendLiteral(" {}");
+
+    patchStylesheetText(patchedStylesheetText.toString());
+
+    return downcast<CSSStyleRule>(rule);
+}
+
+bool StylesheetRuleSet::deleteRule(const CSSId& id, ExceptionCode& ec)
+{
+    RefPtr<CSSStyleRule> rule = ruleForId(id);
+    if (!rule) {
+        ec = NOT_FOUND_ERR;
+        return false;
+    }
+    RefPtr<CSSRuleSourceData> sourceData = sourceDataForRule(*rule);
+    if (!sourceData) {
+        ec = NOT_FOUND_ERR;
+        return false;
+    }
+
+    CSSStyleSheet* styleSheet = rule->parentStyleSheet();
+    styleSheet->deleteRule(id.ruleOrdinal(), ec);
+    rule = nullptr; // The rule is no longer valid, so don't keep a reference.
+
+    if (ec)
+        return false;
+
+    String stylesheetText = parsedRuleSetData().sourceText();
+    stylesheetText.remove(sourceData->ruleHeaderRange.start, sourceData->ruleBodyRange.end - sourceData->ruleHeaderRange.start + 1);
+
+    patchStylesheetText(stylesheetText);
+    return true;
+}
+
+CSSStyleRule* StylesheetRuleSet::ruleForId(const CSSId& id)
+{
+    ParsedRuleSetData& parsedData = parsedRuleSetData();
+    if (id.ruleOrdinal() >= parsedData.flattenedStyleRules().size())
+        return nullptr;
+
+    return parsedData.flattenedStyleRules().at(id.ruleOrdinal()).get();
+}
+
+bool StylesheetRuleSet::setTextForStyle(const CSSId& id, const String& text, String& oldText)
+{
+    RefPtr<StyleRule> styleRule = inspectorStyleForId(id);
+    if (!styleRule)
+        return false;
+
+    if (!styleRule->getStyleText(oldText))
+        return false;
+
+    if (!styleRule->setStyleText(text))
+        return false;
+
+    return true;
+}
+
+CSSStyleDeclaration* StylesheetRuleSet::styleForId(const CSSId& id)
+{
+    if (CSSStyleRule* rule = ruleForId(id))
+        return &rule->style();
+
+    return nullptr;
+}
+
+RefPtr<StyleRule> StylesheetRuleSet::inspectorStyleForId(const CSSId& id)
+{
+    CSSStyleDeclaration* style = styleForId(id);
+    if (!style)
+        return nullptr;
+
+    return StyleRule::create(id, *style, this);
+}
+
+Document* StylesheetRuleSet::ownerDocument() const
+{
+    return m_pageStyleSheet->ownerDocument();
+}
+
+std::unique_ptr<ParsedRuleSetData> StylesheetRuleSet::originalSourceData()
+{
+    return ParsedRuleSetData::create(*this);
+}
+
+bool StylesheetRuleSet::styleSheetMutated()
+{
+    return m_pageStyleSheet->hadRulesMutation();
+}
+
+bool StylesheetRuleSet::setTextForStyle(CSSStyleDeclaration& style, const String& text)
+{
+    String patchedStyleSheetText;
+    if (!getTextWithPatchedStyle(style, text, patchedStyleSheetText))
+        return false;
+
+    if (ruleOrStyleId(style).isEmpty())
+        return false;
+
+    ExceptionCode ec;
+    style.setCssText(text, ec);
+    if (ec)
+        return false;
+
+    commitRuleSetChange(ParsedRuleSetData::createWithText(*this, patchedStyleSheetText));
+    return true;
+}
+
+bool StylesheetRuleSet::getTextWithPatchedStyle(CSSStyleDeclaration& style, const String& newStyleText, String& result)
+{
+    RefPtr<CSSRuleSourceData> sourceData = sourceDataForStyle(style);
+    if (!sourceData)
+        return false;
+
+    unsigned bodyStart = sourceData->ruleBodyRange.start;
+    unsigned bodyEnd = sourceData->ruleBodyRange.end;
+    ASSERT(bodyStart <= bodyEnd);
+
+    String sourceText = parsedRuleSetData().sourceText();
+    ASSERT_WITH_SECURITY_IMPLICATION(bodyEnd <= sourceText.length()); // bodyEnd is exclusive
+
+    sourceText.replace(bodyStart, bodyEnd - bodyStart, newStyleText);
+    result = sourceText;
+    return true;
+}
+
+CSSId StylesheetRuleSet::ruleId(CSSStyleRule& rule)
+{
+    return ruleOrStyleId(rule.style());
+}
+
+bool StylesheetRuleSet::originalSourceText(String& result) const
+{
+    return inlineStylesheetText(result) || resourceStylesheetText(result);
+}
+
+bool StylesheetRuleSet::inlineStylesheetText(String& result) const
+{
+    Node* ownerNode = m_pageStyleSheet->ownerNode();
+    if (!is<Element>(ownerNode))
+        return false;
+    
+    Element& ownerElement = downcast<Element>(*ownerNode);
+    if (!is<HTMLStyleElement>(ownerElement) && !is<SVGStyleElement>(ownerElement))
+        return false;
+    
+    result = ownerElement.textContent();
+    return true;
+}
+    
+bool StylesheetRuleSet::resourceStylesheetText(String& result) const
+{
+    if (m_origin == StyleSheetOrigin::User || m_origin == StyleSheetOrigin::UserAgent)
+        return false;
+
+    if (!ownerDocument() || !ownerDocument()->frame())
+        return false;
+
+    String error;
+    bool base64Encoded;
+    InspectorPageAgent::resourceContent(error, ownerDocument()->frame(), URL(ParsedURLString, m_pageStyleSheet->href()), &result, &base64Encoded);
+    return error.isEmpty() && !base64Encoded;
+}
+
+// FIXME: all protocol methods below should be moved to InspectorCSSAgent.cpp
+static Ref<Inspector::Protocol::CSS::CSSSelector> buildObjectForSelector(const CSSSelector& selector, Element* element);
+static Ref<Inspector::Protocol::CSS::CSSSelector> buildObjectForSelectorText(const String& selectorText, const CSSSelector& selector, Element* element);
+
+static bool hasDynamicSpecificity(const CSSSelector& simpleSelector)
+{
+    // It is possible that these can have a static specificity if each selector in the list has
+    // equal specificity, but lets always report that they can be dynamic.
+    for (const CSSSelector* selector = &simpleSelector; selector; selector = selector->tagHistory()) {
+        if (selector->match() == CSSSelector::PseudoClass) {
+            CSSSelector::PseudoClassType pseudoClassType = selector->pseudoClassType();
+            if (pseudoClassType == CSSSelector::PseudoClassMatches)
+                return true;
+            if (pseudoClassType == CSSSelector::PseudoClassNthChild || pseudoClassType == CSSSelector::PseudoClassNthLastChild) {
+                if (selector->selectorList())
+                    return true;
+                return false;
+            }
+        }
+    }
+    
+    return false;
+}
+
+static Ref<Inspector::Protocol::CSS::CSSSelector> buildObjectForSelector(const CSSSelector& selector, Element* element)
+{
+    return buildObjectForSelectorText(selector.selectorText(), selector, element);
+}
+
+static Ref<Inspector::Protocol::CSS::CSSSelector> buildObjectForSelectorText(const String& selectorText, const CSSSelector& selector, Element* element)
+{
+    auto inspectorSelector = Inspector::Protocol::CSS::CSSSelector::create()
+    .setText(selectorText)
+    .release();
+    
+    if (element) {
+        bool dynamic = hasDynamicSpecificity(selector);
+        if (dynamic)
+            inspectorSelector->setDynamic(true);
+        
+        SelectorChecker::CheckingContext context(SelectorChecker::Mode::CollectingRules);
+        SelectorChecker selectorChecker(element->document());
+        
+        unsigned specificity;
+        bool okay = selectorChecker.match(&selector, element, context, specificity);
+        if (!okay)
+            specificity = selector.staticSpecificity(okay);
+        
+        if (okay) {
+            auto tuple = Inspector::Protocol::Array<int>::create();
+            tuple->addItem(static_cast<int>((specificity & CSSSelector::idMask) >> 16));
+            tuple->addItem(static_cast<int>((specificity & CSSSelector::classMask) >> 8));
+            tuple->addItem(static_cast<int>(specificity & CSSSelector::elementMask));
+            inspectorSelector->setSpecificity(WTF::move(tuple));
+        }
+    }
+    
+    return WTF::move(inspectorSelector);
+}
+
+static Ref<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSSelector>> selectorsFromSourceData(const CSSRuleSourceData* sourceData, const String& sheetText, const CSSSelectorList& selectorList, Element* element)
+{
+    NeverDestroyed<JSC::Yarr::RegularExpression> comment("/\\*[^]*?\\*/", TextCaseSensitive, JSC::Yarr::MultilineEnabled);
+    
+    auto result = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSSelector>::create();
+    const SelectorRangeList& ranges = sourceData->selectorRanges;
+    const CSSSelector* selector = selectorList.first();
+    for (size_t i = 0, size = ranges.size(); i < size; ++i) {
+        // If we don't have a selector, that means the SourceData for this CSSStyleSheet
+        // no longer matches up with the actual rules in the CSSStyleSheet.
+        ASSERT(selector);
+        if (!selector)
+            break;
+        
+        const SourceRange& range = ranges.at(i);
+        String selectorText = sheetText.substring(range.start, range.length());
+        
+        // We don't want to see any comments in the selector components, only the meaningful parts.
+        replace(selectorText, comment, String());
+        result->addItem(buildObjectForSelectorText(selectorText.stripWhiteSpace(), *selector, element));
+        
+        selector = CSSSelectorList::next(selector);
+    }
+    return WTF::move(result);
+}
+
+Ref<Inspector::Protocol::CSS::SelectorList> StylesheetRuleSet::buildObjectForSelectorList(CSSStyleRule& rule, Element* element)
+{
+    RefPtr<Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSSelector>> selectors;
+    
+    RefPtr<CSSRuleSourceData> sourceData = sourceDataForRule(rule);
+    if (sourceData) {
+        selectors = selectorsFromSourceData(sourceData.get(), parsedRuleSetData().sourceText(), rule.styleRule().selectorList(), element);
+    } else {
+        selectors = Inspector::Protocol::Array<Inspector::Protocol::CSS::CSSSelector>::create();
+        const CSSSelectorList& selectorList = rule.styleRule().selectorList();
+        for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
+            if (selector)
+                selectors->addItem(buildObjectForSelector(*selector, element));
+    }
+    
+    // This intentionally does not rely on the source data to avoid catching the trailing comments
+    // (before the declaration starting '{').
+    String selectorListText = rule.selectorText();
+    auto result = Inspector::Protocol::CSS::SelectorList::create()
+    .setSelectors(selectors.release())
+    .setText(selectorListText)
+    .release();
+    if (sourceData) {
+        auto lineEndings = ContentSearchUtilities::lineEndings(parsedRuleSetData().sourceText());
+        result->setRange(buildSourceRangeObject(sourceData->ruleHeaderRange, *lineEndings));
+    }
+    return WTF::move(result);
+}
+
+RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody> StylesheetRuleSet::buildObjectForStyleSheet()
+{
+    auto result = Inspector::Protocol::CSS::CSSStyleSheetBody::create()
+    .setStyleSheetId(identifier())
+    .setRules(buildArrayForRuleList(parsedRuleSetData().flattenedStyleRules(), *this))
+    .release();
+    
+    String stylesheetText = getText();
+    result->setText(stylesheetText);
+    
+    return WTF::move(result);
+}
+
+} // namespace WebCore
diff --git a/Source/WebCore/inspector/InspectorStylesheetRuleSet.h b/Source/WebCore/inspector/InspectorStylesheetRuleSet.h
new file mode 100644
index 0000000..29bd1b1
--- /dev/null
+++ b/Source/WebCore/inspector/InspectorStylesheetRuleSet.h
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2010, Google Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef InspectorStylesheetRuleSet_h
+#define InspectorStylesheetRuleSet_h
+
+#include "CSSStyleDeclaration.h"
+#include "ExceptionCode.h"
+#include "InspectorCSSId.h"
+#include "InspectorStyleRuleSet.h"
+#include <inspector/InspectorProtocolObjects.h>
+#include <inspector/InspectorValues.h>
+#include <wtf/HashMap.h>
+#include <wtf/HashSet.h>
+#include <wtf/RefPtr.h>
+#include <wtf/TypeCasts.h>
+#include <wtf/Vector.h>
+#include <wtf/text/WTFString.h>
+
+struct ParsedRuleSetData;
+
+namespace WebCore {
+class CSSRuleList;
+class CSSSelector;
+class CSSStyleDeclaration;
+class CSSStyleRule;
+class CSSStyleSheet;
+class Document;
+class Element;
+class InspectorPageAgent;
+
+struct CSSRuleSourceData;
+}
+
+namespace Inspector {
+
+class StyleRuleSet;
+typedef String ErrorString;
+
+enum class StyleSheetOrigin {
+    Inspector,
+    UserAgent,
+    User,
+    Author
+};
+
+enum class MediaListSource {
+    LinkedSheet,
+    InlineSheet,
+    MediaRule,
+    ImportRule
+};
+
+class StylesheetRuleSet : public StyleRuleSet {
+public:
+    class Listener {
+    public:
+        Listener() { }
+        virtual ~Listener() { }
+        virtual void styleSheetChanged(StylesheetRuleSet&) = 0;
+    };
+
+    static Ref<StylesheetRuleSet> create(Ref<WebCore::CSSStyleSheet>&&, StyleSheetOrigin, const String& documentURL, Listener*);
+    virtual ~StylesheetRuleSet();
+
+    // StyleRuleSet API
+    virtual bool isStylesheet() const override { return true; }
+    virtual void replaceText(const String&) override;
+
+    virtual std::unique_ptr<ParsedRuleSetData> originalSourceData() override;
+    virtual WebCore::Document* ownerDocument() const override;
+    virtual bool setTextForStyle(const CSSId&, const String& text, String& oldText) override;
+
+    virtual void notifyRuleSetChanged() override;
+    virtual WebCore::CSSStyleDeclaration* styleForId(const CSSId&) override;
+
+    // StylesheetRuleSet API
+    
+    String finalURL() const;
+    String title() const;
+    StyleSheetOrigin origin() const { return m_origin; }
+    bool isEnabled() const;
+    bool originalSourceText(String& result) const;
+    bool canBind() const { return m_origin != StyleSheetOrigin::UserAgent && m_origin != StyleSheetOrigin::User; }
+
+    bool selectorTextForRule(const CSSId&, String& result);
+    bool setSelectorTextForRule(const CSSId&, const String& selectorText);
+
+    WebCore::CSSStyleRule* addRule(const String& selector, WebCore::ExceptionCode&);
+    bool deleteRule(const CSSId&, WebCore::ExceptionCode&);
+
+    // FIXME: remove.
+    WebCore::CSSStyleSheet& pageStyleSheet() { return m_pageStyleSheet.get(); }
+    
+    CSSId ruleId(WebCore::CSSStyleRule&);
+    WebCore::CSSStyleRule* ruleForId(const CSSId&);
+    CSSId styleId(WebCore::CSSStyleDeclaration& style) { return ruleOrStyleId(style); }
+
+    // FIXME: move these to CSSAgent.
+    RefPtr<Inspector::Protocol::CSS::CSSStyleSheetBody> buildObjectForStyleSheet();
+    Ref<Inspector::Protocol::CSS::SelectorList> buildObjectForSelectorList(WebCore::CSSStyleRule&, WebCore::Element*);
+
+protected:
+    StylesheetRuleSet(Ref<WebCore::CSSStyleSheet>&& pageStyleSheet, StyleSheetOrigin, const String& documentURL, Listener*);
+
+    virtual RefPtr<StyleRule> inspectorStyleForId(const CSSId&);
+
+    // Also accessed by friend class InspectorStyle.
+    virtual bool setTextForStyle(WebCore::CSSStyleDeclaration&, const String&) override;
+
+private:
+    friend class InspectorStyle;
+
+    bool styleSheetMutated();
+    bool getTextWithPatchedStyle(WebCore::CSSStyleDeclaration&, const String& newStyleText, String& result);
+    bool resourceStylesheetText(String& result) const;
+    bool inlineStylesheetText(String& result) const;
+
+    // Only to be used internally when a rule has been added, removed, or modified. If the entire
+    // stylesheet contents have been changed, use replaceText() which recreates all CSSOM wrappers
+    // and updates the StyleSheetContents backing store to hold the new stylesheet text.
+    void patchStylesheetText(const String&);
+
+    Ref<WebCore::CSSStyleSheet> m_pageStyleSheet;
+    StyleSheetOrigin m_origin;
+    String m_documentURL;
+    Listener* m_listener;
+};
+
+} // namespace Inspector
+
+SPECIALIZE_TYPE_TRAITS_BEGIN(Inspector::StylesheetRuleSet)
+static bool isType(const Inspector::StyleRuleSet& ruleSet) { return ruleSet.isStylesheet(); }
+SPECIALIZE_TYPE_TRAITS_END()
+
+#endif // InspectorStylesheetRuleSet_h
-- 
2.3.5

