From 16f614a5ea3a73cf7f866d446b2dcca799631a87 Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Fri, 25 Jul 2014 15:59:27 -0700
Subject: [PATCH] WIP: revive the old capturing timeline.

---
 .../WebCore/inspector/InspectorInstrumentation.cpp |   6 +
 .../WebCore/inspector/InspectorInstrumentation.h   |  13 ++
 Source/WebCore/inspector/InspectorReplayAgent.cpp  |   5 +
 Source/WebCore/inspector/InspectorReplayAgent.h    |   1 +
 Source/WebCore/inspector/protocol/Replay.json      |   7 +
 Source/WebCore/replay/CapturingInputCursor.cpp     |   2 +
 .../Localizations/en.lproj/localizedStrings.js     | Bin 55090 -> 55236 bytes
 .../UserInterface/Controllers/ReplayManager.js     |  18 ++
 Source/WebInspectorUI/UserInterface/Main.html      |   2 +
 .../UserInterface/Protocol/ReplayObserver.js       |   5 +
 .../UserInterface/Views/ReplayDashboardView.js     |  16 +-
 .../Views/TickerTimelineNavigationItem.css         |  80 ++++++++
 .../Views/TickerTimelineNavigationItem.js          | 216 +++++++++++++++++++++
 13 files changed, 366 insertions(+), 5 deletions(-)
 create mode 100644 Source/WebInspectorUI/UserInterface/Views/TickerTimelineNavigationItem.css
 create mode 100644 Source/WebInspectorUI/UserInterface/Views/TickerTimelineNavigationItem.js

diff --git a/Source/WebCore/inspector/InspectorInstrumentation.cpp b/Source/WebCore/inspector/InspectorInstrumentation.cpp
index 692a47e..ff338fe 100644
--- a/Source/WebCore/inspector/InspectorInstrumentation.cpp
+++ b/Source/WebCore/inspector/InspectorInstrumentation.cpp
@@ -1102,20 +1102,26 @@ void InspectorInstrumentation::captureStartedImpl(InstrumentingAgents* instrumen
     if (InspectorReplayAgent* replayAgent = instrumentingAgents->inspectorReplayAgent())
         replayAgent->captureStarted();
 }
 
 void InspectorInstrumentation::captureStoppedImpl(InstrumentingAgents* instrumentingAgents)
 {
     if (InspectorReplayAgent* replayAgent = instrumentingAgents->inspectorReplayAgent())
         replayAgent->captureStopped();
 }
 
+void InspectorInstrumentation::capturedEventLoopInputImpl(InstrumentingAgents* instrumentingAgents, double timestamp)
+{
+    if (InspectorReplayAgent* replayAgent = instrumentingAgents->inspectorReplayAgent())
+        replayAgent->capturedEventLoopInput(timestamp);
+}
+
 void InspectorInstrumentation::playbackStartedImpl(InstrumentingAgents* instrumentingAgents)
 {
     if (InspectorReplayAgent* replayAgent = instrumentingAgents->inspectorReplayAgent())
         replayAgent->playbackStarted();
 }
 
 void InspectorInstrumentation::playbackPausedImpl(InstrumentingAgents* instrumentingAgents, const ReplayPosition& position)
 {
     if (InspectorReplayAgent* replayAgent = instrumentingAgents->inspectorReplayAgent())
         replayAgent->playbackPaused(position);
diff --git a/Source/WebCore/inspector/InspectorInstrumentation.h b/Source/WebCore/inspector/InspectorInstrumentation.h
index 0163d47..3ef79c1 100644
--- a/Source/WebCore/inspector/InspectorInstrumentation.h
+++ b/Source/WebCore/inspector/InspectorInstrumentation.h
@@ -251,20 +251,21 @@ public:
     static void sessionLoaded(Page*, PassRefPtr<ReplaySession>);
     static void sessionModified(Page*, PassRefPtr<ReplaySession>);
 
     static void segmentCreated(Page*, PassRefPtr<ReplaySessionSegment>);
     static void segmentCompleted(Page*, PassRefPtr<ReplaySessionSegment>);
     static void segmentLoaded(Page*, PassRefPtr<ReplaySessionSegment>);
     static void segmentUnloaded(Page*);
 
     static void captureStarted(Page*);
     static void captureStopped(Page*);
+    static void capturedEventLoopInput(Page*, double);
 
     static void playbackStarted(Page*);
     static void playbackPaused(Page*, const ReplayPosition&);
     static void playbackHitPosition(Page*, const ReplayPosition&);
     static void playbackFinished(Page*);
 #endif
 
 #if ENABLE(WEB_SOCKETS)
     static void didCreateWebSocket(Document*, unsigned long identifier, const URL& requestURL, const URL& documentURL, const String& protocol);
     static void willSendWebSocketHandshakeRequest(Document*, unsigned long identifier, const ResourceRequest&);
@@ -446,20 +447,21 @@ private:
     static void sessionLoadedImpl(InstrumentingAgents*, PassRefPtr<ReplaySession>);
     static void sessionModifiedImpl(InstrumentingAgents*, PassRefPtr<ReplaySession>);
 
     static void segmentCreatedImpl(InstrumentingAgents*, PassRefPtr<ReplaySessionSegment>);
     static void segmentCompletedImpl(InstrumentingAgents*, PassRefPtr<ReplaySessionSegment>);
     static void segmentLoadedImpl(InstrumentingAgents*, PassRefPtr<ReplaySessionSegment>);
     static void segmentUnloadedImpl(InstrumentingAgents*);
 
     static void captureStartedImpl(InstrumentingAgents*);
     static void captureStoppedImpl(InstrumentingAgents*);
+    static void capturedEventLoopInputImpl(InstrumentingAgents*, double);
 
     static void playbackStartedImpl(InstrumentingAgents*);
     static void playbackPausedImpl(InstrumentingAgents*, const ReplayPosition&);
     static void playbackHitPositionImpl(InstrumentingAgents*, const ReplayPosition&);
     static void playbackFinishedImpl(InstrumentingAgents*);
 #endif
 
 #if ENABLE(WEB_SOCKETS)
     static void didCreateWebSocketImpl(InstrumentingAgents*, unsigned long identifier, const URL& requestURL, const URL& documentURL, const String& protocol, Document*);
     static void willSendWebSocketHandshakeRequestImpl(InstrumentingAgents*, unsigned long identifier, const ResourceRequest&, Document*);
@@ -1905,20 +1907,31 @@ inline void InspectorInstrumentation::captureStopped(Page* page)
 {
 #if ENABLE(INSPECTOR)
     FAST_RETURN_IF_NO_FRONTENDS(void());
     if (InstrumentingAgents* instrumentingAgents = instrumentingAgentsForPage(page))
         captureStoppedImpl(instrumentingAgents);
 #else
     UNUSED_PARAM(page);
 #endif
 }
 
+inline void InspectorInstrumentation::capturedEventLoopInput(Page* page, double timestamp)
+{
+#if ENABLE(INSPECTOR)
+    FAST_RETURN_IF_NO_FRONTENDS(void());
+    if (InstrumentingAgents* instrumentingAgents = instrumentingAgentsForPage(page))
+        capturedEventLoopInputImpl(instrumentingAgents, timestamp);
+#else
+    UNUSED_PARAM(page);
+#endif
+}
+
 inline void InspectorInstrumentation::playbackStarted(Page* page)
 {
 #if ENABLE(INSPECTOR)
     FAST_RETURN_IF_NO_FRONTENDS(void());
     if (InstrumentingAgents* instrumentingAgents = instrumentingAgentsForPage(page))
         playbackStartedImpl(instrumentingAgents);
 #else
     UNUSED_PARAM(page);
 #endif
 }
diff --git a/Source/WebCore/inspector/InspectorReplayAgent.cpp b/Source/WebCore/inspector/InspectorReplayAgent.cpp
index 1586493..bd49cca 100644
--- a/Source/WebCore/inspector/InspectorReplayAgent.cpp
+++ b/Source/WebCore/inspector/InspectorReplayAgent.cpp
@@ -284,20 +284,25 @@ void InspectorReplayAgent::captureStarted()
     m_frontendDispatcher->captureStarted();
 }
 
 void InspectorReplayAgent::captureStopped()
 {
     LOG(WebReplay, "-----CAPTURE STOP-----");
 
     m_frontendDispatcher->captureStopped();
 }
 
+void InspectorReplayAgent::capturedEventLoopInput(double timestamp)
+{
+    m_frontendDispatcher->capturedEventLoopInput(timestamp);
+}
+
 void InspectorReplayAgent::playbackStarted()
 {
     LOG(WebReplay, "-----REPLAY START-----");
 
     m_frontendDispatcher->playbackStarted();
 }
 
 void InspectorReplayAgent::playbackPaused(const ReplayPosition& position)
 {
     LOG(WebReplay, "-----REPLAY PAUSED-----");
diff --git a/Source/WebCore/inspector/InspectorReplayAgent.h b/Source/WebCore/inspector/InspectorReplayAgent.h
index 0ed0712..17b8612 100644
--- a/Source/WebCore/inspector/InspectorReplayAgent.h
+++ b/Source/WebCore/inspector/InspectorReplayAgent.h
@@ -78,20 +78,21 @@ public:
     void sessionModified(PassRefPtr<ReplaySession>);
     void sessionLoaded(PassRefPtr<ReplaySession>);
 
     void segmentCreated(PassRefPtr<ReplaySessionSegment>);
     void segmentCompleted(PassRefPtr<ReplaySessionSegment>);
     void segmentLoaded(PassRefPtr<ReplaySessionSegment>);
     void segmentUnloaded();
 
     void captureStarted();
     void captureStopped();
+    void capturedEventLoopInput(double);
 
     void playbackStarted();
     void playbackPaused(const ReplayPosition&);
     void playbackHitPosition(const ReplayPosition&);
     void playbackFinished();
 
     // Calls from the Inspector frontend.
     virtual void startCapturing(ErrorString*) override;
     virtual void stopCapturing(ErrorString*) override;
 
diff --git a/Source/WebCore/inspector/protocol/Replay.json b/Source/WebCore/inspector/protocol/Replay.json
index 1c9a7a5..e96f4fb 100644
--- a/Source/WebCore/inspector/protocol/Replay.json
+++ b/Source/WebCore/inspector/protocol/Replay.json
@@ -192,20 +192,27 @@
             "description": "Fired when session playback has paused, but not finished.",
             "parameters": [
                 { "name": "position", "$ref": "ReplayPosition", "description": "The playback position immediately prior to where playback is paused." }
             ]
         },
         {
             "name": "playbackFinished",
             "description": "Fired when session playback has stopped."
         },
         {
+            "name": "capturedEventLoopInput",
+            "description": "A new event loop input was captured.",
+            "parameters": [
+                { "name": "timestamp", "type": "number", "description": "A timestamp for the input." }
+            ]
+        },
+        {
             "name": "inputSuppressionChanged",
             "description": "Fired when the replay controller starts or stops suppressing user inputs.",
             "parameters": [
                 { "name": "willSuppress", "type": "boolean", "description": "Whether user inputs will be suppressed during playback." }
             ]
         },
         {
             "name": "sessionCreated",
             "description": "Fired when a new replay session is created",
             "parameters": [
diff --git a/Source/WebCore/replay/CapturingInputCursor.cpp b/Source/WebCore/replay/CapturingInputCursor.cpp
index bc61aa6..75f1db6 100644
--- a/Source/WebCore/replay/CapturingInputCursor.cpp
+++ b/Source/WebCore/replay/CapturingInputCursor.cpp
@@ -24,20 +24,21 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "CapturingInputCursor.h"
 
 #if ENABLE(WEB_REPLAY)
 
 #include "EventLoopInput.h"
+#include "InspectorInstrumentation.h"
 #include "Logging.h"
 #include "Page.h"
 #include "ReplaySessionSegment.h"
 #include "SegmentedInputStorage.h"
 #include <wtf/CurrentTime.h>
 
 namespace WebCore {
 
 CapturingInputCursor::CapturingInputCursor(PassRefPtr<ReplaySessionSegment> segment, Page& page)
     : m_segment(segment)
@@ -59,20 +60,21 @@ PassRefPtr<CapturingInputCursor> CapturingInputCursor::create(PassRefPtr<ReplayS
 }
 
 void CapturingInputCursor::storeInput(std::unique_ptr<NondeterministicInputBase> input)
 {
     ASSERT_ARG(input, input);
 
     if (input->queue() == InputQueue::EventLoopInput) {
         // FIXME: rewrite this (and related dispatch code) to use std::chrono.
         double now = monotonicallyIncreasingTime();
         m_segment->eventLoopTimings().append(now);
+        InspectorInstrumentation::capturedEventLoopInput(&m_page, now);
     }
 
     m_segment->storage().store(WTF::move(input));
 }
 
 NondeterministicInputBase* CapturingInputCursor::loadInput(InputQueue, const AtomicString&)
 {
     // Can't load inputs from capturing cursor.
     ASSERT_NOT_REACHED();
     return nullptr;
diff --git a/Source/WebInspectorUI/Localizations/en.lproj/localizedStrings.js b/Source/WebInspectorUI/Localizations/en.lproj/localizedStrings.js
index 10a90002752b61d6b8b1d1b2a079c057e800b9cd..d8c893fd9065480d4f5755b1d096c9ca6dfdc0fd 100644
GIT binary patch
delta 38
wcmV+>0NMYtt^>rc1F(T62Ot1+0B-;wlN!PwlZ#sllg%X(lN-WDvv(%DunjW~bN~PV

delta 14
WcmX@Io_W(c<_(Q%n}yXkZU6u>mj-_T

diff --git a/Source/WebInspectorUI/UserInterface/Controllers/ReplayManager.js b/Source/WebInspectorUI/UserInterface/Controllers/ReplayManager.js
index 18f52b2..ac9e392 100644
--- a/Source/WebInspectorUI/UserInterface/Controllers/ReplayManager.js
+++ b/Source/WebInspectorUI/UserInterface/Controllers/ReplayManager.js
@@ -28,20 +28,21 @@ WebInspector.ReplayManager = function()
 {
     WebInspector.Object.call(this);
 
     this._sessionState = WebInspector.ReplayManager.SessionState.Inactive;
     this._segmentState = WebInspector.ReplayManager.SegmentState.Unloaded;
 
     this._activeSessionIdentifier = null;
     this._activeSegmentIdentifier = null;
     this._currentPosition = new WebInspector.ReplayPosition(0, 0);
     this._initialized = false;
+    this._capturedInputTimestamps = [];
 
     // These hold actual instances of sessions and segments.
     this._sessions = new Map;
     this._segments = new Map;
     // These hold promises that resolve when the instance data is recieved.
     this._sessionPromises = new Map;
     this._segmentPromises = new Map;
 
     // Playback speed is specified in replayToPosition commands, and persists
     // for the duration of the playback command until another playback begins.
@@ -158,20 +159,25 @@ WebInspector.ReplayManager.prototype = {
         console.assert(this._initialized);
         this._playbackSpeed = value;
     },
 
     get currentPosition()
     {
         console.assert(this._initialized);
         return this._currentPosition;
     },
 
+    get capturedInputTimestamps()
+    {
+        console.assert(this._initialized);
+        return this._capturedInputTimestamps;
+    },
 
     // Public - Asynchronous API
     //
     // Methods in this section return promises and require the manager to be initialized.
 
     // Return a promise that resolves when the manager is fully initialized.
     waitUntilInitialized: function() // --> ()
     {
         return this._initializationPromise;
     },
@@ -487,20 +493,28 @@ WebInspector.ReplayManager.prototype = {
     {
         if (!this._initialized)
             return this.waitUntilInitialized().then(this.playbackFinished.bind(this));
 
         this._changeSessionState(WebInspector.ReplayManager.SessionState.Inactive);
         console.assert(this.segmentState === WebInspector.ReplayManager.SegmentState.Unloaded);
 
         this.dispatchEventToListeners(WebInspector.ReplayManager.Event.PlaybackFinished);
     },
 
+    capturedEventLoopInput: function(timestamp)
+    {
+        if (!this._initialized)
+            return this.waitUntilInitialized().then(this.capturedEventLoopInput.bind(this, timestamp));
+
+        this._capturedInputTimestamps.push(timestamp);
+    },
+
     sessionCreated: function(sessionId)
     {
         if (!this._initialized)
             return this.waitUntilInitialized().then(this.sessionCreated.bind(this, sessionId));
 
         console.assert(!this._sessions.has(sessionId), "Tried to add duplicate session identifier:", sessionId);
         var sessionMap = this._sessions;
         this.getSession(sessionId)
             .then(function(session) {
                 sessionMap.set(sessionId, session);
@@ -624,20 +638,24 @@ WebInspector.ReplayManager.prototype = {
         if (!this._initialized)
             return this.waitUntilInitialized().then(this.segmentLoaded.bind(this, segmentId));
 
         console.assert(this._segments.has(segmentId), "Unknown segment identifier:", segmentId);
 
         console.assert(this.sessionState !== WebInspector.ReplayManager.SessionState.Capturing);
         this._changeSegmentState(WebInspector.ReplayManager.SegmentState.Loaded);
 
         var previousIdentifier = this._activeSegmentIdentifier;
         this._activeSegmentIdentifier = segmentId;
+
+        if (this._sessionState === WebInspector.ReplayManager.SessionState.Capturing)
+            this._capturedInputTimestamps = [];
+
         this.dispatchEventToListeners(WebInspector.ReplayManager.Event.ActiveSegmentChanged, {previousSegmentIdentifier: previousIdentifier});
    },
 
     segmentUnloaded: function()
     {
         if (!this._initialized)
             return this.waitUntilInitialized().then(this.segmentUnloaded.bind(this));
 
         console.assert(this.sessionState === WebInspector.ReplayManager.SessionState.Replaying);
         this._changeSegmentState(WebInspector.ReplayManager.SegmentState.Unloaded);
diff --git a/Source/WebInspectorUI/UserInterface/Main.html b/Source/WebInspectorUI/UserInterface/Main.html
index 06f2968..c132d06 100644
--- a/Source/WebInspectorUI/UserInterface/Main.html
+++ b/Source/WebInspectorUI/UserInterface/Main.html
@@ -119,20 +119,21 @@
     <link rel="stylesheet" href="Views/SearchIcons.css">
     <link rel="stylesheet" href="Views/Section.css">
     <link rel="stylesheet" href="Views/Sidebar.css">
     <link rel="stylesheet" href="Views/Slider.css">
     <link rel="stylesheet" href="Views/SourceCodeTextEditor.css">
     <link rel="stylesheet" href="Views/StyleRuleIcons.css">
     <link rel="stylesheet" href="Views/SyntaxHighlightingDefaultTheme.css">
     <link rel="stylesheet" href="Views/TextContentView.css">
     <link rel="stylesheet" href="Views/TextEditor.css">
     <link rel="stylesheet" href="Views/TextResourceContentView.css">
+    <link rel="stylesheet" href="Views/TickerTimelineNavigationItem.css">
     <link rel="stylesheet" href="Views/TimelineContentView.css">
     <link rel="stylesheet" href="Views/TimelineDataGrid.css">
     <link rel="stylesheet" href="Views/TimelineIcons.css">
     <link rel="stylesheet" href="Views/TimelineOverview.css">
     <link rel="stylesheet" href="Views/TimelineRecordBar.css">
     <link rel="stylesheet" href="Views/TimelineRuler.css">
     <link rel="stylesheet" href="Views/TimelineSidebarPanel.css">
     <link rel="stylesheet" href="Views/TimelineView.css">
     <link rel="stylesheet" href="Views/Toolbar.css">
     <link rel="stylesheet" href="Views/TreeElementStatusButton.css">
@@ -438,20 +439,21 @@
     <script src="Views/SearchResultTreeElement.js"></script>
     <script src="Views/Sidebar.js"></script>
     <script src="Views/Slider.js"></script>
     <script src="Views/SourceCodeTextEditor.js"></script>
     <script src="Views/SourceCodeTimelineTimelineDataGridNode.js"></script>
     <script src="Views/SourceCodeTimelineTreeElement.js"></script>
     <script src="Views/SourceMapResourceTreeElement.js"></script>
     <script src="Views/SyntaxHighlightingSupport.js"></script>
     <script src="Views/TextContentView.js"></script>
     <script src="Views/TextResourceContentView.js"></script>
+    <script src="Views/TickerTimelineNavigationItem.js"></script>
     <script src="Views/TimelineContentView.js"></script>
     <script src="Views/TimelineOverview.js"></script>
     <script src="Views/TimelineRecordBar.js"></script>
     <script src="Views/TimelineRuler.js"></script>
     <script src="Views/TimelineSidebarPanel.js"></script>
     <script src="Views/ToggleButtonNavigationItem.js"></script>
     <script src="Views/ToggleControlToolbarItem.js"></script>
     <script src="Views/Toolbar.js"></script>
     <script src="Views/TreeElementStatusButton.js"></script>
     <script src="Views/TreeOutlineDataGridSynchronizer.js"></script>
diff --git a/Source/WebInspectorUI/UserInterface/Protocol/ReplayObserver.js b/Source/WebInspectorUI/UserInterface/Protocol/ReplayObserver.js
index 5b9d3dd..6f88a80 100644
--- a/Source/WebInspectorUI/UserInterface/Protocol/ReplayObserver.js
+++ b/Source/WebInspectorUI/UserInterface/Protocol/ReplayObserver.js
@@ -67,20 +67,25 @@ WebInspector.ReplayObserver.prototype = {
     playbackPaused: function(replayPosition)
     {
         WebInspector.replayManager.playbackPaused(WebInspector.ReplayPosition.fromProtocol(replayPosition));
     },
 
     playbackFinished: function()
     {
         WebInspector.replayManager.playbackFinished();
     },
 
+    capturedEventLoopInput: function(timestamp)
+    {
+        WebInspector.replayManager.capturedEventLoopInput(timestamp);
+    },
+
     inputSuppressionChanged: function(willSuppress)
     {
         // Not handled yet.
     },
 
     sessionCreated: function(sessionId)
     {
         WebInspector.replayManager.sessionCreated(sessionId);
     },
 
diff --git a/Source/WebInspectorUI/UserInterface/Views/ReplayDashboardView.js b/Source/WebInspectorUI/UserInterface/Views/ReplayDashboardView.js
index 84a91a2..bc7a32f 100644
--- a/Source/WebInspectorUI/UserInterface/Views/ReplayDashboardView.js
+++ b/Source/WebInspectorUI/UserInterface/Views/ReplayDashboardView.js
@@ -23,39 +23,44 @@
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 WebInspector.ReplayDashboardView = function(representedObject)
 {
     WebInspector.DashboardView.call(this, representedObject, "replay");
 
     this._navigationBar = new WebInspector.NavigationBar;
     this.element.appendChild(this._navigationBar.element);
 
+    // Force the navigation bar to resize when the toolbar changes shape.
+    WebInspector.toolbar.addEventListener(WebInspector.Toolbar.Event.SizeModeDidChange, this._navigationBar.updateLayoutSoon, this._navigationBar);
+    WebInspector.toolbar.addEventListener(WebInspector.Toolbar.Event.DisplayModeDidChange, this._navigationBar.updateLayoutSoon, this._navigationBar);
+
     replayManager = WebInspector.replayManager;
 
     this._captureButtonItem = new WebInspector.ActivateButtonNavigationItem("replay-dashboard-capture", WebInspector.UIString("Start Recording"), WebInspector.UIString("Stop Recording"), "Images/ReplayReadyButton.svg", 16, 16);
     this._captureButtonItem.addEventListener(WebInspector.ButtonNavigationItem.Event.Clicked, this._captureButtonItemClicked, this);
     this._captureButtonItem.hidden = true;
     this._navigationBar.addNavigationItem(this._captureButtonItem);
 
     this._replayButtonItem = new WebInspector.ToggleButtonNavigationItem("replay-dashboard-replay", WebInspector.UIString("Start Playback"), WebInspector.UIString("Pause Playback"), "Images/ReplayPlayButton.svg", "Images/ReplayPauseButton.svg", 16, 16);
     this._replayButtonItem.addEventListener(WebInspector.ButtonNavigationItem.Event.Clicked, this._replayButtonItemClicked, this);
     this._replayButtonItem.hidden = true;
     this._navigationBar.addNavigationItem(this._replayButtonItem);
 
     this._ejectButtonItem = new WebInspector.ButtonNavigationItem("replay-dashboard-eject", WebInspector.UIString("Eject Recording"), "Images/ReplayEjectButton.svg", 16, 16);
     this._ejectButtonItem.addEventListener(WebInspector.ButtonNavigationItem.Event.Clicked, this._ejectButtonItemClicked, this);
     this._ejectButtonItem.hidden = true;
     this._navigationBar.addNavigationItem(this._ejectButtonItem);
 
-    var recordingContainerElement = this._recordingContainerElement = this.element.appendChild(document.createElement("div"));
-    recordingContainerElement.className = WebInspector.ReplayDashboardView.RecordingContainerStyleClassName;
+    this._tickerTimelineItem = new WebInspector.TickerTimelineNavigationItem("replay-ticker-timeline");
+    this._tickerTimelineItem.hidden = true;
+    this._navigationBar.addNavigationItem(this._tickerTimelineItem);
 
     // Add events required to track capture and replay state.
     WebInspector.replayManager.addEventListener(WebInspector.ReplayManager.Event.CaptureStarted, this._captureStarted, this);
     WebInspector.replayManager.addEventListener(WebInspector.ReplayManager.Event.CaptureStopped, this._captureStopped, this);
     WebInspector.replayManager.addEventListener(WebInspector.ReplayManager.Event.PlaybackStarted, this._playbackStarted, this);
     WebInspector.replayManager.addEventListener(WebInspector.ReplayManager.Event.PlaybackPaused, this._playbackPaused, this);
     WebInspector.replayManager.addEventListener(WebInspector.ReplayManager.Event.PlaybackFinished, this._playbackFinished, this);
     WebInspector.replayManager.addEventListener(WebInspector.ReplayManager.Event.ActiveSessionChanged, this._activeSessionChanged, this);
 
     // Manually initialize style classes by querying current replay state.
@@ -64,23 +69,20 @@ WebInspector.ReplayDashboardView = function(representedObject)
     else if (WebInspector.replayManager.sessionState === WebInspector.ReplayManager.SessionState.Inactive)
         this._activeSessionChanged();
     // ReplayManager.sessionState must be Replaying.
     else if (WebInspector.replayManager.segmentState === WebInspector.ReplayManager.SegmentState.Dispatching)
         this._playbackStarted();
     // ReplayManager.sessionState must be Unloaded or Loaded, so execution is paused.
     else
         this._playbackPaused();
 };
 
-// Class names for top-level flex items within the replay dashboard.
-WebInspector.ReplayDashboardView.RecordingContainerStyleClassName = "recording-container";
-
 // Class names for single buttons.
 WebInspector.ReplayDashboardView.RecordButtonStyleClassName = "record-button";
 WebInspector.ReplayDashboardView.ReplayButtonStyleClassName = "replay-button";
 
 WebInspector.ReplayDashboardView.prototype = {
     constructor: WebInspector.ReplayDashboardView,
     __proto__: WebInspector.DashboardView.prototype,
 
     // Private
 
@@ -143,28 +145,30 @@ WebInspector.ReplayDashboardView.prototype = {
                 button.enabled = true;
             });
     },
 
     _captureStarted: function()
     {
         this._captureButtonItem.activated = true;
         this._captureButtonItem.hidden = false;
         this._replayButtonItem.hidden = true;
         this._ejectButtonItem.hidden = true;
+        this._tickerTimelineItem.hidden = false;
     },
 
     _captureStopped: function()
     {
         this._captureButtonItem.activated = false;
         this._captureButtonItem.hidden = true;
         this._replayButtonItem.hidden = false;
         this._ejectButtonItem.hidden = false;
+        this._tickerTimelineItem.hidden = true;
     },
 
     _playbackStarted: function()
     {
         // Show the pause button.
         this._replayButtonItem.toggled = true;
     },
 
     _playbackPaused: function()
     {
@@ -179,18 +183,20 @@ WebInspector.ReplayDashboardView.prototype = {
 
     _activeSessionChanged: function()
     {
         var view = this;
         WebInspector.replayManager.getSession(WebInspector.replayManager.activeSessionIdentifier)
             .then(function(session) {
                 if (!session.segments.length) {
                     view._captureButtonItem.hidden = false;
                     view._replayButtonItem.hidden = true;
                     view._ejectButtonItem.hidden = true;
+                    view._tickerTimelineItem.hidden = false;
                 } else {
                     view._captureButtonItem.hidden = true;
                     view._replayButtonItem.hidden = false;
                     view._ejectButtonItem.hidden = false;
+                    view._tickerTimelineItem.hidden = true;
                 }
             });
     }
 };
diff --git a/Source/WebInspectorUI/UserInterface/Views/TickerTimelineNavigationItem.css b/Source/WebInspectorUI/UserInterface/Views/TickerTimelineNavigationItem.css
new file mode 100644
index 0000000..0a6d6e6
--- /dev/null
+++ b/Source/WebInspectorUI/UserInterface/Views/TickerTimelineNavigationItem.css
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2014 University of Washington. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+.toolbar .dashboard.replay .item.ticker-timeline {
+    font-family: Helvetica, sans-serif;
+    font-weight: bold;
+    font-size: 12px;
+    text-align: center;
+
+    color: #666;
+
+    position: relative;
+    z-index: 0;
+
+    margin-top: 2px;
+    margin-left: 5px;
+    height: 25px;
+    width: 316px;
+}
+
+.toolbar.collapsed .dashboard.replay .item.ticker-timeline {
+    width: 114px;
+}
+
+.toolbar.small-size .dashboard.replay .item.ticker-timeline {
+    height: 20px;
+}
+
+.toolbar .dashboard.replay .item.ticker-timeline > .stop-overlay {
+    background-color: rgba(255, 255, 255, 0.6);
+    opacity: 0;
+    z-index: 1;
+    transition: opacity ease 0.4s;
+
+    line-height: 22px;
+
+    position: absolute;
+    top: 0;
+    bottom: 0;
+    left: 0;
+    right: 0;
+}
+
+.toolbar.small-size .dashboard.replay .item.ticker-timeline > .stop-overlay {
+    display: none;
+}
+
+.toolbar .dashboard.replay .item.ticker-timeline > .stop-overlay:hover {
+    opacity: 1;
+    color: #999;
+    text-shadow: 0px 0px 10px #fff;
+    text-decoration: underline;
+    cursor: pointer;
+}
+
+.toolbar .dashboard.replay .item.ticker-timeline > .stop-overlay:active {
+    color: #333;
+}
diff --git a/Source/WebInspectorUI/UserInterface/Views/TickerTimelineNavigationItem.js b/Source/WebInspectorUI/UserInterface/Views/TickerTimelineNavigationItem.js
new file mode 100644
index 0000000..f8d1752
--- /dev/null
+++ b/Source/WebInspectorUI/UserInterface/Views/TickerTimelineNavigationItem.js
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2013, 2014 University of Washington. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+WebInspector.TickerTimelineNavigationItem = function(identifier)
+{
+    WebInspector.NavigationItem.call(this, identifier);
+
+    this._canvas = this.element.appendChild(document.createElement("canvas"));
+
+    var stopOverlayElement = this.element.appendChild(document.createElement("div"));
+    stopOverlayElement.innerHTML = WebInspector.UIString("Stop Recording");
+    stopOverlayElement.className = WebInspector.TickerTimelineNavigationItem.StopStyleClassName;
+    stopOverlayElement.title = WebInspector.UIString("Click to Stop Recording");
+
+    this._timeline = { maxIndex: -1, data: [] };
+
+    stopOverlayElement.addEventListener("click", this._stopClicked.bind(this));
+
+    this._animateFrameCallback = this.animateFrame.bind(this);
+
+    window.webkitRequestAnimationFrame(this._animateFrameCallback);
+};
+
+WebInspector.TickerTimelineNavigationItem.StyleClassName = "ticker-timeline";
+WebInspector.TickerTimelineNavigationItem.StopStyleClassName = "stop-overlay";
+
+WebInspector.TickerTimelineNavigationItem.GraphBorderWidth = 1; // in pixels
+WebInspector.TickerTimelineNavigationItem.GraphBorderStrokeColor = new WebInspector.Color.fromString("#999");
+WebInspector.TickerTimelineNavigationItem.MaxRecordLifetime = 10.0; // seconds
+WebInspector.TickerTimelineNavigationItem.MaxBinsPerTimeline = 300;
+WebInspector.TickerTimelineNavigationItem.LineGraphFillColor = new WebInspector.Color(WebInspector.Color.Format.RGBA, [100, 100, 100, 0.6]);
+
+WebInspector.TickerTimelineNavigationItem.prototype = {
+    constructor: WebInspector.TickerTimelineNavigationItem,
+    __proto__: WebInspector.NavigationItem.prototype,
+    // Public
+
+    updateLayout: function()
+    {
+        this._autosizeCanvas();
+        this._drawGraph();
+    },
+
+    animateFrame: function()
+    {
+        this._recomputeTimeline();
+        this._drawGraph();
+
+        if (WebInspector.replayManager.sessionState === WebInspector.ReplayManager.SessionState.Capturing)
+            window.webkitRequestAnimationFrame(this._animateFrameCallback);
+    },
+
+    // Private
+    _additionalClassNames: [WebInspector.TickerTimelineNavigationItem.StyleClassName],
+
+    _autosizeCanvas: function()
+    {
+        console.log(this._canvas)
+        this._canvas.width = this.element.clientWidth;
+        this._canvas.style.width = this.element.clientWidth + 'px';
+        this._canvas.height = this.element.clientHeight;
+        this._canvas.style.height = this.element.clientHeight + 'px';
+        this._cachedOffsetWidth = this.element.offsetWidth;
+    },
+
+    _stopClicked: function(event)
+    {
+        WebInspector.replayManager.stopCapturing();
+    },
+
+    // Clear the data of the timeline.
+    _resetTimeline: function()
+    {
+        this._timeline.maxIndex = -1;
+        this._timeline.data = [];
+    },
+
+    _recomputeTimeline: function()
+    {
+        var timestamps = WebInspector.replayManager.capturedInputTimestamps;
+
+        if (!timestamps[0])
+            return;
+
+        this._binsPerTimeline = Math.min(this._cachedOffsetWidth/2, WebInspector.TickerTimelineNavigationItem.MaxBinsPerTimeline);
+
+        var interval = WebInspector.TickerTimelineNavigationItem.MaxRecordLifetime;
+        var now = Date.now();
+        if (!this._previousAnimationTime)
+            this._minTimestamp = timestamps[0] - interval;
+        else
+            this._minTimestamp = this._minTimestamp + (now - this._previousAnimationTime) * 0.001;
+
+        this._previousAnimationTime = now;
+        var timestampGranularity = interval / this._binsPerTimeline;
+        this._resetTimeline();
+
+        // Create sparse arrays with 101 cells each to fill with counts for a given group.
+        function markPercentagesForTimestamp(timestamp)
+        {
+            if (timestamp < this._minTimestamp)
+                return false;
+
+            var snappedTimestamp = timestamp - (timestamp % timestampGranularity);
+            var percent = Math.round(this._binsPerTimeline * (snappedTimestamp - this._minTimestamp) / interval);
+            var percentile = Number.constrain(percent, 0, this._binsPerTimeline-1);
+
+            if (!this._timeline.data[percentile])
+                this._timeline.data[percentile] = 1;
+            else
+                this._timeline.data[percentile] += 1;
+
+            return true;
+        }
+        var i = 0;
+        for (i = timestamps.length-1; i >= 0; i--) {
+            if (!markPercentagesForTimestamp.call(this, timestamps[i]))
+                break;
+        }
+
+        var timeline = this._timeline;
+        var highMark = 0;
+        for (var i = 0; i < timeline.data.length; i++) {
+            if (timeline.data[i] > highMark && i < timeline.data.length*0.9) {
+                highMark = timeline.data[i];
+                timeline.maxIndex = i;
+            }
+        }
+    },
+
+    _clearGraph: function(ctx)
+    {
+        if (typeof ctx === "undefined")
+            ctx = this._canvas.getContext("2d");
+
+        var availHeight = this._canvas.height;
+        var availWidth = this._canvas.width;
+
+        ctx.clearRect(0, 0, availWidth, availHeight);
+
+        // Draw border.
+        ctx.strokeStyle = WebInspector.TickerTimelineNavigationItem.GraphBorderStrokeColor.value;
+        ctx.lineWidth = WebInspector.TickerTimelineNavigationItem.GraphBorderWidth;
+        ctx.lineJoin = "round";
+        ctx.beginPath();
+        ctx.moveTo(0, 0);
+        ctx.lineTo(availWidth, 0);
+        ctx.lineTo(availWidth, availHeight);
+        ctx.lineTo(0, availHeight);
+        ctx.lineTo(0, 0);
+        ctx.stroke();
+    },
+
+    _drawGraph: function()
+    {
+        var ctx = this._canvas.getContext('2d');
+        this._clearGraph(ctx);
+
+        if (!this._timeline.data)
+            return;
+
+        //ctx.save();
+        //ctx.translate(WebInspector.TickerTimelineNavigationItem.GraphBorderWidth, WebInspector.TickerTimelineNavigationItem.GraphBorderWidth);
+
+        var pointCount = this._binsPerTimeline;
+        var availHeight = this._canvas.height - WebInspector.TickerTimelineNavigationItem.GraphBorderWidth * 2 + 1;
+        var availWidth = this._canvas.width - WebInspector.TickerTimelineNavigationItem.GraphBorderWidth * 2 + 1;
+        var offsetPerPoint = availWidth / pointCount;
+        var maxValue = this._timeline.data[this._timeline.maxIndex];
+
+        // Draw bars for all actions.
+        function drawLineGraph(data) {
+            ctx.beginPath();
+            ctx.moveTo(0, availHeight);
+            for (var i = 0; i < pointCount; ++i) {
+                var percent = (data[i] / maxValue) || 0;
+                var pointX = (offsetPerPoint * i) + (offsetPerPoint / 2);
+                var pointY = availHeight * (1 - percent);
+                ctx.lineTo(pointX, pointY);
+            }
+            ctx.lineTo(availWidth, availHeight);
+            ctx.lineTo(0, availHeight);
+            ctx.closePath();
+            ctx.fill();
+        }
+
+        var currentData = this._timeline.data;
+        ctx.lineJoin = "round";
+        ctx.fillStyle = WebInspector.TickerTimelineNavigationItem.LineGraphFillColor.toString();
+        drawLineGraph.call(this, currentData);
+
+        //ctx.restore();
+    }
+};
-- 
2.0.1

