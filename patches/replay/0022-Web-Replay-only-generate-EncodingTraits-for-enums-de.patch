From bff1b39c2f8161d5e28649f3fb4794b50506ec2a Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Wed, 27 Aug 2014 14:45:59 -0700
Subject: [PATCH] Web Replay: only generate EncodingTraits for enums defined in
 the target framework https://bugs.webkit.org/show_bug.cgi?id=136311

Reviewed by NOBODY (OOPS!).

Source/JavaScriptCore:

Don't generate EncodingTraits for enums unless they belong to the target framework.
Otherwise, enums used in multiple frameworks' inputs cannot be unambiguously encoded/decoded.

Also use Type.encoding_type_argument in more places.

* replay/JSInputs.json: Move the InputQueue enum to here.
* replay/scripts/CodeGeneratorReplayInputs.py: Include WebReplayInputs.h for WebKit.
(Generator.generate_header): Selectively generate traits unless we are running tests.
(Generator.generate_implementation):
(Generator.generate_enum_trait_implementation): add WEBCORE_EXPORT macro to enum encoding traits.
* replay/scripts/CodeGeneratorReplayInputsTemplates.py:

Source/WebCore:

Duplicate the definitions for some enumerations used in WebKit but not in WebCore.
Add enum encoding traits symbols to the export file.

Covered by existing generator tests.

* WebCore.exp.in:
* replay/WebInputs.json:
---
 Source/JavaScriptCore/ChangeLog                    | 19 ++++++++++++++
 Source/JavaScriptCore/replay/JSInputs.json         |  9 +++++++
 .../replay/scripts/CodeGeneratorReplayInputs.py    | 27 +++++++++++++++++---
 .../scripts/CodeGeneratorReplayInputsTemplates.py  | 24 +++++++++---------
 Source/WebCore/ChangeLog                           | 15 +++++++++++
 Source/WebCore/WebCore.exp.in                      |  4 +++
 Source/WebCore/replay/WebInputs.json               | 29 ++++++++++++++++++++++
 7 files changed, 111 insertions(+), 16 deletions(-)

diff --git a/Source/JavaScriptCore/ChangeLog b/Source/JavaScriptCore/ChangeLog
index 317b76b..b5da802 100644
--- a/Source/JavaScriptCore/ChangeLog
+++ b/Source/JavaScriptCore/ChangeLog
@@ -1,10 +1,29 @@
+2014-08-27  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Replay: only generate EncodingTraits for enums defined in the target framework
+        https://bugs.webkit.org/show_bug.cgi?id=136311
+
+        Reviewed by NOBODY (OOPS!).
+
+        Don't generate EncodingTraits for enums unless they belong to the target framework.
+        Otherwise, enums used in multiple frameworks' inputs cannot be unambiguously encoded/decoded.
+
+        Also use Type.encoding_type_argument in more places.
+
+        * replay/JSInputs.json: Move the InputQueue enum to here.
+        * replay/scripts/CodeGeneratorReplayInputs.py: Include WebReplayInputs.h for WebKit.
+        (Generator.generate_header): Selectively generate traits unless we are running tests.
+        (Generator.generate_implementation):
+        (Generator.generate_enum_trait_implementation): add WEBCORE_EXPORT macro to enum encoding traits.
+        * replay/scripts/CodeGeneratorReplayInputsTemplates.py:
+
 2015-01-09  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Replay: add support for dispatching inputs with Page or WebPage context
         Need the bug URL (OOPS!).
 
         Reviewed by NOBODY (OOPS!).
 
         Update the inputs code generator to change dispatch() argument based on the
         framework the input is from. WebKit framework inputs have the base class of
         WebEventLoopInput.
diff --git a/Source/JavaScriptCore/replay/JSInputs.json b/Source/JavaScriptCore/replay/JSInputs.json
index 7394d94..8419170 100644
--- a/Source/JavaScriptCore/replay/JSInputs.json
+++ b/Source/JavaScriptCore/replay/JSInputs.json
@@ -1,15 +1,24 @@
 {
     "types": {
         "Global": [
             { "name": "double", "mode": "SCALAR" },
             { "name": "uint64_t", "mode": "SCALAR" }
+        ],
+
+        "JavaScriptCore": [
+            {
+                "name": "InputQueue", "mode": "SCALAR", "storage": "uint8_t",
+                "flags": ["ENUM_CLASS"],
+                "values": ["EventLoopInput", "LoaderMemoizedData", "ScriptMemoizedData", "Count"],
+                "header": "replay/NondeterministicInput.h"
+            }
         ]
     },
 
     "inputs": [
         {
             "name": "GetCurrentTime",
             "description": "Supplies the system time to Date.now() and new Date().",
             "queue": "SCRIPT_MEMOIZED",
             "members": [
                 { "name": "currentTime", "type": "double" }
diff --git a/Source/JavaScriptCore/replay/scripts/CodeGeneratorReplayInputs.py b/Source/JavaScriptCore/replay/scripts/CodeGeneratorReplayInputs.py
index 3bdc070..6bfe7e1 100644
--- a/Source/JavaScriptCore/replay/scripts/CodeGeneratorReplayInputs.py
+++ b/Source/JavaScriptCore/replay/scripts/CodeGeneratorReplayInputs.py
@@ -44,20 +44,23 @@ GLOBAL_CONFIG = {
     "baseFilename": "ReplayInputs",
     "guardCondition": "ENABLE(WEB_REPLAY)",
     "traitsFrameworkName": "JavaScriptCore",
 
     # These are formatted as ([allowed_frameworks], (framework, header_path)).
     # The generator can figure out how to format the includes.
     "headerIncludes": [
         (["WebKit"],
             ("WebKit", "WebProcess/Replay/WebEventLoopInput.h")
         ),
+        (["WebKit"],
+            ("WebCore", "WebReplayInputs.h")
+        ),
         (["WebCore"],
             ("WebCore", "replay/EventLoopInput.h")
         ),
         (["JavaScriptCore"],
             ("JavaScriptCore", "replay/NondeterministicInput.h")
         ),
         (["WebKit", "WebCore", "JavaScriptCore"],
             ("JavaScriptCore", "replay/EncodedValue.h")
         ),
         (["WebCore"],
@@ -105,20 +108,21 @@ FRAMEWORK_CONFIG_MAP = {
         "namespace": "WTF",
     },
     "JavaScriptCore": {
         "prefix": "JS",
         "namespace": "JSC",
         "exportMacro": "JS_EXPORT_PRIVATE",
     },
     "WebCore": {
         "prefix": "Web",
         "namespace": "WebCore",
+        "exportMacro": "WEBCORE_EXPORT"
     },
     "WebKit": {
         "prefix": "WK",
         "namespace": "WebKit",
     },
     # Used for bindings tests.
     "Test": {
         "prefix": "Test",
         "namespace": "Test",
     }
@@ -588,49 +592,57 @@ class Generator:
         header_file = IncrementalFileWriter(os.path.join(_dir, self.output_filename('h')), force)
         implementation_file = IncrementalFileWriter(os.path.join(_dir, self.output_filename('cpp')), force)
 
         header_file.write(self.generate_header())
         implementation_file.write(self.generate_implementation())
 
         header_file.close()
         implementation_file.close()
 
     def generate_header(self):
+        enums_to_generate = self._model.enum_types()
+        if self.target_framework is not Frameworks.Test:  # Force generation of enum traits for testing.
+            enums_to_generate = filter(lambda enum: enum.framework is self.target_framework, enums_to_generate)
+
         template_arguments = {
             'licenseBlock': self.generate_license(),
             'headerGuard': re.sub('[-./]', '_', self.output_filename() + ".h"),
             'filename': self.output_filename(),
             'guardCondition': self.setting('guardCondition'),
             'traitsNamespace': self.traits_framework.setting('namespace'),
             'inputsNamespace': self.target_framework.setting('namespace'),
             'includes': self.generate_includes(defaults=self.setting('headerIncludes')),
             'typeForwardDeclarations': self.generate_type_forward_declarations(),
             'inputForwardDeclarations': "\n".join([wrap_with_guard("class %s;", _input.guard) % _input.name for _input in self._model.inputs]),
             'inputClassDeclarations': "\n\n".join([self.generate_class_declaration(_input) for _input in self._model.inputs]),
             'inputTraitDeclarations': "\n\n".join([self.generate_input_trait_declaration(_input) for _input in self._model.inputs]),
-            'enumTraitDeclarations': "\n\n".join([wrap_with_guard(self.generate_enum_trait_declaration(_type), _type.guard) for _type in self._model.enum_types()]),
+            'enumTraitDeclarations': "\n\n".join([wrap_with_guard(self.generate_enum_trait_declaration(_type), _type.guard) for _type in enums_to_generate]),
             'forEachMacro': self.generate_for_each_macro(),
         }
 
         return Template(Templates.HeaderSkeleton).substitute(template_arguments)
 
     def generate_implementation(self):
+        enums_to_generate = self._model.enum_types()
+        if self.target_framework is not Frameworks.Test:  # Force generation of enum traits for testing.
+            enums_to_generate = filter(lambda enum: enum.framework is self.target_framework, enums_to_generate)
+
         template_arguments = {
             'licenseBlock': self.generate_license(),
             'filename': self.output_filename(),
             'guardCondition': self.setting('guardCondition'),
             'traitsNamespace': self.traits_framework.setting('namespace'),
             'inputsNamespace': self.target_framework.setting('namespace'),
             'includes': self.generate_includes(defaults=self.setting('implIncludes'), includes_for_types=True),
             'inputClassImplementations': "\n\n".join([self.generate_class_implementation(_input) for _input in self._model.inputs]),
             'inputTraitImplementations': "\n\n".join([self.generate_input_trait_implementation(_input) for _input in self._model.inputs]),
-            'enumTraitImplementations': "\n\n".join([wrap_with_guard(self.generate_enum_trait_implementation(_type), _type.guard) for _type in self._model.enum_types()]),
+            'enumTraitImplementations': "\n\n".join([wrap_with_guard(self.generate_enum_trait_implementation(_type), _type.guard) for _type in enums_to_generate]),
         }
 
         return Template(Templates.ImplementationSkeleton).substitute(template_arguments)
 
     def generate_license(self):
         return Template(Templates.CopyrightBlock).substitute(None, inputFilename=os.path.basename(self._input_filepath))
 
     def generate_include_string(self, framework_name, header_path):
         def chomp_leading_path_component(path):
             components = [path]
@@ -804,24 +816,30 @@ class Generator:
 
         template_arguments = {
             'structOrClass': " ".join(decl_type),
             'queueType': _input.queue.setting('enumValue'),
             'qualifiedInputName': self.qualified_input_name(_input),
         }
 
         return wrap_with_guard(Template(Templates.InputTraitsDeclaration).substitute(template_arguments), _input.guard)
 
     def generate_enum_trait_declaration(self, _type):
+        decl_type = ['struct']
+        if len(self.setting('exportMacro')) > 0:
+            decl_type.append(self.setting('exportMacro'))
+
         should_qualify_type = _type.framework != self.traits_framework
         template = Templates.EnumTraitDeclaration if _type.is_enum() else Templates.EnumClassTraitDeclaration
         template_arguments = {
-            'enumName': _type.type_name(qualified=should_qualify_type),
+            'encodingTypeArgument': _type.encoding_type_argument(qualified=should_qualify_type),
+            'enumType': _type.type_name(qualified=should_qualify_type),
+            'structOrClass': " ".join(decl_type)
         }
         return Template(template).substitute(template_arguments)
 
     def generate_for_each_macro(self):
         macro_name = "%s_REPLAY_INPUT_NAMES_FOR_EACH" % self.setting('prefix').upper()
         lines = []
         lines.append("#define %s(macro) \\" % macro_name)
         lines.extend(["    macro(%s) \\" % _input.name for _input in self._model.inputs])
         lines.append("    \\")
         lines.append("// end of %s" % macro_name)
@@ -895,21 +913,22 @@ class Generator:
                 template_arguments = {
                     'branchKeyword': "else if" if i > 0 else "if",
                     'enumStringValue': guard_value,
                     'qualifiedEnumValue': "%s%s" % (enum_prefix, guard_value),
                     'qualifiedEnumName': _type.type_name(qualified=should_qualify_type)
                 }
                 guardedLines.append(Template(decode_template).substitute(template_arguments))
             decodeLines.append(wrap_with_guard("\n".join(guardedLines), guard))
 
         template_arguments = {
-            'enumName': _type.type_name(qualified=should_qualify_type),
+            'encodingTypeArgument': _type.encoding_type_argument(qualified=should_qualify_type),
+            'enumType': _type.type_name(qualified=should_qualify_type),
             'encodeCases': "\n".join(encodeLines),
             'decodeCases': "\n".join(decodeLines)
         }
 
         return Template(enum_trait_template).substitute(template_arguments)
 
     def generate_input_trait_implementation(self, _input):
         template_arguments = {
             'inputsNamespace': self.target_framework.setting('namespace'),
             'inputNameStringLiteral': '"%s"' % _input.name,
diff --git a/Source/JavaScriptCore/replay/scripts/CodeGeneratorReplayInputsTemplates.py b/Source/JavaScriptCore/replay/scripts/CodeGeneratorReplayInputsTemplates.py
index 8de7bf6..be00981 100644
--- a/Source/JavaScriptCore/replay/scripts/CodeGeneratorReplayInputsTemplates.py
+++ b/Source/JavaScriptCore/replay/scripts/CodeGeneratorReplayInputsTemplates.py
@@ -98,33 +98,33 @@ ${forEachMacro}
     InputTraitsDeclaration = (
     """template<> ${structOrClass} InputTraits<${qualifiedInputName}> {
     static InputQueue queue() { return InputQueue::${queueType}; }
     static const String& type();
 
     static void encode(JSC::EncodedValue&, const ${qualifiedInputName}&);
     static bool decode(JSC::EncodedValue&, std::unique_ptr<${qualifiedInputName}>&);
 };""")
 
     EnumTraitDeclaration = (
-    """template<> struct EncodingTraits<${enumName}> {
-    typedef ${enumName} DecodedType;
+    """template<> ${structOrClass} EncodingTraits<${encodingTypeArgument}> {
+    typedef ${enumType} DecodedType;
 
-    static EncodedValue encodeValue(const ${enumName}& value);
-    static bool decodeValue(EncodedValue&, ${enumName}& value);
+    static EncodedValue encodeValue(const ${enumType}& value);
+    static bool decodeValue(EncodedValue&, ${enumType}& value);
 };""")
 
     EnumClassTraitDeclaration = (
-    """template<> struct EncodingTraits<${enumName}> {
-    typedef ${enumName} DecodedType;
+    """template<> ${structOrClass} EncodingTraits<${encodingTypeArgument}> {
+    typedef ${enumType} DecodedType;
 
-    static EncodedValue encodeValue(const ${enumName}& value);
-    static bool decodeValue(EncodedValue&, ${enumName}& value);
+    static EncodedValue encodeValue(const ${enumType}& value);
+    static bool decodeValue(EncodedValue&, ${enumType}& value);
 };""")
 
     InputClassDeclaration = (
     """class ${inputName} : public ${baseClass} {
 public:
 ${inputConstructor}
 ${inputDestructor}
 ${extraDeclarations}
 ${memberGetters}
 ${memberDeclarations}
@@ -164,53 +164,53 @@ ${encodeSteps}
 }
 
 bool InputTraits<${qualifiedInputName}>::decode(EncodedValue& encodedValue, std::unique_ptr<${qualifiedInputName}>& input)
 {
 ${decodeSteps}
     input = std::make_unique<${qualifiedInputName}>(${constructorArguments});
     return true;
 }""")
 
     EnumClassTraitImplementation = (
-    """EncodedValue EncodingTraits<${enumName}>::encodeValue(const ${enumName}& enumValue)
+    """EncodedValue EncodingTraits<${encodingTypeArgument}>::encodeValue(const ${enumType}& enumValue)
 {
     switch (enumValue) {
 ${encodeCases}
     default: ASSERT_NOT_REACHED(); return EncodedValue::createString("Error!");
     }
 }
 
-bool EncodingTraits<${enumName}>::decodeValue(EncodedValue& encodedValue, ${enumName}& enumValue)
+bool EncodingTraits<${encodingTypeArgument}>::decodeValue(EncodedValue& encodedValue, ${enumType}& enumValue)
 {
     String enumString = encodedValue.convertTo<String>();
 ${decodeCases}
     return false;
 }""")
 
     EnumClassEncodeCase = (
     """    case ${qualifiedEnumValue}: return EncodedValue::createString("${enumStringValue}");""")
 
     EnumClassDecodeCase = (
     """    if (enumString == "${enumStringValue}") {
         enumValue = ${qualifiedEnumValue};
         return true;
     }""")
 
     EnumTraitImplementation = (
-    """EncodedValue EncodingTraits<${enumName}>::encodeValue(const ${enumName}& enumValue)
+    """EncodedValue EncodingTraits<${encodingTypeArgument}>::encodeValue(const ${enumType}& enumValue)
 {
     EncodedValue encodedValue = EncodedValue::createArray();
 ${encodeCases}
     return encodedValue;
 }
 
-bool EncodingTraits<${enumName}>::decodeValue(EncodedValue& encodedValue, ${enumName}& enumValue)
+bool EncodingTraits<${encodingTypeArgument}>::decodeValue(EncodedValue& encodedValue, ${enumType}& enumValue)
 {
     Vector<String> enumStrings;
     if (!EncodingTraits<Vector<String>>::decodeValue(encodedValue, enumStrings))
         return false;
 
     for (const String& enumString : enumStrings) {
 ${decodeCases}
     }
 
     return true;
diff --git a/Source/WebCore/ChangeLog b/Source/WebCore/ChangeLog
index e1d49c5..75934e3 100644
--- a/Source/WebCore/ChangeLog
+++ b/Source/WebCore/ChangeLog
@@ -1,10 +1,25 @@
+2014-08-27  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Replay: only generate EncodingTraits for enums defined in the target framework
+        https://bugs.webkit.org/show_bug.cgi?id=136311
+
+        Reviewed by NOBODY (OOPS!).
+
+        Duplicate the definitions for some enumerations used in WebKit but not in WebCore.
+        Add enum encoding traits symbols to the export file.
+
+        Covered by existing generator tests.
+
+        * WebCore.exp.in:
+        * replay/WebInputs.json:
+
 2015-01-11  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Replay: capture and dispatch navigation inputs from WebPage
         Need the bug URL (OOPS!).
 
         Reviewed by NOBODY (OOPS!).
 
         Finish moving interception methods from UserInputBridge into WebPage
         Remove UserinputBridge accessors and state changes.
 
diff --git a/Source/WebCore/WebCore.exp.in b/Source/WebCore/WebCore.exp.in
index 1a746e4..9b3fff6 100644
--- a/Source/WebCore/WebCore.exp.in
+++ b/Source/WebCore/WebCore.exp.in
@@ -3554,22 +3554,26 @@ __ZN3JSC11InputTraitsIN7WebCore28ResourceLoaderDidReceiveDataEE4typeEv
 __ZN3JSC11InputTraitsIN7WebCore28ResourceLoaderDidReceiveDataEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
 __ZN3JSC11InputTraitsIN7WebCore28ResourceLoaderDidReceiveDataEE6encodeERNS_12EncodedValueERKS2_
 __ZN3JSC11InputTraitsIN7WebCore30ResourceLoaderDidFinishLoadingEE4typeEv
 __ZN3JSC11InputTraitsIN7WebCore30ResourceLoaderDidFinishLoadingEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
 __ZN3JSC11InputTraitsIN7WebCore30ResourceLoaderDidFinishLoadingEE6encodeERNS_12EncodedValueERKS2_
 __ZN3JSC11InputTraitsIN7WebCore32ResourceLoaderDidReceiveResponseEE4typeEv
 __ZN3JSC11InputTraitsIN7WebCore32ResourceLoaderDidReceiveResponseEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
 __ZN3JSC11InputTraitsIN7WebCore32ResourceLoaderDidReceiveResponseEE6encodeERNS_12EncodedValueERKS2_
 __ZN3JSC14EncodingTraitsIN7WebCore15KeypressCommandEE11decodeValueERNS_12EncodedValueERS2_
 __ZN3JSC14EncodingTraitsIN7WebCore15KeypressCommandEE11encodeValueERKS2_
+__ZN3JSC14EncodingTraitsIN7WebCore15ScrollDirectionEE11decodeValueERNS_12EncodedValueERS2_
+__ZN3JSC14EncodingTraitsIN7WebCore15ScrollDirectionEE11encodeValueERKS2_
 __ZN3JSC14EncodingTraitsIN7WebCore16FrameLoadRequestEE11decodeValueERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
 __ZN3JSC14EncodingTraitsIN7WebCore16FrameLoadRequestEE11encodeValueERKS2_
+__ZN3JSC14EncodingTraitsIN7WebCore17ScrollGranularityEE11decodeValueERNS_12EncodedValueERS2_
+__ZN3JSC14EncodingTraitsIN7WebCore17ScrollGranularityEE11encodeValueERKS2_
 __ZN3JSC14EncodingTraitsIN7WebCore8IntPointEE11decodeValueERNS_12EncodedValueERS2_
 __ZN3JSC14EncodingTraitsIN7WebCore8IntPointEE11encodeValueERKS2_
 __ZN3JSC14EncodingTraitsIN7WebCore9FloatSizeEE11decodeValueERNS_12EncodedValueERS2_
 __ZN3JSC14EncodingTraitsIN7WebCore9FloatSizeEE11encodeValueERKS2_
 __ZN7WebCore19frameFromFrameIndexEPNS_4PageEj
 __ZN7WebCore19frameIndexFromFrameEPKNS_5FrameE
 __ZN7WebCore20EventLoopInputExtentC1ERN3JSC11InputCursorE
 __ZN7WebCore20EventLoopInputExtentD1Ev
 __ZNK7WebCore14ResourceLoader17activeInputCursorEv
 __ZNK7WebCore16ReplayController17activeInputCursorEv
diff --git a/Source/WebCore/replay/WebInputs.json b/Source/WebCore/replay/WebInputs.json
index d4f3b34..19bcbde 100644
--- a/Source/WebCore/replay/WebInputs.json
+++ b/Source/WebCore/replay/WebInputs.json
@@ -79,20 +79,49 @@
             },
             {
                 "name": "ResourceError", "mode": "OWNED",
                 "header": "platform/network/ResourceError.h"
             },
             {
                 "name": "ResourceResponse", "mode": "OWNED",
                 "header": "platform/network/ResourceResponse.h"
             },
             {
+                "name": "ScrollDirection", "mode": "SCALAR", "storage": "uint8_t",
+                "flags": ["ENUM"],
+                "values": ["ScrollUp", "ScrollDown", "ScrollLeft", "ScrollRight"],
+                "header": "platform/ScrollTypes.h"
+            },
+            {
+                "name": "ScrollGranularity", "mode": "SCALAR", "storage": "uint8_t",
+                "flags": ["ENUM"],
+                "values": [
+                    "ScrollByLine",
+                    "ScrollByPage",
+                    "ScrollByDocument",
+                    "ScrollByPixel",
+                    "ScrollByPrecisePixel"
+                ],
+                "header": "platform/ScrollTypes.h"
+            },
+            {
+                "name": "ScrollLogicalDirection", "mode": "SCALAR", "storage": "uint8_t",
+                "flags": ["ENUM"],
+                "values": [
+                    "ScrollBlockDirectionBackward",
+                    "ScrollBlockDirectionForward",
+                    "ScrollInlineDirectionBackward",
+                    "ScrollInlineDirectionForward"
+                ],
+                "header": "platform/ScrollTypes.h"
+            },
+            {
                 "name": "SecurityOrigin", "mode": "SHARED",
                 "header": "page/SecurityOrigin.h"
             },
             {
                 "name": "SharedBuffer", "mode": "SHARED",
                 "header": "platform/SharedBuffer.h"
             },
              {
                 "name": "Type", "mode": "SCALAR",
                 "enclosing_class": "FormDataElement",
-- 
2.0.1

