From 85e4855bd3947378f6480099bf55abb1455d402a Mon Sep 17 00:00:00 2001
From: "Brian J. Burg" <burg@cs.washington.edu>
Date: Wed, 20 Aug 2014 15:32:34 -0700
Subject: [PATCH] Web Replay: Encode replay inputs through ReplayClient Need
 the bug URL (OOPS!).

Reviewed by NOBODY (OOPS!).

Only WebKit2 can access all possible replay inputs, so it should contain
the big function with cases to encode each input based on its type tag.

Move some logging code out of SegmentedInputStorage so that inputs can be encoded
through ReplayClient and then displayed in the serialized JSON representation.

No new tests, no behavior was changed.

Source/WebCore:

* WebCore.exp.in: Add symbols for EncodingTraits specializations of WebCore inputs.
* WebCore.xcodeproj/project.pbxproj:
* inspector/InspectorReplayAgent.cpp:
(WebCore::SerializeInputToJSONFunctor::SerializeInputToJSONFunctor):
(WebCore::SerializeInputToJSONFunctor::operator()):
(WebCore::buildInspectorObjectForSegment):
(WebCore::InspectorReplayAgent::getSegmentData):
(WebCore::buildInspectorObjectForInput): Deleted.
* loader/EmptyClients.h:
* replay/AllReplayInputs.h: Removed. It doesn't really do anything.
* replay/CapturingInputCursor.cpp:
(queueTypeToLogPrefix):
(WebCore::CapturingInputCursor::CapturingInputCursor):
(WebCore::CapturingInputCursor::create):
(WebCore::CapturingInputCursor::storeInput):
* replay/CapturingInputCursor.h:
* replay/EventLoopInputDispatcher.cpp:
(WebCore::EventLoopInputDispatcher::dispatchInput):
* replay/ReplayClient.h: Add encodeInput virtual method.
* replay/ReplayController.cpp:
(WebCore::ReplayController::createSegment):
* replay/ReplayingInputCursor.cpp:
(WebCore::queueTypeToLogPrefix):
(WebCore::ReplayingInputCursor::ReplayingInputCursor):
(WebCore::ReplayingInputCursor::uncheckedLoadInput):
* replay/ReplayingInputCursor.h:
* replay/SegmentedInputStorage.cpp:
(WebCore::SegmentedInputStorage::load):
(WebCore::SegmentedInputStorage::store):
(WebCore::queueTypeToLogPrefix): Deleted.
(WebCore::jsonStringForInput): Deleted.
* replay/SegmentedInputStorage.h:
* replay/WebReplayInputCoders.cpp:
* replay/WebReplayInputDispatchMethods.cpp:

Source/WebKit2:

* CMakeLists.txt:
* WebKit2.xcodeproj/project.pbxproj:
* WebProcess/Replay/WKReplayInputCoders.cpp: Added.
* WebProcess/Replay/WKReplayInputCoders.h: Added.
* WebProcess/WebCoreSupport/WebReplayClient.cpp:
(WebKit::WebReplayClient::encodeInput):
* WebProcess/WebCoreSupport/WebReplayClient.h:
---
 Source/WebCore/ChangeLog                           | 50 ++++++++++++
 Source/WebCore/WebCore.exp.in                      | 76 ++++++++++++++++++-
 Source/WebCore/WebCore.xcodeproj/project.pbxproj   | 10 +--
 Source/WebCore/inspector/InspectorReplayAgent.cpp  | 36 ++++-----
 Source/WebCore/loader/EmptyClients.h               |  2 +
 Source/WebCore/replay/AllReplayInputs.h            | 48 ------------
 Source/WebCore/replay/CapturingInputCursor.cpp     | 41 +++++++++-
 Source/WebCore/replay/CapturingInputCursor.h       |  5 +-
 Source/WebCore/replay/EventLoopInputDispatcher.cpp | 10 +--
 Source/WebCore/replay/ReplayClient.h               |  8 ++
 Source/WebCore/replay/ReplayController.cpp         |  3 +-
 Source/WebCore/replay/ReplayingInputCursor.cpp     | 28 ++++++-
 Source/WebCore/replay/ReplayingInputCursor.h       |  1 +
 Source/WebCore/replay/SegmentedInputStorage.cpp    | 43 +----------
 Source/WebCore/replay/SegmentedInputStorage.h      |  2 +-
 Source/WebCore/replay/WebReplayInputCoders.cpp     | 59 +--------------
 Source/WebCore/replay/WebReplayInputCoders.h       |  7 --
 .../replay/WebReplayInputDispatchMethods.cpp       |  2 +-
 Source/WebKit2/CMakeLists.txt                      |  1 +
 Source/WebKit2/ChangeLog                           | 23 ++++++
 Source/WebKit2/WebKit2.xcodeproj/project.pbxproj   |  8 ++
 .../WebProcess/Replay/WKReplayInputCoders.cpp      | 88 ++++++++++++++++++++++
 .../WebProcess/Replay/WKReplayInputCoders.h        | 49 ++++++++++++
 .../WebProcess/WebCoreSupport/WebReplayClient.cpp  | 12 +++
 .../WebProcess/WebCoreSupport/WebReplayClient.h    |  3 +
 25 files changed, 422 insertions(+), 193 deletions(-)
 delete mode 100644 Source/WebCore/replay/AllReplayInputs.h
 create mode 100644 Source/WebKit2/WebProcess/Replay/WKReplayInputCoders.cpp
 create mode 100644 Source/WebKit2/WebProcess/Replay/WKReplayInputCoders.h

diff --git a/Source/WebCore/ChangeLog b/Source/WebCore/ChangeLog
index 7107d1f..1b6b729 100644
--- a/Source/WebCore/ChangeLog
+++ b/Source/WebCore/ChangeLog
@@ -1,12 +1,62 @@
 2014-08-20  Brian J. Burg  <burg@cs.washington.edu>
 
+        Web Replay: Encode replay inputs through ReplayClient
+        Need the bug URL (OOPS!).
+
+        Reviewed by NOBODY (OOPS!).
+
+        Only WebKit2 can access all possible replay inputs, so it should contain
+        the big function with cases to encode each input based on its type tag.
+
+        Move some logging code out of SegmentedInputStorage so that inputs can be encoded
+        through ReplayClient and then displayed in the serialized JSON representation.
+
+        No new tests, no behavior was changed.
+
+        * WebCore.exp.in: Add symbols for EncodingTraits specializations of WebCore inputs.
+        * WebCore.xcodeproj/project.pbxproj:
+        * inspector/InspectorReplayAgent.cpp:
+        (WebCore::SerializeInputToJSONFunctor::SerializeInputToJSONFunctor):
+        (WebCore::SerializeInputToJSONFunctor::operator()):
+        (WebCore::buildInspectorObjectForSegment):
+        (WebCore::InspectorReplayAgent::getSegmentData):
+        (WebCore::buildInspectorObjectForInput): Deleted.
+        * loader/EmptyClients.h:
+        * replay/AllReplayInputs.h: Removed. It doesn't really do anything.
+        * replay/CapturingInputCursor.cpp:
+        (queueTypeToLogPrefix):
+        (WebCore::CapturingInputCursor::CapturingInputCursor):
+        (WebCore::CapturingInputCursor::create):
+        (WebCore::CapturingInputCursor::storeInput):
+        * replay/CapturingInputCursor.h:
+        * replay/EventLoopInputDispatcher.cpp:
+        (WebCore::EventLoopInputDispatcher::dispatchInput):
+        * replay/ReplayClient.h: Add encodeInput virtual method.
+        * replay/ReplayController.cpp:
+        (WebCore::ReplayController::createSegment):
+        * replay/ReplayingInputCursor.cpp:
+        (WebCore::queueTypeToLogPrefix):
+        (WebCore::ReplayingInputCursor::ReplayingInputCursor):
+        (WebCore::ReplayingInputCursor::uncheckedLoadInput):
+        * replay/ReplayingInputCursor.h:
+        * replay/SegmentedInputStorage.cpp:
+        (WebCore::SegmentedInputStorage::load):
+        (WebCore::SegmentedInputStorage::store):
+        (WebCore::queueTypeToLogPrefix): Deleted.
+        (WebCore::jsonStringForInput): Deleted.
+        * replay/SegmentedInputStorage.h:
+        * replay/WebReplayInputCoders.cpp:
+        * replay/WebReplayInputDispatchMethods.cpp:
+
+2014-08-20  Brian J. Burg  <burg@cs.washington.edu>
+
         Web Replay: Use framework prefixes for framework-specific replay input code
         Need the bug URL (OOPS!).
 
         Reviewed by NOBODY (OOPS!).
 
         In preparation for moving some inputs to WebKit2, add the 'Web' prefix to some
         files that are specific to WebCore inputs. This includes encode/decode methods,
         factory methods, and input dispatch implementations.
 
         Also rename SerializationMethods to ReplayInputCoders to match WebKit2 naming schemes.
diff --git a/Source/WebCore/WebCore.exp.in b/Source/WebCore/WebCore.exp.in
index a7ea993..0c61eef 100644
--- a/Source/WebCore/WebCore.exp.in
+++ b/Source/WebCore/WebCore.exp.in
@@ -3496,16 +3496,90 @@ __ZTVN7WebCore32WebVideoFullscreenInterfaceAVKitE
 
 #if ENABLE(VIDEO_TRACK)
 __ZN7WebCore9PageGroup18captionPreferencesEv
 #endif
 
 #if ENABLE(VIEW_MODE_CSS_MEDIA)
 __ZN7WebCore4Page11setViewModeENS0_8ViewModeE
 #endif
 
 #if ENABLE(WEB_REPLAY)
-__ZNK7WebCore14ResourceLoader17activeInputCursorEv
+__ZN3JSC11InputTraitsIN7WebCore10ScrollPageEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore10ScrollPageEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore10ScrollPageEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore11ReloadFrameEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore11ReloadFrameEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore11ReloadFrameEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore12TryClosePageEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore12TryClosePageEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore12TryClosePageEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore13DOMTimerFiredEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore13DOMTimerFiredEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore13DOMTimerFiredEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore14HandleKeyPressEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore14HandleKeyPressEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore14HandleKeyPressEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore14LoadURLRequestEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore14LoadURLRequestEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore14LoadURLRequestEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore15AsyncTimerFiredEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore15AsyncTimerFiredEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore15AsyncTimerFiredEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore15DOMTimerCreatedEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore15DOMTimerCreatedEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore15DOMTimerCreatedEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore15FetchPluginDataEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore15FetchPluginDataEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore15FetchPluginDataEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore15HandleMouseMoveEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore15HandleMouseMoveEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore16HandleMousePressEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore16HandleMousePressEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore16HandleWheelEventEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore16HandleWheelEventEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore16HandleWheelEventEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore16StopLoadingFrameEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore16StopLoadingFrameEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore16StopLoadingFrameEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore17InitialNavigationEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore17InitialNavigationEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore17InitialNavigationEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore17InitializeHistoryEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore17InitializeHistoryEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore17InitializeHistoryEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore17LogicalScrollPageEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore17LogicalScrollPageEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore17LogicalScrollPageEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore18EndSegmentSentinelEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore18EndSegmentSentinelEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore18EndSegmentSentinelEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore18HandleMouseReleaseEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore18HandleMouseReleaseEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore20BeginSegmentSentinelEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore20BeginSegmentSentinelEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore20BeginSegmentSentinelEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore21MemoizedDOMResultBaseEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore21MemoizedDOMResultBaseEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore21MemoizedDOMResultBaseEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore21ResourceLoaderDidFailEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore21ResourceLoaderDidFailEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore21ResourceLoaderDidFailEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore24DocumentLastModifiedDateEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore24DocumentLastModifiedDateEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore24DocumentLastModifiedDateEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore25ResourceLoaderDidSendDataEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore25ResourceLoaderDidSendDataEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore25ResourceLoaderDidSendDataEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore28ResourceLoaderDidReceiveDataEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore28ResourceLoaderDidReceiveDataEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore28ResourceLoaderDidReceiveDataEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore30ResourceLoaderDidFinishLoadingEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore30ResourceLoaderDidFinishLoadingEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore30ResourceLoaderDidFinishLoadingEE6encodeERNS_12EncodedValueERKS2_
+__ZN3JSC11InputTraitsIN7WebCore32ResourceLoaderDidReceiveResponseEE4typeEv
+__ZN3JSC11InputTraitsIN7WebCore32ResourceLoaderDidReceiveResponseEE6decodeERNS_12EncodedValueERNSt3__110unique_ptrIS2_NS6_14default_deleteIS2_EEEE
+__ZN3JSC11InputTraitsIN7WebCore32ResourceLoaderDidReceiveResponseEE6encodeERNS_12EncodedValueERKS2_
 #endif
 
 #if ENABLE(WEB_TIMING)
 __ZNK7WebCore20ResourceResponseBase18resourceLoadTimingEv
 #endif
diff --git a/Source/WebCore/WebCore.xcodeproj/project.pbxproj b/Source/WebCore/WebCore.xcodeproj/project.pbxproj
index 8f9f7a2..b735b31 100644
--- a/Source/WebCore/WebCore.xcodeproj/project.pbxproj
+++ b/Source/WebCore/WebCore.xcodeproj/project.pbxproj
@@ -3622,23 +3622,24 @@
 		97F8E666151D4A4E00D2D181 /* WorkerGlobalScopeNotifications.h in Headers */ = {isa = PBXBuildFile; fileRef = 97F8E662151D4A3F00D2D181 /* WorkerGlobalScopeNotifications.h */; };
 		9831AE4A154225C900FE2644 /* ReferrerPolicy.h in Headers */ = {isa = PBXBuildFile; fileRef = 9831AE49154225A200FE2644 /* ReferrerPolicy.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		984264F112D5280A000D88A4 /* LinkLoaderClient.h in Headers */ = {isa = PBXBuildFile; fileRef = 984264EF12D5280A000D88A4 /* LinkLoaderClient.h */; };
 		985BB96D13A94058007A0B69 /* LinkRelAttribute.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 985BB96B13A94058007A0B69 /* LinkRelAttribute.cpp */; };
 		985BB96E13A94058007A0B69 /* LinkRelAttribute.h in Headers */ = {isa = PBXBuildFile; fileRef = 985BB96C13A94058007A0B69 /* LinkRelAttribute.h */; };
 		98CE4326129E00BD005821DC /* LinkLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 98CE4325129E00BD005821DC /* LinkLoader.cpp */; };
 		98CE432A129E00E5005821DC /* LinkLoader.h in Headers */ = {isa = PBXBuildFile; fileRef = 98CE4329129E00E5005821DC /* LinkLoader.h */; };
 		98EB1F951313FE0500D0E1EA /* NotImplemented.h in Headers */ = {isa = PBXBuildFile; fileRef = 98EB1F941313FE0500D0E1EA /* NotImplemented.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		9920398218B95BC600B39AF9 /* UserInputBridge.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 9920398018B95BC600B39AF9 /* UserInputBridge.cpp */; };
 		9920398318B95BC600B39AF9 /* UserInputBridge.h in Headers */ = {isa = PBXBuildFile; fileRef = 9920398118B95BC600B39AF9 /* UserInputBridge.h */; settings = {ATTRIBUTES = (Private, ); }; };
-		99C7CCB318C663E40032E413 /* MemoizedDOMResult.h in Headers */ = {isa = PBXBuildFile; fileRef = 99C7CCB218C663E40032E413 /* MemoizedDOMResult.h */; };
+		996231F318D18AC300C03FDA /* InspectorWebBackendCommands.js in Headers */ = {isa = PBXBuildFile; fileRef = 996231F118D189BD00C03FDA /* InspectorWebBackendCommands.js */; };
+		996231F418D22FA200C03FDA /* InspectorWebBackendCommands.js in Copy Generated Headers */ = {isa = PBXBuildFile; fileRef = 996231F118D189BD00C03FDA /* InspectorWebBackendCommands.js */; };
+		99C7CCB318C663E40032E413 /* MemoizedDOMResult.h in Headers */ = {isa = PBXBuildFile; fileRef = 99C7CCB218C663E40032E413 /* MemoizedDOMResult.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		99C7CCB518C6B8990032E413 /* MemoizedDOMResult.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99C7CCB418C6B8990032E413 /* MemoizedDOMResult.cpp */; };
-		99CC0B4D18BE9849006CEBCC /* AllReplayInputs.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B3818BE9849006CEBCC /* AllReplayInputs.h */; };
 		99CC0B4E18BE9849006CEBCC /* CapturingInputCursor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B3918BE9849006CEBCC /* CapturingInputCursor.cpp */; };
 		99CC0B4F18BE9849006CEBCC /* CapturingInputCursor.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B3A18BE9849006CEBCC /* CapturingInputCursor.h */; };
 		99CC0B5018BE9849006CEBCC /* EventLoopInputDispatcher.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B3B18BE9849006CEBCC /* EventLoopInputDispatcher.cpp */; };
 		99CC0B5118BE9849006CEBCC /* EventLoopInputDispatcher.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B3C18BE9849006CEBCC /* EventLoopInputDispatcher.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		99CC0B5218BE9849006CEBCC /* FunctorInputCursor.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B3D18BE9849006CEBCC /* FunctorInputCursor.h */; };
 		99CC0B5318BE9849006CEBCC /* ReplayController.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B3E18BE9849006CEBCC /* ReplayController.cpp */; };
 		99CC0B5418BE9849006CEBCC /* ReplayController.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B3F18BE9849006CEBCC /* ReplayController.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		99CC0B5518BE9849006CEBCC /* ReplayingInputCursor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B4018BE9849006CEBCC /* ReplayingInputCursor.cpp */; };
 		99CC0B5618BE984A006CEBCC /* ReplayingInputCursor.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B4118BE9849006CEBCC /* ReplayingInputCursor.h */; };
 		99CC0B5718BE984A006CEBCC /* WebReplayInputCreationMethods.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B4218BE9849006CEBCC /* WebReplayInputCreationMethods.cpp */; };
@@ -3647,21 +3648,21 @@
 		99CC0B5A18BE984A006CEBCC /* ReplaySession.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B4518BE9849006CEBCC /* ReplaySession.h */; };
 		99CC0B5B18BE984A006CEBCC /* ReplaySessionSegment.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B4618BE9849006CEBCC /* ReplaySessionSegment.cpp */; };
 		99CC0B5C18BE984A006CEBCC /* ReplaySessionSegment.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B4718BE9849006CEBCC /* ReplaySessionSegment.h */; };
 		99CC0B5D18BE984A006CEBCC /* SegmentedInputStorage.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B4818BE9849006CEBCC /* SegmentedInputStorage.cpp */; };
 		99CC0B5E18BE984A006CEBCC /* SegmentedInputStorage.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B4918BE9849006CEBCC /* SegmentedInputStorage.h */; };
 		99CC0B5F18BE984A006CEBCC /* WebReplayInputCoders.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B4A18BE9849006CEBCC /* WebReplayInputCoders.cpp */; };
 		99CC0B6018BE984A006CEBCC /* WebReplayInputCoders.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B4B18BE9849006CEBCC /* WebReplayInputCoders.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		99CC0B6618BE9F15006CEBCC /* InspectorReplayAgent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B6418BE9F15006CEBCC /* InspectorReplayAgent.cpp */; };
 		99CC0B6718BE9F15006CEBCC /* InspectorReplayAgent.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B6518BE9F15006CEBCC /* InspectorReplayAgent.h */; };
 		99CC0B6A18BEA1FF006CEBCC /* WebReplayInputs.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 99CC0B6818BEA1FF006CEBCC /* WebReplayInputs.cpp */; };
-		99CC0B6B18BEA1FF006CEBCC /* WebReplayInputs.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B6918BEA1FF006CEBCC /* WebReplayInputs.h */; };
+		99CC0B6B18BEA1FF006CEBCC /* WebReplayInputs.h in Headers */ = {isa = PBXBuildFile; fileRef = 99CC0B6918BEA1FF006CEBCC /* WebReplayInputs.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		99E45A1718A063BE0026D88F /* EventLoopInput.h in Headers */ = {isa = PBXBuildFile; fileRef = 99E45A1618A063BE0026D88F /* EventLoopInput.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		9A1142041832D135000BB8AD /* ValueToString.h in Headers */ = {isa = PBXBuildFile; fileRef = 9A1142031832D134000BB8AD /* ValueToString.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		9A1B6F97158869C80011A8C4 /* JSDOMStringListCustom.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 9A1B6F96158869C80011A8C4 /* JSDOMStringListCustom.cpp */; };
 		9A528E8317D7F52F00AA9518 /* FloatingObjects.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 9A528E8117D7F52F00AA9518 /* FloatingObjects.cpp */; };
 		9A528E8417D7F52F00AA9518 /* FloatingObjects.h in Headers */ = {isa = PBXBuildFile; fileRef = 9A528E8217D7F52F00AA9518 /* FloatingObjects.h */; settings = {ATTRIBUTES = (Private, ); }; };
 		9AB1F38018E2489A00534743 /* CSSToLengthConversionData.h in Headers */ = {isa = PBXBuildFile; fileRef = 9AB1F37E18E2489A00534743 /* CSSToLengthConversionData.h */; };
 		9AB1F38118E2489A00534743 /* CSSToLengthConversionData.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 9AB1F37F18E2489A00534743 /* CSSToLengthConversionData.cpp */; };
 		9B1AB07C1648C7C40051F3F2 /* JSHTMLFormControlsCollectionCustom.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 9B1AB07B1648C7C40051F3F2 /* JSHTMLFormControlsCollectionCustom.cpp */; };
 		9B24DE8E15194B9500C59C27 /* HTMLBDIElement.h in Headers */ = {isa = PBXBuildFile; fileRef = 9B24DE8C15194B9500C59C27 /* HTMLBDIElement.h */; };
 		9B2D8A7914997CCF00ECEF3E /* UndoStep.h in Headers */ = {isa = PBXBuildFile; fileRef = 9B2D8A7814997CCF00ECEF3E /* UndoStep.h */; settings = {ATTRIBUTES = (Private, ); }; };
@@ -10827,21 +10828,20 @@
 		984264EF12D5280A000D88A4 /* LinkLoaderClient.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LinkLoaderClient.h; sourceTree = "<group>"; };
 		985BB96B13A94058007A0B69 /* LinkRelAttribute.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LinkRelAttribute.cpp; sourceTree = "<group>"; };
 		985BB96C13A94058007A0B69 /* LinkRelAttribute.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LinkRelAttribute.h; sourceTree = "<group>"; };
 		98CE4325129E00BD005821DC /* LinkLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LinkLoader.cpp; sourceTree = "<group>"; };
 		98CE4329129E00E5005821DC /* LinkLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LinkLoader.h; sourceTree = "<group>"; };
 		98EB1F941313FE0500D0E1EA /* NotImplemented.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = NotImplemented.h; sourceTree = "<group>"; };
 		9920398018B95BC600B39AF9 /* UserInputBridge.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = UserInputBridge.cpp; sourceTree = "<group>"; };
 		9920398118B95BC600B39AF9 /* UserInputBridge.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = UserInputBridge.h; sourceTree = "<group>"; };
 		99C7CCB218C663E40032E413 /* MemoizedDOMResult.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MemoizedDOMResult.h; sourceTree = "<group>"; };
 		99C7CCB418C6B8990032E413 /* MemoizedDOMResult.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MemoizedDOMResult.cpp; sourceTree = "<group>"; };
-		99CC0B3818BE9849006CEBCC /* AllReplayInputs.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AllReplayInputs.h; sourceTree = "<group>"; };
 		99CC0B3918BE9849006CEBCC /* CapturingInputCursor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CapturingInputCursor.cpp; sourceTree = "<group>"; };
 		99CC0B3A18BE9849006CEBCC /* CapturingInputCursor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CapturingInputCursor.h; sourceTree = "<group>"; };
 		99CC0B3B18BE9849006CEBCC /* EventLoopInputDispatcher.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = EventLoopInputDispatcher.cpp; sourceTree = "<group>"; };
 		99CC0B3C18BE9849006CEBCC /* EventLoopInputDispatcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EventLoopInputDispatcher.h; sourceTree = "<group>"; };
 		99CC0B3D18BE9849006CEBCC /* FunctorInputCursor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FunctorInputCursor.h; sourceTree = "<group>"; };
 		99CC0B3E18BE9849006CEBCC /* ReplayController.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ReplayController.cpp; sourceTree = "<group>"; };
 		99CC0B3F18BE9849006CEBCC /* ReplayController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ReplayController.h; sourceTree = "<group>"; };
 		99CC0B4018BE9849006CEBCC /* ReplayingInputCursor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ReplayingInputCursor.cpp; sourceTree = "<group>"; };
 		99CC0B4118BE9849006CEBCC /* ReplayingInputCursor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ReplayingInputCursor.h; sourceTree = "<group>"; };
 		99CC0B4218BE9849006CEBCC /* WebReplayInputCreationMethods.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WebReplayInputCreationMethods.cpp; sourceTree = "<group>"; };
@@ -18462,21 +18462,20 @@
 				977E2E0C12F0FC9C00C13379 /* XSSAuditor.h */,
 				977E2E0B12F0FC9C00C13380 /* XSSAuditorDelegate.cpp */,
 				977E2E0C12F0FC9C00C13380 /* XSSAuditorDelegate.h */,
 			);
 			name = parser;
 			sourceTree = "<group>";
 		};
 		99E45A1318A021760026D88F /* replay */ = {
 			isa = PBXGroup;
 			children = (
-				99CC0B3818BE9849006CEBCC /* AllReplayInputs.h */,
 				99CC0B3918BE9849006CEBCC /* CapturingInputCursor.cpp */,
 				99CC0B3A18BE9849006CEBCC /* CapturingInputCursor.h */,
 				C400D10818F1C8F60090D863 /* EventLoopInput.cpp */,
 				99E45A1618A063BE0026D88F /* EventLoopInput.h */,
 				99CC0B3B18BE9849006CEBCC /* EventLoopInputDispatcher.cpp */,
 				99CC0B3C18BE9849006CEBCC /* EventLoopInputDispatcher.h */,
 				99CC0B3D18BE9849006CEBCC /* FunctorInputCursor.h */,
 				99C7CCB418C6B8990032E413 /* MemoizedDOMResult.cpp */,
 				99C7CCB218C663E40032E413 /* MemoizedDOMResult.h */,
 				99CC0B3E18BE9849006CEBCC /* ReplayController.cpp */,
@@ -23419,21 +23418,20 @@
 				29A8122B0FBB9C1D00510293 /* AccessibilityTable.h in Headers */,
 				29A812320FBB9C1D00510293 /* AccessibilityTableCell.h in Headers */,
 				29A812410FBB9C1D00510293 /* AccessibilityTableColumn.h in Headers */,
 				29A8123F0FBB9C1D00510293 /* AccessibilityTableHeaderContainer.h in Headers */,
 				29A812310FBB9C1D00510293 /* AccessibilityTableRow.h in Headers */,
 				B5D31DFB11CF610B009F22B4 /* ActiveDOMCallback.h in Headers */,
 				E1C4DE690EA75C1E0023CCD6 /* ActiveDOMObject.h in Headers */,
 				BCF7E491137CD7C7001DDAE7 /* AdjustViewSizeOrNot.h in Headers */,
 				84D0C4061115F1EA0018AA34 /* AffineTransform.h in Headers */,
 				0705850817FA4689005F2BCB /* AllAudioCapabilities.h in Headers */,
-				99CC0B4D18BE9849006CEBCC /* AllReplayInputs.h in Headers */,
 				073AB4B317F8BACA006E0D6F /* AllVideoCapabilities.h in Headers */,
 				CEDA12D7152CA1CB00D9E08D /* AlternativeTextClient.h in Headers */,
 				CE08C3D2152B599A0021B8C2 /* AlternativeTextController.h in Headers */,
 				CE7B2DB31586ABAD0098B3FA /* AlternativeTextUIController.h in Headers */,
 				FD31603E12B0267600C1A359 /* AnalyserNode.h in Headers */,
 				31A795C71888BCB200382F90 /* ANGLEInstancedArrays.h in Headers */,
 				490707E71219C04300D90E51 /* ANGLEWebKitBridge.h in Headers */,
 				077AF14018F4AE400001ED61 /* SerializedPlatformRepresentation.h in Headers */,
 				49E912AB0EFAC906009D0CAF /* Animation.h in Headers */,
 				316FE1120E6E1DA700BF6088 /* AnimationBase.h in Headers */,
diff --git a/Source/WebCore/inspector/InspectorReplayAgent.cpp b/Source/WebCore/inspector/InspectorReplayAgent.cpp
index b3d0f9e..f1b5b9c 100644
--- a/Source/WebCore/inspector/InspectorReplayAgent.cpp
+++ b/Source/WebCore/inspector/InspectorReplayAgent.cpp
@@ -35,20 +35,21 @@
 #include "EventLoopInput.h"
 #include "Frame.h"
 #include "FunctorInputCursor.h"
 #include "InspectorController.h"
 #include "InspectorPageAgent.h"
 #include <inspector/InspectorProtocolObjects.h>
 #include "InstrumentingAgents.h"
 #include "Logging.h"
 #include "Page.h"
 #include "ReplayController.h"
+#include "ReplayClient.h"
 #include "ReplaySession.h"
 #include "ReplaySessionSegment.h"
 #include "WebReplayInputCoders.h"
 #include "WebReplayInputs.h" // For EncodingTraits<InputQueue>.
 #include <inspector/InspectorValues.h>
 #include <wtf/text/CString.h>
 #include <wtf/text/WTFString.h>
 
 using namespace Inspector;
 
@@ -56,31 +57,20 @@ namespace WebCore {
 
 static PassRefPtr<Inspector::Protocol::Replay::ReplayPosition> buildInspectorObjectForPosition(const ReplayPosition& position)
 {
     RefPtr<Inspector::Protocol::Replay::ReplayPosition> positionObject = Inspector::Protocol::Replay::ReplayPosition::create()
         .setSegmentOffset(position.segmentOffset)
         .setInputOffset(position.inputOffset);
 
     return positionObject.release();
 }
 
-static PassRefPtr<Inspector::Protocol::Replay::ReplayInput> buildInspectorObjectForInput(const NondeterministicInputBase& input, size_t offset)
-{
-    EncodedValue encodedInput = EncodingTraits<NondeterministicInputBase>::encodeValue(input);
-    RefPtr<Inspector::Protocol::Replay::ReplayInput> inputObject = Inspector::Protocol::Replay::ReplayInput::create()
-        .setType(input.type())
-        .setOffset(offset)
-        .setData(encodedInput.asObject());
-
-    return inputObject.release();
-}
-
 static PassRefPtr<Inspector::Protocol::Replay::ReplaySession> buildInspectorObjectForSession(PassRefPtr<ReplaySession> prpSession)
 {
     RefPtr<ReplaySession> session = prpSession;
     RefPtr<Inspector::Protocol::Array<SegmentIdentifier>> segments = Inspector::Protocol::Array<SegmentIdentifier>::create();
 
     for (auto it = session->begin(); it != session->end(); ++it)
         segments->addItem((*it)->identifier());
 
     RefPtr<Inspector::Protocol::Replay::ReplaySession> sessionObject = Inspector::Protocol::Replay::ReplaySession::create()
         .setId(session->identifier())
@@ -106,44 +96,54 @@ static Inspector::Protocol::Replay::SegmentState buildInspectorObjectForSegmentS
     case WebCore::SegmentState::Unloaded: return Inspector::Protocol::Replay::SegmentState::Unloaded;
     case WebCore::SegmentState::Loaded: return Inspector::Protocol::Replay::SegmentState::Loaded;
     case WebCore::SegmentState::Dispatching: return Inspector::Protocol::Replay::SegmentState::Dispatching;
     }
 }
 
 class SerializeInputToJSONFunctor {
 public:
     typedef PassRefPtr<Inspector::Protocol::Array<Inspector::Protocol::Replay::ReplayInput>> ReturnType;
 
-    SerializeInputToJSONFunctor()
-        : m_inputs(Inspector::Protocol::Array<Inspector::Protocol::Replay::ReplayInput>::create()) { }
+    SerializeInputToJSONFunctor(ReplayClient& client)
+        : m_client(client)
+        , m_inputs(Inspector::Protocol::Array<Inspector::Protocol::Replay::ReplayInput>::create()) { }
     ~SerializeInputToJSONFunctor() { }
 
     void operator()(size_t index, const NondeterministicInputBase* input)
     {
         LOG(WebReplay, "%-25s Writing %5zu: %s\n", "[SerializeInput]", index, input->type().ascii().data());
 
-        if (RefPtr<Inspector::Protocol::Replay::ReplayInput> serializedInput = buildInspectorObjectForInput(*input, index))
-            m_inputs->addItem(serializedInput.release());
+        EncodedValue encodedInput;
+        if (!m_client.encodeInput(*input, encodedInput))
+            return;
+
+        RefPtr<Inspector::Protocol::Replay::ReplayInput> inputObject = Inspector::Protocol::Replay::ReplayInput::create()
+            .setType(input->type())
+            .setOffset(index)
+            .setData(encodedInput.asObject());
+
+        m_inputs->addItem(inputObject.release());
     }
 
     ReturnType returnValue() { return m_inputs.release(); }
 private:
+    ReplayClient& m_client;
     RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Replay::ReplayInput>> m_inputs;
 };
 
-static PassRefPtr<Inspector::Protocol::Replay::SessionSegment> buildInspectorObjectForSegment(PassRefPtr<ReplaySessionSegment> prpSegment)
+static PassRefPtr<Inspector::Protocol::Replay::SessionSegment> buildInspectorObjectForSegment(PassRefPtr<ReplaySessionSegment> prpSegment, ReplayClient& client)
 {
     RefPtr<ReplaySessionSegment> segment = prpSegment;
     RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Replay::ReplayInputQueue>> queuesObject = Inspector::Protocol::Array<Inspector::Protocol::Replay::ReplayInputQueue>::create();
 
     for (size_t i = 0; i < static_cast<size_t>(InputQueue::Count); i++) {
-        SerializeInputToJSONFunctor collector;
+        SerializeInputToJSONFunctor collector(client);
         InputQueue queue = static_cast<InputQueue>(i);
         RefPtr<FunctorInputCursor> functorCursor = FunctorInputCursor::create(segment);
         RefPtr<Inspector::Protocol::Array<Inspector::Protocol::Replay::ReplayInput>> queueInputs = functorCursor->forEachInputInQueue(queue, collector);
 
         RefPtr<Inspector::Protocol::Replay::ReplayInputQueue> queueObject = Inspector::Protocol::Replay::ReplayInputQueue::create()
             .setType(EncodingTraits<InputQueue>::encodeValue(queue).convertTo<String>())
             .setInputs(queueInputs);
 
         queuesObject->addItem(queueObject.release());
     }
@@ -511,16 +511,16 @@ void InspectorReplayAgent::getSessionData(ErrorString& errorString, Inspector::P
 }
 
 void InspectorReplayAgent::getSegmentData(ErrorString& errorString, Inspector::Protocol::Replay::SegmentIdentifier identifier, RefPtr<Inspector::Protocol::Replay::SessionSegment>& serializedObject)
 {
     RefPtr<ReplaySessionSegment> segment = findSegment(errorString, identifier);
     if (!segment) {
         errorString = ASCIILiteral("Couldn't find the specified segment.");
         return;
     }
 
-    serializedObject = buildInspectorObjectForSegment(segment);
+    serializedObject = buildInspectorObjectForSegment(segment, m_page.replayController().client());
 }
 
 } // namespace WebCore
 
 #endif // ENABLE(INSPECTOR) && ENABLE(WEB_REPLAY)
diff --git a/Source/WebCore/loader/EmptyClients.h b/Source/WebCore/loader/EmptyClients.h
index a1c0b80..616c3b0 100644
--- a/Source/WebCore/loader/EmptyClients.h
+++ b/Source/WebCore/loader/EmptyClients.h
@@ -610,20 +610,22 @@ public:
     virtual void hideHighlight() override { }
 };
 
 #if ENABLE(WEB_REPLAY)
 class EmptyReplayClient : public ReplayClient {
 public:
     EmptyReplayClient() { }
     virtual ~EmptyReplayClient() { }
 
     virtual void dispatchInput(EventLoopInputBase&) override { }
+    virtual bool encodeInput(const JSC::NondeterministicInputBase&, JSC::EncodedValue&) override { return false; }
+    virtual bool decodeInput(JSC::EncodedValue&, std::unique_ptr<JSC::NondeterministicInputBase>&) override { return false; }
 };
 #endif // ENABLE(WEB_REPLAY)
 
 class EmptyDeviceClient : public DeviceClient {
 public:
     virtual void startUpdating() override { }
     virtual void stopUpdating() override { }
 };
 
 class EmptyDeviceMotionClient : public DeviceMotionClient {
diff --git a/Source/WebCore/replay/AllReplayInputs.h b/Source/WebCore/replay/AllReplayInputs.h
deleted file mode 100644
index 669bc25..0000000
--- a/Source/WebCore/replay/AllReplayInputs.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2013 University of Washington. All rights reserved.
- * Copyright (C) 2014 Apple Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer.
- * 2.  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-// This file is the include equivalent for WEB_REPLAY_INPUT_NAMES_FOR_EACH.
-// Note that there is not an exact correspondence between the two, since
-// Some input types reside in the same file.
-
-#ifndef AllReplayInputs_h
-#define AllReplayInputs_h
-
-#if ENABLE(WEB_REPLAY)
-
-#include "MemoizedDOMResult.h"
-#include "WebReplayInputs.h"
-#include <JavaScriptCore/JSReplayInputs.h>
-
-#define IMPORT_FROM_JSC_NAMESPACE(name) \
-using JSC::name; \
-
-JS_REPLAY_INPUT_NAMES_FOR_EACH(IMPORT_FROM_JSC_NAMESPACE)
-
-#endif // ENABLE(WEB_REPLAY)
-
-#endif // AllReplayInputs_h
diff --git a/Source/WebCore/replay/CapturingInputCursor.cpp b/Source/WebCore/replay/CapturingInputCursor.cpp
index 73b402f..731842e 100644
--- a/Source/WebCore/replay/CapturingInputCursor.cpp
+++ b/Source/WebCore/replay/CapturingInputCursor.cpp
@@ -25,53 +25,86 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "CapturingInputCursor.h"
 
 #if ENABLE(WEB_REPLAY)
 
 #include "EventLoopInput.h"
 #include "Logging.h"
+#include "Page.h"
+#include "ReplayController.h"
+#include "ReplayCLient.h"
 #include "ReplaySessionSegment.h"
 #include "SegmentedInputStorage.h"
+#include <replay/EncodedValue.h>
 #include <wtf/CurrentTime.h>
+#include <wtf/text/CString.h>
+
+#if !LOG_DISABLED
+// This is used to make the log spew from LOG(WebReplay, ...) more readable.
+static const char* queueTypeToLogPrefix(InputQueue queue)
+{
+    switch (queue) {
+    case InputQueue::EventLoopInput: return ">DSPTCH-STORE";
+    case InputQueue::LoaderMemoizedData: return "<LDMEMO-STORE";
+    case InputQueue::ScriptMemoizedData: return "<---<---<---JSMEMO-STORE";
+    case InputQueue::Count: return "ERROR!";
+    }
+}
+#endif // !LOG_DISABLED
 
 namespace WebCore {
 
-CapturingInputCursor::CapturingInputCursor(PassRefPtr<ReplaySessionSegment> segment)
+CapturingInputCursor::CapturingInputCursor(PassRefPtr<ReplaySessionSegment> segment, Page& page)
     : m_segment(segment)
+    , m_page(page)
 {
     LOG(WebReplay, "%-30sCreated capture cursor=%p.\n", "[ReplayController]", this);
 }
 
 CapturingInputCursor::~CapturingInputCursor()
 {
     LOG(WebReplay, "%-30sDestroyed capture cursor=%p.\n", "[ReplayController]", this);
 }
 
-PassRefPtr<CapturingInputCursor> CapturingInputCursor::create(PassRefPtr<ReplaySessionSegment> segment)
+PassRefPtr<CapturingInputCursor> CapturingInputCursor::create(PassRefPtr<ReplaySessionSegment> segment, Page& page)
 {
-    return adoptRef(new CapturingInputCursor(segment));
+    return adoptRef(new CapturingInputCursor(segment, page));
 }
 
 void CapturingInputCursor::storeInput(std::unique_ptr<NondeterministicInputBase> input)
 {
     ASSERT_ARG(input, input);
 
     if (input->queue() == InputQueue::EventLoopInput) {
         // FIXME: rewrite this (and related dispatch code) to use std::chrono.
         double now = monotonicallyIncreasingTime();
         m_segment->eventLoopTimings().append(now);
     }
 
-    m_segment->storage().store(WTF::move(input));
+    InputQueue queue = input->queue();
+    const AtomicString& type = input->type();
+    EncodedValue encodedInput;
+    m_page.replayController().client().encodeInput(*input, encodedInput);
+
+    size_t inputCount = m_segment->storage().store(WTF::move(input));
+
+#if !LOG_DISABLED
+    LOG(WebReplay, "%-14s#%-5zu %s: %s %s\n", "ReplayEvents", inputCount, queueTypeToLogPrefix(queue), type.string().utf8().data(), encodedInput.asObject()->toJSONString().utf8().data());
+#else
+    UNUSED_PARAM(queue);
+    UNUSED_PARAM(type);
+    UNUSED_PARAM(encodedInput);
+    UNUSED_PARAM(inputCount);
+#endif
 }
 
 NondeterministicInputBase* CapturingInputCursor::loadInput(InputQueue, const AtomicString&)
 {
     // Can't load inputs from capturing cursor.
     ASSERT_NOT_REACHED();
     return nullptr;
 }
 
 NondeterministicInputBase* CapturingInputCursor::uncheckedLoadInput(InputQueue)
diff --git a/Source/WebCore/replay/CapturingInputCursor.h b/Source/WebCore/replay/CapturingInputCursor.h
index ec25c84..31f3061 100644
--- a/Source/WebCore/replay/CapturingInputCursor.h
+++ b/Source/WebCore/replay/CapturingInputCursor.h
@@ -35,33 +35,34 @@
 
 namespace WebCore {
 
 class EventLoopInputExtent;
 class Page;
 class ReplaySessionSegment;
 
 class CapturingInputCursor final : public InputCursor {
     WTF_MAKE_NONCOPYABLE(CapturingInputCursor);
 public:
-    static PassRefPtr<CapturingInputCursor> create(PassRefPtr<ReplaySessionSegment>);
+    static PassRefPtr<CapturingInputCursor> create(PassRefPtr<ReplaySessionSegment>, Page&);
     virtual ~CapturingInputCursor();
 
     virtual bool isCapturing() const override { return true; }
     virtual bool isReplaying() const override { return false; }
 
 protected:
     virtual NondeterministicInputBase* loadInput(InputQueue, const AtomicString& type) override;
 
 private:
-    CapturingInputCursor(PassRefPtr<ReplaySessionSegment>);
+    CapturingInputCursor(PassRefPtr<ReplaySessionSegment>, Page&);
 
     virtual NondeterministicInputBase* uncheckedLoadInput(InputQueue) override;
     virtual void storeInput(std::unique_ptr<NondeterministicInputBase>) override;
 
     RefPtr<ReplaySessionSegment> m_segment;
+    Page& m_page;
 };
 
 } // namespace WebCore
 
 #endif // ENABLE(WEB_REPLAY)
 
 #endif // CapturingInputCursor_h
diff --git a/Source/WebCore/replay/EventLoopInputDispatcher.cpp b/Source/WebCore/replay/EventLoopInputDispatcher.cpp
index 0a1c23d..0c835b6 100644
--- a/Source/WebCore/replay/EventLoopInputDispatcher.cpp
+++ b/Source/WebCore/replay/EventLoopInputDispatcher.cpp
@@ -132,25 +132,25 @@ void EventLoopInputDispatcher::dispatchInput()
 {
     ASSERT(m_currentWork.input);
     ASSERT(!m_dispatching);
 
     if (m_speed == DispatchSpeed::RealTime) {
         m_previousDispatchStartTime = monotonicallyIncreasingTime();
         m_previousInputTimestamp = m_currentWork.timestamp;
     }
 
 #if !LOG_DISABLED
-    EncodedValue encodedInput = EncodingTraits<NondeterministicInputBase>::encodeValue(*m_currentWork.input);
-    String jsonString = encodedInput.asObject()->toJSONString();
-
-    LOG(WebReplay, "%-20s ----------------------------------------------", "ReplayEvents");
-    LOG(WebReplay, "%-20s >DISPATCH: %s %s\n", "ReplayEvents", m_currentWork.input->type().utf8().data(), jsonString.utf8().data());
+    EncodedValue encodedInput;
+    if (m_page.replayController().client().encodeInput(*m_currentWork.input, encodedInput)) {
+        LOG(WebReplay, "%-20s ----------------------------------------------", "ReplayEvents");
+        LOG(WebReplay, "%-20s >DISPATCH: %s %s\n", "ReplayEvents", m_currentWork.input->type().utf8().data(), encodedInput.asObject()->toJSONString().utf8().data());
+    }
 #endif
 
     m_client->willDispatchInput(*m_currentWork.input);
     // Client could stop replay in the previous callback, so check again.
     if (!m_running)
         return;
 
     {
         TemporaryChange<bool> change(m_dispatching, true);
         m_page.replayController().client().dispatchInput(*m_currentWork.input);
diff --git a/Source/WebCore/replay/ReplayClient.h b/Source/WebCore/replay/ReplayClient.h
index 509e6a1..70a79b1 100644
--- a/Source/WebCore/replay/ReplayClient.h
+++ b/Source/WebCore/replay/ReplayClient.h
@@ -21,26 +21,34 @@
  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef ReplayClient_h
 #define ReplayClient_h
 
 #if ENABLE(WEB_REPLAY)
 
+namespace JSC {
+class EncodedValue;
+class NondeterministicInputBase;
+}
+
 namespace WebCore {
 
 class EventLoopInputBase;
 
 class ReplayClient {
 public:
     virtual ~ReplayClient() { }
 
     virtual void dispatchInput(EventLoopInputBase&) = 0;
+
+    virtual bool encodeInput(const JSC::NondeterministicInputBase&, JSC::EncodedValue&) = 0;
+    virtual bool decodeInput(JSC::EncodedValue&, std::unique_ptr<JSC::NondeterministicInputBase>&) = 0;
 };
 
 } // namespace WebCore
 
 #endif // ENABLE(WEB_REPLAY)
 
 #endif // !defined(ReplayClient_h)
diff --git a/Source/WebCore/replay/ReplayController.cpp b/Source/WebCore/replay/ReplayController.cpp
index a3560c1..297ad54 100644
--- a/Source/WebCore/replay/ReplayController.cpp
+++ b/Source/WebCore/replay/ReplayController.cpp
@@ -23,21 +23,20 @@
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "ReplayController.h"
 
 #if ENABLE(WEB_REPLAY)
 
-#include "AllReplayInputs.h"
 #include "CapturingInputCursor.h"
 #include "DOMWindow.h"
 #include "DocumentLoader.h"
 #include "Frame.h"
 #include "FrameTree.h"
 #include "InspectorInstrumentation.h"
 #include "Location.h"
 #include "Logging.h"
 #include "MainFrame.h"
 #include "Page.h"
@@ -223,21 +222,21 @@ void ReplayController::createSegment()
     setSegmentState(SegmentState::Appending);
 
     // Create a new segment but don't associate it with the current session
     // until we stop appending to it. This preserves the invariant that
     // segments associated with a replay session have immutable data.
     m_loadedSegment = ReplaySessionSegment::create();
 
     LOG(WebReplay, "%-20s Created segment: %p.\n", "ReplayController", m_loadedSegment.get());
     InspectorInstrumentation::segmentCreated(&m_page, m_loadedSegment);
 
-    m_activeCursor = CapturingInputCursor::create(m_loadedSegment);
+    m_activeCursor = CapturingInputCursor::create(m_loadedSegment, m_page);
     m_activeCursor->appendInput<BeginSegmentSentinel>();
 
     // Dispatching this input saves history, clears all but the current item, appends saved
     // history item to the back/forward list, then moves the current item cursor to the last entry.
     std::unique_ptr<InitializeHistory> historyInput = InitializeHistory::createFromPage(m_page);
     m_client.dispatchInput(*historyInput);
     m_activeCursor->storeInput(WTF::move(historyInput));
 
     // Dispatching this input schedules navigation of the main frame, causing a refresh.
     std::unique_ptr<InitialNavigation> navigationInput = InitialNavigation::createFromPage(m_page);
diff --git a/Source/WebCore/replay/ReplayingInputCursor.cpp b/Source/WebCore/replay/ReplayingInputCursor.cpp
index ae6aa7a..e3aa7d8 100644
--- a/Source/WebCore/replay/ReplayingInputCursor.cpp
+++ b/Source/WebCore/replay/ReplayingInputCursor.cpp
@@ -24,30 +24,48 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "ReplayingInputCursor.h"
 
 #if ENABLE(WEB_REPLAY)
 
 #include "EventLoopInputDispatcher.h"
+#include "Logging.h"
+#include "Page.h"
+#include "ReplayClient.h"
+#include "ReplayController.h"
 #include "ReplaySessionSegment.h"
 #include "SegmentedInputStorage.h"
 #include "WebReplayInputCoders.h"
 #include "WebReplayInputs.h"
 #include <wtf/text/CString.h>
 
 namespace WebCore {
 
+#if !LOG_DISABLED
+// This is used to make the log spew from LOG(WebReplay, ...) more readable.
+static const char* queueTypeToLogPrefix(InputQueue queue)
+{
+    switch (queue) {
+    case InputQueue::EventLoopInput: return "(DSPTCH-LOAD)";
+    case InputQueue::LoaderMemoizedData: return "<LDMEMO-LOAD";
+    case InputQueue::ScriptMemoizedData: return "<---<---<---JSMEMO-LOAD";
+    case InputQueue::Count: return "ERROR!";
+    }
+}
+#endif // !LOG_DISABLED
+
 ReplayingInputCursor::ReplayingInputCursor(PassRefPtr<ReplaySessionSegment> segment, Page& page, EventLoopInputDispatcherClient* client)
     : m_segment(segment)
+    , m_page(page)
     , m_dispatcher(std::make_unique<EventLoopInputDispatcher>(page, *this, client))
 {
     for (size_t i = 0; i < static_cast<size_t>(InputQueue::Count); i++)
         m_positions.append(0);
 }
 
 ReplayingInputCursor::~ReplayingInputCursor()
 {
 }
 
@@ -75,21 +93,29 @@ NondeterministicInputBase* ReplayingInputCursor::loadInput(InputQueue queue, con
 }
 
 NondeterministicInputBase* ReplayingInputCursor::uncheckedLoadInput(InputQueue queue)
 {
     if (m_positions[static_cast<size_t>(queue)] >= m_segment->storage().queueSize(queue)) {
         String queueString = EncodingTraits<InputQueue>::encodeValue(queue).convertTo<String>();
         LOG_ERROR("%-30s ERROR No more inputs remain for determinism queue %s, but one was requested.", "[ReplayingInputCursor]", queueString.ascii().data());
         return nullptr;
     }
 
-    return m_segment->storage().load(queue, m_positions[static_cast<size_t>(queue)]++);
+    NondeterministicInputBase* input = m_segment->storage().load(queue, m_positions[static_cast<size_t>(queue)]++);
+    if (!input)
+        return nullptr;
+    
+    EncodedValue encodedInput;
+    m_page.replayController().client().encodeInput(*input, encodedInput);
+    LOG(WebReplay, "%-20s %s: %s %s\n", "ReplayEvents", queueTypeToLogPrefix(queue), input->type().string().utf8().data(), encodedInput.asObject()->toJSONString().utf8().data());
+
+    return input;
 }
 
 EventLoopInputData ReplayingInputCursor::loadEventLoopInput()
 {
     ASSERT(m_segment);
 
     size_t offset = m_positions.at(static_cast<size_t>(InputQueue::EventLoopInput));
     ASSERT(offset < m_segment->eventLoopTimings().size());
 
     EventLoopInputData data;
diff --git a/Source/WebCore/replay/ReplayingInputCursor.h b/Source/WebCore/replay/ReplayingInputCursor.h
index f379066..5d1cddf 100644
--- a/Source/WebCore/replay/ReplayingInputCursor.h
+++ b/Source/WebCore/replay/ReplayingInputCursor.h
@@ -57,19 +57,20 @@ public:
     EventLoopInputData loadEventLoopInput();
 protected:
     virtual NondeterministicInputBase* loadInput(InputQueue, const AtomicString& type) override;
 private:
     ReplayingInputCursor(PassRefPtr<ReplaySessionSegment>, Page&, EventLoopInputDispatcherClient*);
 
     virtual void storeInput(std::unique_ptr<NondeterministicInputBase>) override;
     virtual NondeterministicInputBase* uncheckedLoadInput(InputQueue) override;
 
     RefPtr<ReplaySessionSegment> m_segment;
+    Page& m_page;
     std::unique_ptr<EventLoopInputDispatcher> m_dispatcher;
     Vector<size_t> m_positions;
 };
 
 } // namespace WebCore
 
 #endif // ENABLE(WEB_REPLAY)
 
 #endif // ReplayingInputCursor_h
diff --git a/Source/WebCore/replay/SegmentedInputStorage.cpp b/Source/WebCore/replay/SegmentedInputStorage.cpp
index b9e9c7b..acc8a8a 100644
--- a/Source/WebCore/replay/SegmentedInputStorage.cpp
+++ b/Source/WebCore/replay/SegmentedInputStorage.cpp
@@ -23,58 +23,22 @@
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "SegmentedInputStorage.h"
 
 #if ENABLE(WEB_REPLAY)
 
-#if !LOG_DISABLED
-#include "Logging.h"
-#include "WebReplayInputCoders.h"
-#include <replay/EncodedValue.h>
-#include <wtf/text/CString.h>
-#include <wtf/text/WTFString.h>
-#endif
-
 namespace WebCore {
 
-#if !LOG_DISABLED
-// These are used to make the log spew from LOG(WebReplay, ...) more readable.
-static const char* queueTypeToLogPrefix(InputQueue inputQueue, bool isLoad)
-{
-    if (isLoad) {
-        switch (inputQueue) {
-        case InputQueue::EventLoopInput: return "(DSPTCH-LOAD)";
-        case InputQueue::LoaderMemoizedData: return "<LDMEMO-LOAD";
-        case InputQueue::ScriptMemoizedData: return "<---<---<---JSMEMO-LOAD";
-        case InputQueue::Count: return "ERROR!";
-        }
-    } else {
-        switch (inputQueue) {
-        case InputQueue::EventLoopInput: return ">DSPTCH-STORE";
-        case InputQueue::LoaderMemoizedData: return "<LDMEMO-STORE";
-        case InputQueue::ScriptMemoizedData: return "<---<---<---JSMEMO-STORE";
-        case InputQueue::Count: return "ERROR!";
-        }
-    }
-}
-
-static String jsonStringForInput(const NondeterministicInputBase& input)
-{
-    EncodedValue encodedValue = EncodingTraits<NondeterministicInputBase>::encodeValue(input);
-    return encodedValue.asObject()->toJSONString();
-}
-#endif // !LOG_DISABLED
-
 static size_t offsetForInputQueue(InputQueue inputQueue)
 {
     return static_cast<size_t>(inputQueue);
 }
 
 SegmentedInputStorage::SegmentedInputStorage()
     : m_inputCount(0)
 {
     for (size_t i = 0; i < offsetForInputQueue(InputQueue::Count); i++)
         m_queues.append(new QueuedInputs);
@@ -86,33 +50,30 @@ SegmentedInputStorage::~SegmentedInputStorage()
         delete m_queues.at(i);
 }
 
 NondeterministicInputBase* SegmentedInputStorage::load(InputQueue inputQueue, size_t offset)
 {
     ASSERT(offset < queueSize(inputQueue));
 
     NondeterministicInputBase* input = queue(inputQueue).at(offset).get();
     ASSERT(input);
 
-    LOG(WebReplay, "%-20s %s: %s %s\n", "ReplayEvents", queueTypeToLogPrefix(inputQueue, true), input->type().utf8().data(), jsonStringForInput(*input).utf8().data());
-
     return input;
 }
 
-void SegmentedInputStorage::store(std::unique_ptr<NondeterministicInputBase> input)
+size_t SegmentedInputStorage::store(std::unique_ptr<NondeterministicInputBase> input)
 {
     ASSERT(input);
     ASSERT(input->queue() < InputQueue::Count);
 
-    LOG(WebReplay, "%-14s#%-5u %s: %s %s\n", "ReplayEvents", m_inputCount++, queueTypeToLogPrefix(input->queue(), false), input->type().utf8().data(), jsonStringForInput(*input).utf8().data());
-
     m_queues.at(offsetForInputQueue(input->queue()))->append(WTF::move(input));
+    return m_inputCount++;
 }
 
 size_t SegmentedInputStorage::queueSize(InputQueue inputQueue) const
 {
     return queue(inputQueue).size();
 }
 
 const SegmentedInputStorage::QueuedInputs& SegmentedInputStorage::queue(InputQueue queue) const
 {
     ASSERT(queue < InputQueue::Count);
diff --git a/Source/WebCore/replay/SegmentedInputStorage.h b/Source/WebCore/replay/SegmentedInputStorage.h
index b87211b..7316512 100644
--- a/Source/WebCore/replay/SegmentedInputStorage.h
+++ b/Source/WebCore/replay/SegmentedInputStorage.h
@@ -37,21 +37,21 @@
 namespace WebCore {
 
 class SegmentedInputStorage {
     WTF_MAKE_NONCOPYABLE(SegmentedInputStorage);
     friend class FunctorInputCursor;
 public:
     SegmentedInputStorage();
     ~SegmentedInputStorage();
 
     NondeterministicInputBase* load(InputQueue, size_t);
-    void store(std::unique_ptr<NondeterministicInputBase>);
+    size_t store(std::unique_ptr<NondeterministicInputBase>);
     size_t queueSize(InputQueue) const;
 
 private:
     typedef Vector<std::unique_ptr<NondeterministicInputBase>> QueuedInputs;
     const QueuedInputs& queue(InputQueue) const;
 
     Vector<QueuedInputs*, 3> m_queues;
     unsigned m_inputCount;
 };
 
diff --git a/Source/WebCore/replay/WebReplayInputCoders.cpp b/Source/WebCore/replay/WebReplayInputCoders.cpp
index 853c4dd..93a32a3 100644
--- a/Source/WebCore/replay/WebReplayInputCoders.cpp
+++ b/Source/WebCore/replay/WebReplayInputCoders.cpp
@@ -23,44 +23,46 @@
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "WebReplayInputCoders.h"
 
 #if ENABLE(WEB_REPLAY)
 
-#include "AllReplayInputs.h"
 #include "Document.h"
 #include "FormData.h"
 #include "Frame.h"
 #include "FrameLoadRequest.h"
 #include "FrameTree.h"
 #include "HTTPHeaderMap.h"
 #include "HistoryItem.h"
 #include "MainFrame.h"
+#include "MemoizedDOMResult.h"
 #include "Page.h"
 #include "PlatformKeyboardEvent.h"
 #include "PlatformMouseEvent.h"
 #include "PlatformWheelEvent.h"
 #include "PluginData.h"
 #include "ReplayInputTypes.h"
 #include "ResourceError.h"
 #include "ResourceLoadTiming.h"
 #include "ResourceRequest.h"
 #include "ResourceResponse.h"
 #include "SecurityOrigin.h"
 #include "SerializedScriptValue.h"
 #include "SharedBuffer.h"
 #include "SubstituteData.h"
 #include "URL.h"
+#include "WebReplayInputs.h"
+#include <JavaScriptCore/JSReplayInputs.h>
 #include <wtf/text/Base64.h>
 
 using WebCore::FormData;
 using WebCore::FormDataElement;
 using WebCore::FrameLoadRequest;
 using WebCore::HTTPHeaderMap;
 using WebCore::HistoryItem;
 using WebCore::IntPoint;
 using WebCore::MimeClassInfo;
 using WebCore::MouseButton;
@@ -329,45 +331,20 @@ bool EncodingTraits<MimeClassInfo>::decodeValue(EncodedValue& encodedData, MimeC
     MimeClassInfo info;
 
     DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, String, type, info.type);
     DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, String, desc, info.desc);
     DECODE_TYPE_WITH_KEY_TO_LVALUE(encodedData, Vector<String>, extensions, info.extensions);
 
     input = info;
     return true;
 }
 
-EncodedValue EncodingTraits<NondeterministicInputBase>::encodeValue(const NondeterministicInputBase& input)
-{
-    EncodedValue encodedValue = EncodedValue::createObject();
-    ENCODE_TYPE_WITH_KEY(encodedValue, String, type, input.type());
-
-#define ENCODE_IF_TYPE_TAG_MATCHES(name) \
-    if (input.type() == InputTraits<name>::type()) { \
-        InputTraits<name>::encode(encodedValue, static_cast<const name&>(input)); \
-        return encodedValue; \
-    } \
-
-    JS_REPLAY_INPUT_NAMES_FOR_EACH(ENCODE_IF_TYPE_TAG_MATCHES)
-    WEB_REPLAY_INPUT_NAMES_FOR_EACH(ENCODE_IF_TYPE_TAG_MATCHES)
-#undef ENCODE_IF_TYPE_TAG_MATCHES
-
-    // The macro won't work here because of the class template argument.
-    if (input.type() == InputTraits<MemoizedDOMResultBase>::type()) {
-        InputTraits<MemoizedDOMResultBase>::encode(encodedValue, static_cast<const MemoizedDOMResultBase&>(input));
-        return encodedValue;
-    }
-
-    ASSERT_NOT_REACHED();
-    return EncodedValue();
-}
-
 EncodedValue EncodingTraits<HistoryItem>::encodeValue(RefPtr<HistoryItem> item)
 {
     EncodedValue encodedValue = EncodedValue::createObject();
 
     ENCODE_TYPE_WITH_KEY(encodedValue, String, originalURLString, item->originalURLString());
     ENCODE_TYPE_WITH_KEY(encodedValue, String, urlString, item->urlString());
     ENCODE_TYPE_WITH_KEY(encodedValue, String, title, item->title());
     ENCODE_TYPE_WITH_KEY(encodedValue, String, parent, item->parent());
     ENCODE_TYPE_WITH_KEY(encodedValue, int64_t, documentSequenceNumber, item->documentSequenceNumber());
     ENCODE_TYPE_WITH_KEY(encodedValue, Vector<String>, documentState, item->documentState());
@@ -442,50 +419,20 @@ bool EncodingTraits<IntPoint>::decodeValue(EncodedValue& encodedData, IntPoint&
 {
     IntPoint decodedPoint;
 
     DECODE_TYPE_WITH_KEY(encodedData, int, x);
     DECODE_TYPE_WITH_KEY(encodedData, int, y);
 
     point = IntPoint(x, y);
     return true;
 }
 
-bool EncodingTraits<NondeterministicInputBase>::decodeValue(EncodedValue& encodedValue, std::unique_ptr<NondeterministicInputBase>& input)
-{
-    DECODE_TYPE_WITH_KEY(encodedValue, String, type);
-
-#define DECODE_IF_TYPE_TAG_MATCHES(name) \
-    if (type == InputTraits<name>::type()) { \
-        std::unique_ptr<name> decodedInput; \
-        if (!InputTraits<name>::decode(encodedValue, decodedInput)) \
-            return false; \
-        \
-        input = WTF::move(decodedInput); \
-        return true; \
-    } \
-
-    JS_REPLAY_INPUT_NAMES_FOR_EACH(DECODE_IF_TYPE_TAG_MATCHES)
-    WEB_REPLAY_INPUT_NAMES_FOR_EACH(DECODE_IF_TYPE_TAG_MATCHES)
-#undef DECODE_IF_TYPE_TAG_MATCHES
-
-    if (type == InputTraits<MemoizedDOMResultBase>::type()) {
-        std::unique_ptr<MemoizedDOMResultBase> decodedInput;
-        if (!InputTraits<MemoizedDOMResultBase>::decode(encodedValue, decodedInput))
-            return false;
-
-        input = WTF::move(decodedInput);
-        return true;
-    }
-
-    return false;
-}
-
 #if USE(APPKIT)
 EncodedValue EncodingTraits<KeypressCommand>::encodeValue(const KeypressCommand& command)
 {
     EncodedValue encodedValue = EncodedValue::createObject();
 
     ENCODE_TYPE_WITH_KEY(encodedValue, String, commandName, command.commandName);
     ENCODE_OPTIONAL_TYPE_WITH_KEY(encodedValue, String, text, command.text, !command.text.isEmpty());
 
     return encodedValue;
 }
diff --git a/Source/WebCore/replay/WebReplayInputCoders.h b/Source/WebCore/replay/WebReplayInputCoders.h
index 59f5cb6..a5d767f 100644
--- a/Source/WebCore/replay/WebReplayInputCoders.h
+++ b/Source/WebCore/replay/WebReplayInputCoders.h
@@ -100,27 +100,20 @@ template<> struct EncodingTraits<WebCore::KeypressCommand> {
 };
 #endif // USE(APPKIT)
 
 template<> struct EncodingTraits<WebCore::HistoryItem> {
     typedef RefPtr<WebCore::HistoryItem> DecodedType;
 
     static EncodedValue encodeValue(RefPtr<WebCore::HistoryItem>);
     static bool decodeValue(EncodedValue&, RefPtr<WebCore::HistoryItem>&);
 };
 
-template<> struct EncodingTraits<NondeterministicInputBase> {
-    typedef NondeterministicInputBase DecodedType;
-
-    static EncodedValue encodeValue(const NondeterministicInputBase& value);
-    static bool decodeValue(EncodedValue&, std::unique_ptr<NondeterministicInputBase>& value);
-};
-
 template<> struct EncodingTraits<WebCore::PlatformKeyboardEvent> {
     typedef WebCore::PlatformKeyboardEvent DecodedType;
 
     static EncodedValue encodeValue(const WebCore::PlatformKeyboardEvent& value);
     static bool decodeValue(EncodedValue&, std::unique_ptr<WebCore::PlatformKeyboardEvent>& value);
 };
 
 template<> struct EncodingTraits<WebCore::PlatformMouseEvent> {
     typedef WebCore::PlatformMouseEvent DecodedType;
 
diff --git a/Source/WebCore/replay/WebReplayInputDispatchMethods.cpp b/Source/WebCore/replay/WebReplayInputDispatchMethods.cpp
index ea452e6..7b5662c 100644
--- a/Source/WebCore/replay/WebReplayInputDispatchMethods.cpp
+++ b/Source/WebCore/replay/WebReplayInputDispatchMethods.cpp
@@ -21,37 +21,37 @@
  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 
 #if ENABLE(WEB_REPLAY)
 
-#include "AllReplayInputs.h"
 #include "BackForwardController.h"
 #include "DOMTimer.h"
 #include "Document.h"
 #include "DocumentLoader.h"
 #include "FrameLoadRequest.h"
 #include "FrameLoader.h"
 #include "HistoryController.h"
 #include "MainFrame.h"
 #include "NavigationScheduler.h"
 #include "Page.h"
 #include "ReplayController.h"
 #include "ReplayableTimers.h"
 #include "ResourceError.h"
 #include "ResourceLoader.h"
 #include "ResourceRequest.h"
 #include "WebReplayInputCoders.h"
+#include "WebReplayInputs.h"
 #include "URL.h"
 #include "UserInputBridge.h"
 #include <cinttypes>
 
 namespace WebCore {
 
 static ResourceLoader* resourceLoaderForOrdinal(Page& page, unsigned long ordinal, int frameIndex)
 {
     Frame* frame = frameFromFrameIndex(&page, frameIndex);
     ASSERT(frame);
diff --git a/Source/WebKit2/CMakeLists.txt b/Source/WebKit2/CMakeLists.txt
index f1c191b..31f73a9 100644
--- a/Source/WebKit2/CMakeLists.txt
+++ b/Source/WebKit2/CMakeLists.txt
@@ -752,19 +752,20 @@ if (ENABLE_WEB_REPLAY)
 =======
     set(WebKit2_WEB_REPLAY_INPUTS ${WEBKIT2_DIR}/WebProcess/Replay/WebInputs.json)
     add_custom_command(
         OUTPUT ${DERIVED_SOURCES_WEBKIT2_DIR}/WKReplayInputs.h ${DERIVED_SOURCES_WEBKIT2_DIR}/WKReplayInputs.cpp
         MAIN_DEPENDENCY ${JAVASCRIPTCORE_DIR}/replay/scripts/CodeGeneratorReplayInputs.py
         DEPENDS ${WebKit2_WEB_REPLAY_INPUTS}
         COMMAND ${PYTHON_EXECUTABLE} ${JAVASCRIPTCORE_DIR}/replay/scripts/CodeGeneratorReplayInputs.py --outputDir ${DERIVED_SOURCES_WEBKIT2_DIR}/ --framework WebKit ${WebKit2_WEB_REPLAY_INPUTS}
         VERBATIM)
 
     list(APPEND WebKit2_SOURCES
+        WebProcess/Replay/WKReplayInputCoders.cpp
         ${DERIVED_SOURCES_WEBKIT2_DIR}/WKReplayInputs.cpp
     )
 endif ()
 
 POPULATE_LIBRARY_VERSION(WEBKIT2)
 set_target_properties(WebKit2 PROPERTIES VERSION ${WEBKIT2_VERSION} SOVERSION ${WEBKIT2_VERSION_MAJOR})
 
 install(TARGETS WebKit2 DESTINATION "${LIB_INSTALL_DIR}")
 install(TARGETS WebProcess DESTINATION "${LIBEXEC_INSTALL_DIR}")
diff --git a/Source/WebKit2/ChangeLog b/Source/WebKit2/ChangeLog
index 2531e36..638dda4 100644
--- a/Source/WebKit2/ChangeLog
+++ b/Source/WebKit2/ChangeLog
@@ -1,10 +1,33 @@
+2014-08-20  Brian J. Burg  <burg@cs.washington.edu>
+
+        Web Replay: Encode replay inputs through ReplayClient
+        Need the bug URL (OOPS!).
+
+        Reviewed by NOBODY (OOPS!).
+
+        Only WebKit2 can access all possible replay inputs, so it should contain
+        the big function with cases to encode each input based on its type tag.
+
+        Move some logging code out of SegmentedInputStorage so that inputs can be encoded
+        through ReplayClient and then displayed in the serialized JSON representation.
+
+        No new tests, no behavior was changed.
+
+        * CMakeLists.txt:
+        * WebKit2.xcodeproj/project.pbxproj:
+        * WebProcess/Replay/WKReplayInputCoders.cpp: Added.
+        * WebProcess/Replay/WKReplayInputCoders.h: Added.
+        * WebProcess/WebCoreSupport/WebReplayClient.cpp:
+        (WebKit::WebReplayClient::encodeInput):
+        * WebProcess/WebCoreSupport/WebReplayClient.h:
+
 2014-07-15  Brian J. Burg  <burg@cs.washington.edu>
 
         Web Replay: save and restore page history state at main frame navigations
         https://bugs.webkit.org/show_bug.cgi?id=131043
 
         Reviewed by NOBODY (OOPS!).
 
         Promote clear() to be part of the BackForwardClient interface.
 
         * WebProcess/WebPage/WebBackForwardListProxy.h:
diff --git a/Source/WebKit2/WebKit2.xcodeproj/project.pbxproj b/Source/WebKit2/WebKit2.xcodeproj/project.pbxproj
index 7766f75..adef8bf 100644
--- a/Source/WebKit2/WebKit2.xcodeproj/project.pbxproj
+++ b/Source/WebKit2/WebKit2.xcodeproj/project.pbxproj
@@ -1549,20 +1549,22 @@
 		C0CE72A01247E71D00BC0EC4 /* WebPageMessageReceiver.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C0CE729E1247E71D00BC0EC4 /* WebPageMessageReceiver.cpp */; };
 		C0CE72A11247E71D00BC0EC4 /* WebPageMessages.h in Headers */ = {isa = PBXBuildFile; fileRef = C0CE729F1247E71D00BC0EC4 /* WebPageMessages.h */; };
 		C0CE72AD1247E78D00BC0EC4 /* HandleMessage.h in Headers */ = {isa = PBXBuildFile; fileRef = C0CE72AC1247E78D00BC0EC4 /* HandleMessage.h */; };
 		C0E3AA7A1209E83000A49D01 /* ModuleCF.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C0E3AA481209E45000A49D01 /* ModuleCF.cpp */; };
 		C0E3AA7B1209E83500A49D01 /* Module.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C0E3AA451209E2BA00A49D01 /* Module.cpp */; };
 		C0E3AA7C1209E83C00A49D01 /* Module.h in Headers */ = {isa = PBXBuildFile; fileRef = C0E3AA441209E2BA00A49D01 /* Module.h */; };
 		C49474B019A3F93F009B3DE8 /* WebReplayClient.h in Headers */ = {isa = PBXBuildFile; fileRef = C49474AE19A3F924009B3DE8 /* WebReplayClient.h */; };
 		C49474B119A3F947009B3DE8 /* WebReplayClient.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C49474AD19A3F924009B3DE8 /* WebReplayClient.cpp */; };
 		C49474B719A41B73009B3DE8 /* WKReplayInputs.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C49474B519A41B73009B3DE8 /* WKReplayInputs.cpp */; };
 		C49474B819A41B73009B3DE8 /* WKReplayInputs.h in Headers */ = {isa = PBXBuildFile; fileRef = C49474B619A41B73009B3DE8 /* WKReplayInputs.h */; };
+		C49474BB19A5413F009B3DE8 /* WKReplayInputCoders.cpp in Sources */ = {isa = PBXBuildFile; fileRef = C49474B919A5413F009B3DE8 /* WKReplayInputCoders.cpp */; };
+		C49474BC19A5413F009B3DE8 /* WKReplayInputCoders.h in Headers */ = {isa = PBXBuildFile; fileRef = C49474BA19A5413F009B3DE8 /* WKReplayInputCoders.h */; };
 		C517388112DF8F4F00EE3F47 /* DragControllerAction.h in Headers */ = {isa = PBXBuildFile; fileRef = C517388012DF8F4F00EE3F47 /* DragControllerAction.h */; };
 		C5237F6012441CA300780472 /* WebEditorClientMac.mm in Sources */ = {isa = PBXBuildFile; fileRef = C5237F5F12441CA300780472 /* WebEditorClientMac.mm */; };
 		C54256B518BEC18C00DE4179 /* WKFormInputControl.h in Headers */ = {isa = PBXBuildFile; fileRef = C54256AF18BEC18B00DE4179 /* WKFormInputControl.h */; };
 		C54256B618BEC18C00DE4179 /* WKFormInputControl.mm in Sources */ = {isa = PBXBuildFile; fileRef = C54256B018BEC18B00DE4179 /* WKFormInputControl.mm */; };
 		C54256B718BEC18C00DE4179 /* WKFormPeripheral.h in Headers */ = {isa = PBXBuildFile; fileRef = C54256B118BEC18B00DE4179 /* WKFormPeripheral.h */; };
 		C54256B818BEC18C00DE4179 /* WKFormPopover.h in Headers */ = {isa = PBXBuildFile; fileRef = C54256B218BEC18B00DE4179 /* WKFormPopover.h */; };
 		C54256B918BEC18C00DE4179 /* WKFormPopover.mm in Sources */ = {isa = PBXBuildFile; fileRef = C54256B318BEC18B00DE4179 /* WKFormPopover.mm */; };
 		C54256BA18BEC18C00DE4179 /* WKFormSelectControl.h in Headers */ = {isa = PBXBuildFile; fileRef = C54256B418BEC18C00DE4179 /* WKFormSelectControl.h */; };
 		C55CB5B718C269CF00CA81E1 /* WKFormSelectPopover.mm in Sources */ = {isa = PBXBuildFile; fileRef = C57193BA18C149D0002D0F12 /* WKFormSelectPopover.mm */; };
 		C55CB5B818C2A5D600CA81E1 /* WKFormSelectPicker.mm in Sources */ = {isa = PBXBuildFile; fileRef = C57193B918C149D0002D0F12 /* WKFormSelectPicker.mm */; };
@@ -3655,20 +3657,22 @@
 		C0CE73361247F70E00BC0EC4 /* generate-message-receiver.py */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.python; path = "generate-message-receiver.py"; sourceTree = "<group>"; };
 		C0CE73371247F70E00BC0EC4 /* generate-messages-header.py */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.python; path = "generate-messages-header.py"; sourceTree = "<group>"; };
 		C0E3AA441209E2BA00A49D01 /* Module.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Module.h; sourceTree = "<group>"; };
 		C0E3AA451209E2BA00A49D01 /* Module.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Module.cpp; sourceTree = "<group>"; };
 		C0E3AA481209E45000A49D01 /* ModuleCF.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ModuleCF.cpp; sourceTree = "<group>"; };
 		C49474AD19A3F924009B3DE8 /* WebReplayClient.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WebReplayClient.cpp; sourceTree = "<group>"; };
 		C49474AE19A3F924009B3DE8 /* WebReplayClient.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WebReplayClient.h; sourceTree = "<group>"; };
 		C49474B319A41246009B3DE8 /* WKInputs.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = WKInputs.json; sourceTree = "<group>"; };
 		C49474B519A41B73009B3DE8 /* WKReplayInputs.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WKReplayInputs.cpp; sourceTree = "<group>"; };
 		C49474B619A41B73009B3DE8 /* WKReplayInputs.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WKReplayInputs.h; sourceTree = "<group>"; };
+		C49474B919A5413F009B3DE8 /* WKReplayInputCoders.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WKReplayInputCoders.cpp; sourceTree = "<group>"; };
+		C49474BA19A5413F009B3DE8 /* WKReplayInputCoders.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WKReplayInputCoders.h; sourceTree = "<group>"; };
 		C517388012DF8F4F00EE3F47 /* DragControllerAction.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DragControllerAction.h; sourceTree = "<group>"; };
 		C5237F5F12441CA300780472 /* WebEditorClientMac.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; path = WebEditorClientMac.mm; sourceTree = "<group>"; };
 		C54256AF18BEC18B00DE4179 /* WKFormInputControl.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WKFormInputControl.h; path = ios/forms/WKFormInputControl.h; sourceTree = "<group>"; };
 		C54256B018BEC18B00DE4179 /* WKFormInputControl.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; name = WKFormInputControl.mm; path = ios/forms/WKFormInputControl.mm; sourceTree = "<group>"; };
 		C54256B118BEC18B00DE4179 /* WKFormPeripheral.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WKFormPeripheral.h; path = ios/forms/WKFormPeripheral.h; sourceTree = "<group>"; };
 		C54256B218BEC18B00DE4179 /* WKFormPopover.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WKFormPopover.h; path = ios/forms/WKFormPopover.h; sourceTree = "<group>"; };
 		C54256B318BEC18B00DE4179 /* WKFormPopover.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; name = WKFormPopover.mm; path = ios/forms/WKFormPopover.mm; sourceTree = "<group>"; };
 		C54256B418BEC18C00DE4179 /* WKFormSelectControl.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WKFormSelectControl.h; path = ios/forms/WKFormSelectControl.h; sourceTree = "<group>"; };
 		C554FFA212E4E8EA002F22C0 /* WebDragClientMac.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; path = WebDragClientMac.mm; sourceTree = "<group>"; };
 		C57193B918C149D0002D0F12 /* WKFormSelectPicker.mm */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.objcpp; name = WKFormSelectPicker.mm; path = ios/forms/WKFormSelectPicker.mm; sourceTree = "<group>"; };
@@ -6938,20 +6942,22 @@
 			);
 			path = Scripts;
 			sourceTree = "<group>";
 			tabWidth = 8;
 			usesTabs = 0;
 		};
 		C49474B219A4121A009B3DE8 /* Replay */ = {
 			isa = PBXGroup;
 			children = (
 				C49474B319A41246009B3DE8 /* WKInputs.json */,
+				C49474B919A5413F009B3DE8 /* WKReplayInputCoders.cpp */,
+				C49474BA19A5413F009B3DE8 /* WKReplayInputCoders.h */,
 			);
 			path = Replay;
 			sourceTree = "<group>";
 		};
 		C54256AE18BEC16100DE4179 /* forms */ = {
 			isa = PBXGroup;
 			children = (
 				C5FA1ED118E1062200B3F402 /* WKAirPlayRoutePicker.h */,
 				C5FA1ED218E1062200B3F402 /* WKAirPlayRoutePicker.mm */,
 				A58B6F0618FCA733008CBA53 /* WKFileUploadPanel.h */,
@@ -7822,20 +7828,21 @@
 				BCD597D0112B56AC00EC8C23 /* WKPreferencesRef.h in Headers */,
 				762B748D120BC75C00819339 /* WKPreferencesRefPrivate.h in Headers */,
 				37C4C08918149F23003688B9 /* WKBackForwardListItemInternal.h in Headers */,
 				51D0D437183B353D0097041D /* DatabaseProcessIDBConnectionMessages.h in Headers */,
 				BCBAACED145225E30053F82F /* WKProcessGroupPrivate.h in Headers */,
 				512F58FC12A88A5400629530 /* WKProtectionSpace.h in Headers */,
 				518ACAEA12AEE6BB00B04B83 /* WKProtectionSpaceTypes.h in Headers */,
 				37948409150C4B9700E52CE9 /* WKRenderLayer.h in Headers */,
 				37608823150414F700FC82C7 /* WKRenderObject.h in Headers */,
 				E13833EC189C33C8001E2350 /* LocalStorageDetails.h in Headers */,
+				C49474BC19A5413F009B3DE8 /* WKReplayInputCoders.h in Headers */,
 				3336763B130C99DC006C9DE2 /* WKResourceCacheManager.h in Headers */,
 				BC8A501511765F5600757573 /* WKRetainPtr.h in Headers */,
 				F634445D12A885E9000612D8 /* WKSecurityOrigin.h in Headers */,
 				1AAF08B819269E6D00B6390C /* WebUserContentControllerMessages.h in Headers */,
 				BC407604124FF0270068F20A /* WKSerializedScriptValue.h in Headers */,
 				1CBBE4A119B66C53006B7D81 /* WebInspectorUIMessages.h in Headers */,
 				0FCB4E4C18BBE044000FCFC9 /* WKContentView.h in Headers */,
 				37A64E5718F38F4600EB30F1 /* _WKFormInputSession.h in Headers */,
 				1F604BAA1889FBB800EE0395 /* WKRenderingProgressEventsInternal.h in Headers */,
 				1F7506B81859165D00EC0FF7 /* WKWebProcessPlugInFrameInternal.h in Headers */,
@@ -8828,20 +8835,21 @@
 				515E773318402D510007203F /* UniqueIDBDatabaseIdentifier.cpp in Sources */,
 				2DA049B7180CCD0A00AAFA9E /* GraphicsLayerCARemote.cpp in Sources */,
 				378E1A4D18208D700031007A /* WKNSURL.mm in Sources */,
 				515E772F184015800007203F /* UniqueIDBDatabase.cpp in Sources */,
 				2DA049B3180CCCD300AAFA9E /* PlatformCALayerRemote.cpp in Sources */,
 				CDC3831017212440008A2FC3 /* CookieStorageShim.mm in Sources */,
 				B878B616133428DC006888E9 /* CorrectionPanel.mm in Sources */,
 				2989A411167D1834004F96D2 /* CustomProtocolManagerCocoa.mm in Sources */,
 				2984F588164BA095004BC0C6 /* CustomProtocolManagerMessageReceiver.cpp in Sources */,
 				29AD3096164B4C930072DEA9 /* CustomProtocolManagerProxyMac.mm in Sources */,
+				C49474BB19A5413F009B3DE8 /* WKReplayInputCoders.cpp in Sources */,
 				0FF24A2D1879E4BC003ABF0C /* RemoteLayerTreeDrawingAreaProxyMessageReceiver.cpp in Sources */,
 				2984F57C164B915F004BC0C6 /* CustomProtocolManagerProxyMessageReceiver.cpp in Sources */,
 				BCE81D98131AE02100241910 /* DictionaryPopupInfo.cpp in Sources */,
 				5167EEA1170377BF007681CA /* NetworkDiskCacheMonitor.mm in Sources */,
 				2DAF06D718BD1A470081CEB1 /* SmartMagnificationController.mm in Sources */,
 				2D6CD11A189058A500E5A4A0 /* ViewSnapshotStore.mm in Sources */,
 				518E8F0716B2093700E91429 /* Download.cpp in Sources */,
 				2D47B56C1810714E003A3AEE /* RemoteLayerBackingStore.mm in Sources */,
 				518E8F0916B2093700E91429 /* DownloadAuthenticationClient.cpp in Sources */,
 				518E8F0D16B2093700E91429 /* DownloadMac.mm in Sources */,
diff --git a/Source/WebKit2/WebProcess/Replay/WKReplayInputCoders.cpp b/Source/WebKit2/WebProcess/Replay/WKReplayInputCoders.cpp
new file mode 100644
index 0000000..ffdac55
--- /dev/null
+++ b/Source/WebKit2/WebProcess/Replay/WKReplayInputCoders.cpp
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2012, 2014 University of Washington. All rights reserved.
+ * Copyright (C) 2014 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "WKReplayInputCoders.h"
+
+#if ENABLE(WEB_REPLAY)
+
+#include "WKReplayInputs.h"
+#include <JavaScriptCore/JSReplayInputs.h>
+#include <WebCore/MemoizedDOMResult.h>
+#include <WebCore/WebReplayInputs.h>
+
+#define IMPORT_FROM_JSC_NAMESPACE(name) \
+using JSC::name; \
+
+JS_REPLAY_INPUT_NAMES_FOR_EACH(IMPORT_FROM_JSC_NAMESPACE)
+#undef IMPORT_FROM_JSC_NAMESPACE
+
+#define IMPORT_FROM_WEBCORE_NAMESPACE(name) \
+using WebCore::name; \
+
+WEB_REPLAY_INPUT_NAMES_FOR_EACH(IMPORT_FROM_WEBCORE_NAMESPACE)
+#undef IMPORT_FROM_WEBCORE_NAMESPACE
+
+// FIXME: This is copied verbatim from WebReplayInputCoders.cpp
+#define ENCODE_TYPE_WITH_KEY(_encodedValue, _type, _key, _value) \
+_encodedValue.put<_type>(ASCIILiteral(#_key), _value)
+
+using WebCore::MemoizedDOMResultBase;
+
+namespace JSC {
+
+EncodedValue EncodingTraits<NondeterministicInputBase>::encodeValue(const NondeterministicInputBase& input)
+{
+    EncodedValue encodedValue = EncodedValue::createObject();
+    const AtomicString& type = input.type();
+
+    ENCODE_TYPE_WITH_KEY(encodedValue, String, type, type.string());
+
+#define ENCODE_IF_TYPE_TAG_MATCHES(name) \
+    if (type == InputTraits<name>::type()) { \
+        InputTraits<name>::encode(encodedValue, static_cast<const name&>(input)); \
+        return encodedValue; \
+    } \
+
+    JS_REPLAY_INPUT_NAMES_FOR_EACH(ENCODE_IF_TYPE_TAG_MATCHES)
+    WEB_REPLAY_INPUT_NAMES_FOR_EACH(ENCODE_IF_TYPE_TAG_MATCHES)
+    WK_REPLAY_INPUT_NAMES_FOR_EACH(ENCODE_IF_TYPE_TAG_MATCHES)
+#undef ENCODE_IF_TYPE_TAG_MATCHES
+
+    // The macro won't work here because of the class template argument.
+    if (type == InputTraits<MemoizedDOMResultBase>::type()) {
+        InputTraits<MemoizedDOMResultBase>::encode(encodedValue, static_cast<const MemoizedDOMResultBase&>(input));
+        return encodedValue;
+    }
+
+    ASSERT_NOT_REACHED();
+    return EncodedValue();
+}
+
+} // namespace JSC
+
+#endif // ENABLE(WEB_REPLAY)
diff --git a/Source/WebKit2/WebProcess/Replay/WKReplayInputCoders.h b/Source/WebKit2/WebProcess/Replay/WKReplayInputCoders.h
new file mode 100644
index 0000000..e12f187
--- /dev/null
+++ b/Source/WebKit2/WebProcess/Replay/WKReplayInputCoders.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013, 2014 University of Washington. All rights reserved.
+ * Copyright (C) 2014 Apple Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1.  Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ * 2.  Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef WKReplayInputCoders_h
+#define WKReplayInputCoders_h
+
+#if ENABLE(WEB_REPLAY)
+
+#include <JavaScriptCore/EncodedValue.h>
+#include <JavaScriptCore/NondeterministicInput.h>
+
+// Template specializations must be defined in the same namespace as the template declaration.
+namespace JSC {
+
+template<> struct EncodingTraits<JSC::NondeterministicInputBase> {
+    typedef JSC::NondeterministicInputBase DecodedType;
+
+    static EncodedValue encodeValue(const JSC::NondeterministicInputBase& input);
+    static bool decodeValue(EncodedValue&, std::unique_ptr<JSC::NondeterministicInputBase>& input);
+};
+
+} // namespace JSC
+
+#endif // ENABLE(WEB_REPLAY)
+
+#endif // WKReplayInputCoders_h
diff --git a/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.cpp b/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.cpp
index 87c6a2b..f5b7652 100644
--- a/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.cpp
+++ b/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.cpp
@@ -21,24 +21,36 @@
  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
 #include "WebReplayClient.h"
 
 #if ENABLE(WEB_REPLAY)
 
+#include "WKReplayInputCoders.h"
 #include "WebPage.h"
 #include <WebCore/EventLoopInput.h>
 #include <WebCore/ReplayController.h>
 
 namespace WebKit {
 
 void WebReplayClient::dispatchInput(WebCore::EventLoopInputBase& input)
 {
     input.dispatch(*m_page->corePage());
 }
 
+bool WebReplayClient::encodeInput(const NondeterministicInputBase& input, EncodedValue& encodedInput)
+{
+    encodedInput = EncodingTraits<NondeterministicInputBase>::encodeValue(input);
+    return true;
+}
+
+bool WebReplayClient::decodeInput(EncodedValue& encodedInput, std::unique_ptr<NondeterministicInputBase>& decodedInput)
+{
+    return EncodingTraits<NondeterministicInputBase>::decodeValue(encodedInput, decodedInput);
+}
+
 } // namespace WebKit
 
 #endif // ENABLE(WEB_REPLAY)
diff --git a/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.h b/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.h
index cee44c3..f6928e1 100644
--- a/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.h
+++ b/Source/WebKit2/WebProcess/WebCoreSupport/WebReplayClient.h
@@ -37,18 +37,21 @@ class WebPage;
 class WebReplayClient : public WebCore::ReplayClient {
 public:
     WebReplayClient(WebPage* page)
         : m_page(page)
     {
     }
 
 private:
     virtual void dispatchInput(WebCore::EventLoopInputBase&) override;
 
+    virtual bool encodeInput(const JSC::NondeterministicInputBase&, JSC::EncodedValue&) override;
+    virtual bool decodeInput(JSC::EncodedValue&, std::unique_ptr<JSC::NondeterministicInputBase>&) override;
+
     WebPage* m_page;
 };
 
 } // namespace WebKit
 
 #endif // ENABLE(WEB_REPLAY)
 
 #endif // WebReplayClient_h
-- 
2.0.1

